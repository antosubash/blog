<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
        <channel>
            <title>Anto Subash</title>
            <link>https://blog.antosubash.com</link>
            <description>Anto Subash's Blog</description>
            <language>en</language>
            <item>
          <title>Migrating Identity Service to OpenIddict Module</title>
          <link>https://blog.antosubash.com/posts/migrating-identity-service-to-open-iddict-module</link>
          <guid>https://blog.antosubash.com/posts/migrating-identity-service-to-open-iddict-module</guid>
          <pubDate>Mon, 05 Dec 2022 20:59:17 GMT</pubDate>
          <description>In this post we will see how to replace Identity server with OpenIddict in our microservice</description>
          <content:encoded><![CDATA[
## Table of contents

## Introduction

In this post we will see how to replace Identity server with OpenIddict in our microservice. We will use the same microservice we created in the previous posts. If you haven't read the previous post, you can read it [here](/posts/abp-microservice-series).

## OpenIddict

OpenIddict aims at providing a versatile solution to implement OpenID Connect client, server and token validation support in any ASP.NET Core 2.1 (and higher) application. ASP.NET 4.6.1 (and higher) applications are also fully supported thanks to a native Microsoft.Owin 4.2 integration.

OpenIddict fully supports the code/implicit/hybrid flows, the client credentials/resource owner password grants and the device authorization flow.

OpenIddict natively supports Entity Framework Core, Entity Framework 6 and MongoDB out-of-the-box and custom stores can be implemented to support other providers.

## Reason for the migration

The main reason for the migration is that the Identity server is not maintained anymore. The last release was in 2019. The latest version of ABP framework is using OpenIddict. So, it is better to use the latest version of the framework. you can read more about the migration [here](https://docs.abp.io/en/abp/6.0/Migration-Guides/OpenIddict-Step-by-Step). you can learn more about the background of the migration [here](https://github.com/abpframework/abp/issues/11989)

## Create a new temp project

We will create a temp project and copy the `AuthServer` project from the temp project to the solution. We did the same while creating the microservice. We will do the same here.

Create a new folder and create the solution using the following command.

```bash
abp new Tasky -t app -u angular --separate-auth-server -dbms PostgreSQL
```

This will create a new solution with the `AuthServer` project. Copy the `AuthServer` project from the temp project to the solution. after copying the project, copy `angular` folder from the temp project to the solution. This will replace the existing `angular` folder.

### Update the ABP packages

To update the ABP packages, use the following command.

```bash
abp update
```

This will update all the ABP packages to the latest version. You can see the changes in the `*.csproj` files.

### Update the .Net Version

Update the .Net version to `6.0` in the `*.csproj` files.

```xml
<TargetFramework>net6.0</TargetFramework>
```

### Update the tye.yaml file

Update the `tye.yaml` file to add the `AuthServer` project.

```yaml
- name: tasky-auth-server
  project: apps/Tasky.AuthServer/Tasky.AuthServer.csproj
  bindings:
    - protocol: https
      port: 7600
```

## Configure the AuthServer

### Add Auth Server to the solution

Add the `AuthServer` project to the solution.

```bash
dotnet sln add .\apps\Tasky.AuthServer\Tasky.AuthServer.csproj
```

Add the Project references to the `AuthServer` project.

```bash
dotnet add .\apps\Tasky.AuthServer\Tasky.AuthServer.csproj reference .\services\administration\src\Tasky.AdministrationService.EntityFrameworkCore\Tasky.AdministrationService.EntityFrameworkCore.csproj

dotnet add .\apps\Tasky.AuthServer\Tasky.AuthServer.csproj reference .\services\identity\src\Tasky.IdentityService.EntityFrameworkCore\Tasky.IdentityService.EntityFrameworkCore.csproj

dotnet add .\apps\Tasky.AuthServer\Tasky.AuthServer.csproj reference .\services\saas\src\Tasky.SaasService.EntityFrameworkCore\Tasky.SaasService.EntityFrameworkCore.csproj

dotnet add .\apps\Tasky.AuthServer\Tasky.AuthServer.csproj reference .\shared\Tasky.Shared.Microservice.Hosting\Tasky.Shared.Microservice.Hosting.csproj
```

### Update the TaskyAuthServerModule Dependency

We will update the `TaskyAuthServerModule` dependency in the `AuthServer.csproj` file:

```csharp
    typeof(AdministrationServiceEntityFrameworkCoreModule),
    typeof(SaaSServiceEntityFrameworkCoreModule),
    typeof(IdentityServiceEntityFrameworkCoreModule),
    typeof(TaskyMicroserviceHosting)
```

### Configure RabbitMQ

We will use RabbitMQ to publish the events. So, we need to configure RabbitMQ in the `AuthServer` project.

Add the following section to the `appsettings.json` file:

```json
  "RabbitMQ": {
    "Connections": {
      "Default": {
        "HostName": "localhost"
      }
    },
    "EventBus": {
      "ClientName": "Tasky_AuthServer",
      "ExchangeName": "Tasky"
    }
  }
```

### Configure the Database

We will update the connection string in the `appsettings.json` file:

```json
  "ConnectionStrings": {
    "SaaS": "User ID=postgres;Password=postgres;Host=localhost;Port=5432;Database=SaasService;Pooling=false;",
    "IdentityService": "User ID=postgres;Password=postgres;Host=localhost;Port=5432;Database=IdentityService;Pooling=false;",
    "Administration": "User ID=postgres;Password=postgres;Host=localhost;Port=5432;Database=AdministrationService;Pooling=false;"
  },
```

### Update CORS and Redirect URIs

We will update the CORS and Redirect URIs in the `appsettings.json` file:

```json
  "App": {
    "SelfUrl": "https://localhost:44346",
    "ClientUrl": "http://localhost:4200",
    "CorsOrigins": "http://localhost:4200,http://localhost:3000,https://localhost:7001,https://localhost:7002,https://localhost:7003,https://localhost:7004,https://localhost:7005",
    "RedirectAllowedUrls": "http://localhost:4200,http://localhost:3000,https://localhost:7001"
  },
```

### Update the port number in the `AuthServer` project

We will update the port number in the `AuthServer` project to `7600` in the `AuthServer`. you can do this by updating the `launchSettings.json` file.

```json
  "applicationUrl": "https://localhost:7600;http://localhost:7600"
```

> Note: after updating the .Net version, you may get the error from non abp packages. You can update the non abp packages to the latest version.

Build the solution to make sure everything is working fine.

## Replace the IdentityServer with OpenIddict

Search for `IdentityServer` in the solution and replace it with `OpenIddict` in the `*.csproj` files and `*.cs` files.

## Update the IdentityServiceDbContext

Update the `IdentityServiceDbContext` class to inherit from `IOpenIddictDbContext`. This will add the required tables for the OpenIddict and remove the tables for the IdentityServer.

```csharp
    public DbSet<OpenIddictApplication> Applications { get; set; }
    public DbSet<OpenIddictAuthorization> Authorizations { get; set; }
    public DbSet<OpenIddictScope> Scopes { get; set; }
    public DbSet<OpenIddictToken> Tokens { get; set; }
```

### Add the migrations

After updating the `IdentityServiceDbContext` class, add the migrations using the following command.

```bash
dotnet ef migrations add Init-OpenIddict
```

This will add the migrations for the OpenIddict. Now, we can run the migrations using the following command.

```bash
dotnet ef database update
```

This will remove the tables for the IdentityServer and add the tables for the OpenIddict.

## Update the data seeder

We will need to update the data seeder in the `Tasky.DbMigrator`.

Create a new class `OpenIddictDataSeeder` and add the following code.

```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using Microsoft.Extensions.Configuration;
using OpenIddict.Abstractions;
using Volo.Abp.Authorization.Permissions;
using Volo.Abp.DependencyInjection;
using Volo.Abp.Guids;
using Volo.Abp.MultiTenancy;
using Volo.Abp.OpenIddict.Applications;
using Volo.Abp.PermissionManagement;
using Volo.Abp.Uow;
using Microsoft.Extensions.Localization;
using Volo.Abp;
using JetBrains.Annotations;

namespace Tasky.DbMigrator;

public class OpenIddictDataSeeder : ITransientDependency
{
    private readonly IConfiguration _configuration;
    private readonly ICurrentTenant _currentTenant;
    private readonly IGuidGenerator _guidGenerator;
    private readonly IAbpApplicationManager _applicationManager;
    private readonly IOpenIddictScopeManager _scopeManager;
    private readonly IPermissionDataSeeder _permissionDataSeeder;
    private readonly IStringLocalizer<OpenIddictResponse> L;

    public OpenIddictDataSeeder(
        IAbpApplicationManager applicationManager,
        IOpenIddictScopeManager scopeManager,
        IPermissionDataSeeder permissionDataSeeder,
        IStringLocalizer<OpenIddictResponse> l,
        IGuidGenerator guidGenerator,
        IConfiguration configuration,
        ICurrentTenant currentTenant)
    {
        _configuration = configuration;
        _applicationManager = applicationManager;
        _scopeManager = scopeManager;
        _permissionDataSeeder = permissionDataSeeder;
        _guidGenerator = guidGenerator;
        _currentTenant = currentTenant;
        L = l;
    }

    [UnitOfWork]
    public async virtual Task SeedAsync()
    {
        using (_currentTenant.Change(null))
        {
            await CreateApiResourcesAsync();
            await CreateClientsAsync();
        }
    }

    private async Task CreateClientsAsync()
    {
        var clients = _configuration.GetSection("Clients").Get<List<ServiceClient>>();
        var commonScopes = new[] {
            OpenIddictConstants.Permissions.Scopes.Address,
            OpenIddictConstants.Permissions.Scopes.Email,
            OpenIddictConstants.Permissions.Scopes.Phone,
            OpenIddictConstants.Permissions.Scopes.Profile,
            OpenIddictConstants.Permissions.Scopes.Roles,
            "offline_access"
        };

        foreach (var client in clients)
        {
            var isClientSecretAvailable = !string.IsNullOrEmpty(client.ClientSecret);

            await CreateClientAsync(
                    client.ClientId,
                    displayName: client.ClientId,
                    secret: isClientSecretAvailable ? client.ClientSecret : null,
                    type: isClientSecretAvailable ? OpenIddictConstants.ClientTypes.Confidential : OpenIddictConstants.ClientTypes.Public,
                    scopes: commonScopes.Union(client.Scopes).ToList(),
                    grantTypes: client.GrantTypes.ToList(),
                    redirectUris: client.RedirectUris,
                    postLogoutRedirectUris: client.PostLogoutRedirectUris,
                    consentType: OpenIddictConstants.ConsentTypes.Implicit
                );
        }
    }


    private async Task CreateApiResourcesAsync()
    {
        var apiResources = _configuration.GetSection("ApiResource").Get<string[]>();

        foreach (var item in apiResources)
        {
            await CreateApiResourceAsync(item);
        }
    }

    private async Task CreateApiResourceAsync(string name)
    {
        if (await _scopeManager.FindByNameAsync(name) == null)
        {
            await _scopeManager.CreateAsync(new OpenIddictScopeDescriptor
            {
                Name = name,
                DisplayName = name + " API",
                Resources =
                {
                    name
                }
            });
        }
    }

    private async Task CreateClientAsync(
        [NotNull] string name,
        [NotNull] string type,
        [NotNull] string consentType,
        string displayName,
        string secret,
        List<string> grantTypes,
        List<string> scopes,
        string[] redirectUris = null,
        string[] postLogoutRedirectUris = null,
        List<string> permissions = null)
    {
        if (!string.IsNullOrEmpty(secret) && string.Equals(type, OpenIddictConstants.ClientTypes.Public, StringComparison.OrdinalIgnoreCase))
        {
            throw new BusinessException(L["NoClientSecretCanBeSetForPublicApplications"]);
        }

        if (string.IsNullOrEmpty(secret) && string.Equals(type, OpenIddictConstants.ClientTypes.Confidential, StringComparison.OrdinalIgnoreCase))
        {
            throw new BusinessException(L["TheClientSecretIsRequiredForConfidentialApplications"]);
        }

        if (!string.IsNullOrEmpty(name) && await _applicationManager.FindByClientIdAsync(name) != null)
        {
            return;
            //throw new BusinessException(L["TheClientIdentifierIsAlreadyTakenByAnotherApplication"]);
        }

        var client = await _applicationManager.FindByClientIdAsync(name);
        if (client == null)
        {
            var application = new OpenIddictApplicationDescriptor
            {
                ClientId = name,
                Type = type,
                ClientSecret = secret,
                ConsentType = consentType,
                DisplayName = displayName
            };

            Check.NotNullOrEmpty(grantTypes, nameof(grantTypes));
            Check.NotNullOrEmpty(scopes, nameof(scopes));

            if (new[] { OpenIddictConstants.GrantTypes.AuthorizationCode, OpenIddictConstants.GrantTypes.Implicit }.All(grantTypes.Contains))
            {
                application.Permissions.Add(OpenIddictConstants.Permissions.ResponseTypes.CodeIdToken);
                if (string.Equals(type, OpenIddictConstants.ClientTypes.Public, StringComparison.OrdinalIgnoreCase))
                {
                    application.Permissions.Add(OpenIddictConstants.Permissions.ResponseTypes.CodeIdTokenToken);
                    application.Permissions.Add(OpenIddictConstants.Permissions.ResponseTypes.CodeToken);
                }
            }
            application.Permissions.Add(OpenIddictConstants.Permissions.Endpoints.Logout);


            foreach (var grantType in grantTypes)
            {
                if (grantType == OpenIddictConstants.GrantTypes.AuthorizationCode)
                {
                    application.Permissions.Add(OpenIddictConstants.Permissions.GrantTypes.AuthorizationCode);
                    application.Permissions.Add(OpenIddictConstants.Permissions.ResponseTypes.Code);
                }

                if (grantType == OpenIddictConstants.GrantTypes.AuthorizationCode || grantType == OpenIddictConstants.GrantTypes.Implicit)
                {
                    application.Permissions.Add(OpenIddictConstants.Permissions.Endpoints.Authorization);
                }

                if (grantType == OpenIddictConstants.GrantTypes.AuthorizationCode ||
                    grantType == OpenIddictConstants.GrantTypes.ClientCredentials ||
                    grantType == OpenIddictConstants.GrantTypes.Password ||
                    grantType == OpenIddictConstants.GrantTypes.RefreshToken ||
                    grantType == OpenIddictConstants.GrantTypes.DeviceCode)
                {
                    application.Permissions.Add(OpenIddictConstants.Permissions.Endpoints.Token);
                    application.Permissions.Add(OpenIddictConstants.Permissions.Endpoints.Revocation);
                    application.Permissions.Add(OpenIddictConstants.Permissions.Endpoints.Introspection);
                }

                if (grantType == OpenIddictConstants.GrantTypes.ClientCredentials)
                {
                    application.Permissions.Add(OpenIddictConstants.Permissions.GrantTypes.ClientCredentials);
                }

                if (grantType == OpenIddictConstants.GrantTypes.Implicit)
                {
                    application.Permissions.Add(OpenIddictConstants.Permissions.GrantTypes.Implicit);
                }

                if (grantType == OpenIddictConstants.GrantTypes.Password)
                {
                    application.Permissions.Add(OpenIddictConstants.Permissions.GrantTypes.Password);
                }

                if (grantType == OpenIddictConstants.GrantTypes.RefreshToken)
                {
                    application.Permissions.Add(OpenIddictConstants.Permissions.GrantTypes.RefreshToken);
                }

                if (grantType == OpenIddictConstants.GrantTypes.DeviceCode)
                {
                    application.Permissions.Add(OpenIddictConstants.Permissions.GrantTypes.DeviceCode);
                    application.Permissions.Add(OpenIddictConstants.Permissions.Endpoints.Device);
                }

                if (grantType == OpenIddictConstants.GrantTypes.Implicit)
                {
                    application.Permissions.Add(OpenIddictConstants.Permissions.ResponseTypes.IdToken);
                    if (string.Equals(type, OpenIddictConstants.ClientTypes.Public, StringComparison.OrdinalIgnoreCase))
                    {
                        application.Permissions.Add(OpenIddictConstants.Permissions.ResponseTypes.IdTokenToken);
                        application.Permissions.Add(OpenIddictConstants.Permissions.ResponseTypes.Token);
                    }
                }
            }

            var buildInScopes = new[]
            {
                OpenIddictConstants.Permissions.Scopes.Address,
                OpenIddictConstants.Permissions.Scopes.Email,
                OpenIddictConstants.Permissions.Scopes.Phone,
                OpenIddictConstants.Permissions.Scopes.Profile,
                OpenIddictConstants.Permissions.Scopes.Roles,
                "offline_access"
            };

            foreach (var scope in scopes)
            {
                if (buildInScopes.Contains(scope))
                {
                    application.Permissions.Add(scope);
                }
                else
                {
                    application.Permissions.Add(OpenIddictConstants.Permissions.Prefixes.Scope + scope);
                }
            }

            if (redirectUris != null)
            {
                foreach (var redirectUri in redirectUris)
                {
                    if (!redirectUri.IsNullOrEmpty())
                    {
                        if (!Uri.TryCreate(redirectUri, UriKind.Absolute, out var uri) || !uri.IsWellFormedOriginalString())
                        {
                            throw new BusinessException(L["InvalidRedirectUri", redirectUri]);
                        }

                        if (application.RedirectUris.All(x => x != uri))
                        {
                            application.RedirectUris.Add(uri);
                        }
                    }
                }
            }

            if (postLogoutRedirectUris != null)
            {
                foreach (var postLogoutRedirectUri in postLogoutRedirectUris)
                {
                    if (!postLogoutRedirectUri.IsNullOrEmpty())
                    {
                        if (!Uri.TryCreate(postLogoutRedirectUri, UriKind.Absolute, out var uri) || !uri.IsWellFormedOriginalString())
                        {
                            throw new BusinessException(L["InvalidPostLogoutRedirectUri", postLogoutRedirectUri]);
                        }

                        if (application.PostLogoutRedirectUris.All(x => x != uri))
                        {
                            application.PostLogoutRedirectUris.Add(uri);
                        }
                    }
                }
            }

            if (permissions != null)
            {
                await _permissionDataSeeder.SeedAsync(
                    ClientPermissionValueProvider.ProviderName,
                    name,
                    permissions,
                    null
                );
            }

            await _applicationManager.CreateAsync(application);
        }
    }
}
```

Create a new class `OpenIddictDataSeedContributor` and add the following code:

```csharp
using System.Threading.Tasks;
using Volo.Abp.Data;
using Volo.Abp.DependencyInjection;

namespace Tasky.DbMigrator;

public class OpenIddictDataSeedContributor : IDataSeedContributor, ITransientDependency
{
    private readonly OpenIddictDataSeeder _OpenIddictDataSeeder;

    public OpenIddictDataSeedContributor(OpenIddictDataSeeder OpenIddictDataSeeder)
    {
        _OpenIddictDataSeeder = OpenIddictDataSeeder;
    }


    public async Task SeedAsync(DataSeedContext context)
    {
        await _OpenIddictDataSeeder.SeedAsync();
    }
}
```

With the above code, we have created a new data seed contributor for OpenIddict. Now, we can delete the old `IdentityServerDataSeedContributor` class and `IdentityServerDataSeeder` class.

## Seed the Application Client

Now, we have our OpenIddict data seed contributor. We can run the `DbMigration` project to create the seed data in the database.

```bash
dotnet run
```

This will create the new Scopes and Clients in the database. We can check the database to see the new data.

## Test the AuthServer

We can test the AuthServer by running the `AuthServer` project:

```bash
dotnet run
```

If everything is configured correctly, we will be able to login to the AuthServer.

Now, run all the projects using tye and test the entire application with the angular application.

## Conclusion

In this article, I have shown how to migrate the IdentityServer to OpenIddict. We have also seen how to create a new data seed contributor for OpenIddict and configure the AuthServer to use RabbitMQ and PostgreSQL. We have also tested the AuthServer and the entire application.

you can find the source code for this article on [GitHub](https://github.com/antosubash/AbpMicroservice)
]]></content:encoded>
          </item><item>
          <title>Automatically version and release .Net Application</title>
          <link>https://blog.antosubash.com/posts/automatic-version-and-release</link>
          <guid>https://blog.antosubash.com/posts/automatic-version-and-release</guid>
          <pubDate>Sun, 23 Oct 2022 00:00:00 GMT</pubDate>
          <description>In this post you will see how to automatically version and release a .Net Application using GitHub Actions</description>
          <content:encoded><![CDATA[## Table of contents

## Introduction

In this post we will see how to automatically version and release a .Net Application using GitHub Actions. We will use the conventional commits specification to automatically version and release our application.

## Conventional Commits

Conventional Commits is a specification for adding human and machine readable meaning to commit messages. It provides an easy set of rules for creating an explicit commit history; which makes it easier to write automated tools on top of. This convention dovetails with [SemVer](https://semver.org), by describing the features, fixes, and breaking changes made in commit messages. If you want to know more about conventional commits, please check [this](https://www.conventionalcommits.org/en/v1.0.0/).

## Libraries used

- [Versionize](https://github.com/versionize/versionize) - To version the application
- [Husky.Net](https://github.com/alirezanet/husky.net) - To run git hooks in dotnet
- Github Actions - To automatically release the application

Please note that we will use the `Versionize` library to version the application and `Husky.Net` to run git hooks in dotnet. These are amazing libraries and I highly recommend them. please check them out if you want to know more about them and give them a star. It will help the authors to keep working on them. I'm not affiliated with them in any way. I just like them and I'm using them in this post.

## Versionize

Versionize is a library that can be used to version a .Net application. It uses the conventional commits specification to automatically version the application. It can also be used to automatically release the application. It can be used in any .Net application. It can be used in a console application, a web application, a web api, a library, etc. The current supported project types are: `csproj`, `fsproj`, `vbproj`. There is PR to support `.props` projects. hopefully, it will be merged soon.

## Husky.Net

Husky.Net is a library that can be used to run git hooks in dotnet. It is a port of the famous [Husky](https://github.com/typicode/husky) library. Husky is a library that can be used to run git hooks in nodejs. Husky.Net can be used to run git hooks in dotnet. It can be used in any .Net application.

> Husky is not required for this but it is a nice to have. It will help us to keep the commit messages clean and consistent. If you don't want to use it you can skip this section. But I highly recommend it.

## GitHub Actions

I think there is no need to explain what GitHub Actions is. If you don't know what GitHub Actions is, please check [this](https://docs.github.com/en/actions).

## Create the .Net project

### Create a github repository

Create a github repository and clone it locally. You can use the following command to clone the repository.

```bash
git clone "url of the repository"
```

Now, we will create a .Net project and add it to the repository.

### Create the .Net project using this following command

Navigate to the your repository folder and run the following command to create a .Net project.

```bash
dotnet new console -n VersionMe -o .
```

Now we have a .Net console application. We will use this application to test the versioning and releasing.

## Add Version to the .Net project

To get started add version to you csproj file.

```xml
    <Version>1.0.0</Version>
```

Now we can install the versionize tool.

```bash
dotnet tool install --global Versionize
```

When you want to version the application, run the following command.

```bash
versionize
```

This will version the application, create a tag for the release and generate a changelog. You can find the changelog in the `CHANGELOG.md` file. make sure you push the tag to the remote repository.

```bash
git push --tags
```

For now we have versioned the application manually and tagged the release. we also have a changelog. but to create a release we need to do it manually. we need to use the GitHub UI. But we want to automate this process. We want to automatically create a release when we push a commit to the main branch. We will use GitHub Actions to do this.

Now lets automate this process using github actions.

## Creating github action

We will create a github action to version and release the application. Create a new file in the `.github/workflows` folder and name it `version-and-release.yml`. In the `version-and-release.yml` file, add the following code.

```yaml
name: Version and Release

on:
  push:
    branches: [ "main" ]

jobs:
  build:

    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v3
      with:
        fetch-depth: 0
    - name: Setup .NET
      uses: actions/setup-dotnet@v3
      with:
        dotnet-version: 6.0.x
    - name: Restore dependencies
      run: dotnet restore
    - name: Build
      run: dotnet build --no-restore
    - name: Install Versionize
      run: dotnet tool install --global Versionize
    - name: Setup git
      run: |
        git config --local user.email "antosubash@live.com"
        git config --local user.name "Anto Subash"
    - name: Versionize Release
      id: versionize
      run: versionize --changelog-all --exit-insignificant-commits
      continue-on-error: true
    - name: No release required
      if: steps.versionize.outcome != 'success'
      run: echo "Skipping Release. No release required."
    - name: Push changes to GitHub
      if: steps.versionize.outcome == 'success'
      uses: ad-m/github-push-action@master
      with:
        github_token: ${{ secrets.GITHUB_TOKEN }}
        branch: ${{ github.ref }}
        tags: true
    - name: "Create release"
      if: steps.versionize.outcome == 'success'
      uses: "actions/github-script@v5"
      with:
        github-token: "${{ secrets.GITHUB_TOKEN }}"
        script: |
          try {
            const tags_url = context.payload.repository.tags_url + "?per_page=1"
            const result = await github.request(tags_url)
            const current_tag = result.data[0].name
            await github.rest.repos.createRelease({
              draft: false,
              generate_release_notes: true,
              name: current_tag,
              owner: context.repo.owner,
              prerelease: false,
              repo: context.repo.repo,
              tag_name: current_tag,
            });
          } catch (error) {
            core.setFailed(error.message);
          }
```

This will run when we push a commit to the main branch. It will version the application, create a tag for the release and generate a changelog. It will also create a release using the GitHub API. You can find the changelog in the `CHANGELOG.md` file.

If you are new to GitHub Actions, please check [this](https://docs.github.com/en/actions/learn-github-actions/introduction-to-github-actions) to learn more about GitHub Actions. It will help you to understand the above code.

Here is a brief explanation of the above code.

```yaml
name: Version and Release
```

This is the name of the action.

```yaml
on:
  push:
    branches: [ "main" ]
```

This will run the action when we push a commit to the main branch.

```yaml
jobs:
  build:
    runs-on: ubuntu-latest
```

This is the job that will run. We are using ubuntu-latest as the operating system.

```yaml
- uses: actions/checkout@v3
  with:
    fetch-depth: 0
```

This will checkout the repository.

```yaml
- name: Setup .NET
  uses: actions/setup-dotnet@v3
  with:
    dotnet-version: 6.0.x
```

This will setup the .Net environment.

```yaml
- name: Restore dependencies
  run: dotnet restore
```

This will restore the dependencies.

```yaml
- name: Build
  run: dotnet build --no-restore
```

This will build the application.

```yaml
- name: Install Versionize
  run: dotnet tool install --global Versionize
```

This will install the versionize tool.

```yaml
- name: Setup git
  run: |
        git config --local user.email "antosubash@live.com"
        git config --local user.name "Anto Subash"
```

This will setup the git user name and email.

```yaml
- name: Versionize Release
  id: versionize
  run: versionize --changelog-all --exit-insignificant-commits
  continue-on-error: true
```

This will version the application, create a tag for the release and generate a changelog. You can find the changelog in the `CHANGELOG.md` file. 

```yaml
- name: No release required
  if: steps.versionize.outcome != 'success'
  run: echo "Skipping Release. No release required."
```

This will check if the versionize command was successful. If it was successful, it will continue to the next step. If it was not successful, it will skip the release.

```yaml
- name: Push changes to GitHub
  if: steps.versionize.outcome == 'success'
  uses: ad-m/github-push-action@master
  with:
    github_token: ${{ secrets.GITHUB_TOKEN }}
    branch: ${{ github.ref }}
    tags: true
```

This will push the changes to the GitHub repository.

```yaml
- name: "Create release"
  if: steps.versionize.outcome == 'success'
  uses: "actions/github-script@v5"
  with:
    github-token: "${{ secrets.GITHUB_TOKEN }}"
    script: |
      try {
        const tags_url = context.payload.repository.tags_url + "?per_page=1"
        const result = await github.request(tags_url)
        const current_tag = result.data[0].name
        await github.rest.repos.createRelease({
          draft: false,
          generate_release_notes: true,
          name: current_tag,
          owner: context.repo.owner,
          prerelease: false,
          repo: context.repo.repo,
          tag_name: current_tag,
        });
      } catch (error) {
        core.setFailed(error.message);
      }
```

This will create a release using the GitHub API.

## Adding Husky.Net

We will use Husky.Net to lint the commit message. this will make the commit message follow the conventional commits standard.

> As I said earlier, This is not required. But it is a nice to have. If you don't want to use it you can skip this section. But I highly recommend it.

Follow the steps here to add Husky.Net to your project. <https://alirezanet.github.io/Husky.Net/guide/getting-started.html#installation>

if you are new to git hooks, please check this <https://githooks.com>. It will help you to understand what git hooks are.

### Add a pre-commit hook

We will add a pre-commit hook to lint the commit message. Husky.Net will run the pre-commit hook before the commit is made.

```bash
dotnet husky add pre-commit
```

This will add a pre-commit hook to your project. You can find the hook in the `.husky` folder. In the `pre-commit` file, you can add the commands you want to run before the commit is made. In our case, we will run a group of command. This is a good example in case you want to run multiple commands before the commit is made.

```bash
husky run -v --group "pre-commit"
```

### Add commit-msg hook

We will add a commit msg hook to lint the commit message before the commit is made. Husky.Net will run the commit msg hook before the commit is made.

```bash
dotnet husky add commit-msg
```

This will add a commit msg hook to your project. You can find the hook in the `.husky` folder. In the `commit-msg` file, you can add the commands you want to run before the commit is made. In our case, we will run commit-msg.

```bash
husky run --name "commit-message-linter" --args "$1"
echo
echo Great work! ðŸ¥‚
echo
```

### Add a commit message linter

We will add a commit message linter to lint the commit message. Husky.Net will run the commit message linter before the commit is made. Create a new folder in the `.husky` folder and name it `csx` (csx stands for C# script). In the `csx` folder, create a new file and name it `commit-lint.csx`. In the `commit-lint.csx` file, add the following code.

```csharp
using System.Text.RegularExpressions;

private var pattern = @"^(?=.{1,90}$)(?:build|feat|ci|chore|docs|fix|perf|refactor|revert|style|test|wip)(?:\(.+\))*(?::).{4,}(?:#\d+)*(?<![\.\s])$";
private var msg = File.ReadAllLines(Args[0])[0];

if (Regex.IsMatch(msg, pattern))
    return 0;

Console.ForegroundColor = ConsoleColor.Red;
Console.WriteLine("Invalid commit message");
Console.ResetColor();
Console.WriteLine("e.g: 'feat(scope): subject' or 'fix: subject'");
Console.ForegroundColor = ConsoleColor.Gray;
Console.WriteLine("more info: https://www.conventionalcommits.org/en/v1.0.0/");

return 1;
```

## Update the task runner

Now we have our hooks ready. We need to update the task runner to run the hooks. Open the `task-runner.json` file and update the tasks.

```json
{
   "tasks": [
     {
       "name": "commit-message-linter",
       "command": "husky",
       "args": [
         "exec",
         ".husky/csx/commit-lint.csx",
         "--args",
         "${args}"
       ]
     },
     {
       "name": "dotnet-format",
       "group": "pre-commit",
       "command": "dotnet-format",
       "args": ["--include", "${staged}"],
       "include": ["**/*.cs"]
     }
   ]
}
```

## Commit and push

Now we are ready to commit and push our changes. Commit and push your changes. You can find the commit message linter in action.

if you followed the steps correctly, you should see the following output when you didn't follow the conventional commits standard.

```bash
[Husky] ðŸš€ Loading tasks ...
--------------------------------------------------
--------------------------------------------------
[Husky] âš¡ Preparing task 'dotnet-format'
[Husky] ðŸ’¤ Skipped, no matched files
--------------------------------------------------
[Husky] ðŸš€ Loading tasks ...
--------------------------------------------------
[Husky] âš¡ Preparing task 'commit-message-linter'
[Husky] âŒ› Executing task 'commit-message-linter' ...
Invalid commit message
e.g: 'feat(scope): subject' or 'fix: subject'
More info: https://www.conventionalcommits.org/en/v1.0.0/
script execution failed

  âŒ Task 'commit-message-linter' failed in 2.445ms

husky - commit-msg hook exited with code 1 (error)
```

if you commit message is valid, you should see the following output.

```bash
[Husky] ðŸš€ Loading tasks ...
--------------------------------------------------
[Husky] âš¡ Preparing task 'dotnet-format'
[Husky] ðŸ’¤ Skipped, no matched files
--------------------------------------------------
[Husky] ðŸš€ Loading tasks ...
--------------------------------------------------
[Husky] âš¡ Preparing task 'commit-message-linter'
[Husky] âŒ› Executing task 'commit-message-linter' ...
[Husky]  âœ” Successfully executed in 404ms
--------------------------------------------------

Great work! ðŸ¥‚
```

## Attach Husky.Net to your project

To make things easier for other developers, you can attach Husky.Net to your project.

```bash
dotnet husky attach <path-to-project-file>
```

This will add required configuration to your project file. You can find the configuration in the `PropertyGroup` section.

```xml
<Target Name="husky" BeforeTargets="Restore;CollectPackageReferences" Condition="'$(HUSKY)' != 0">
   <Exec Command="dotnet tool restore"  StandardOutputImportance="Low" StandardErrorImportance="High"/>
   <Exec Command="dotnet husky install" StandardOutputImportance="Low" StandardErrorImportance="High"
         WorkingDirectory="../../" />  <!--Update this to the relative path to your project root dir -->
</Target>
```

## Conclusion

In this article, we have seen how to version and release a dotnet application using versionize and github actions. You can find the source code in the [github repository](https://github.com/antosubash/dotnet-version-and-release) for this article. If you have any questions or suggestions, please leave a comment below. Thanks for reading. Happy coding! ðŸš€ ðŸš€ ðŸš€
]]></content:encoded>
          </item><item>
          <title>MicroK8s - Hassle-free Kubernetes</title>
          <link>https://blog.antosubash.com/posts/microk8s-gettings-started</link>
          <guid>https://blog.antosubash.com/posts/microk8s-gettings-started</guid>
          <pubDate>Thu, 15 Sep 2022 14:30:14 GMT</pubDate>
          <description>In this post we will see how to get started with the MicroK8s Kubernetes distribution.</description>
          <content:encoded><![CDATA[
## Table of contents

## Introduction

In this post we will see how to get started with the microk8s and deploy a simple service. We will see how to access the service from outside the cluster using ingress controller. We will also see how to use the cert-manager to get a valid ssl certificate for the service and then how to use the docker registry to store the docker images and how to use the postgres database in the microk8s cluster. We will use tye to build the application and deploy it in the microk8s cluster.

## What is MicroK8s?

MicroK8s is the easiest and fastest way to get Kubernetes up and running. Experiment with the latest upstream features and toggle services on and off. Seamlessly move your work from dev to production. It is Minimal and CNCF-certified distribution. it has Batteries included and sensible defaults. Microk8s is built by the Kubernetes team at Canonical. It is a single package of kubernetes that installs on 42 flavours of Linux. It works on all major Linux distributions, Windows, and macOS.

## Why use MicroK8s?

After moving away from docker swarm. I was looking for simple and easy to use kubernetes distribution. After trying out few options I have settled on microk8s as best option for the replacement of docker swarm. It is very easy to setup and managing it very easy and its perfect for my personal use. It provides all the features I need in the form of addons and removes most of the complexity in managing the kubernetes cluster. It is perfect for personal use. If you a developer who wants to use the kubernetes cluster without the complexities of managing the cluster this is the best option. It is also perfect for the small teams who want to use the kubernetes cluster for their development and testing.

## What is the cost?

In this post I will create a single node cluster which will cost around 15â‚¬ or $. I'm going to use hetzner cloud and you can use the referral link [https://hetzner.cloud/?ref=ENhA4rCZ5JUM](https://hetzner.cloud/?ref=ENhA4rCZ5JUM) and get 20â‚¬ for free to try it out.

## What are the goals

The goals are as follows

- Setup and connect to the kubernetes cluster using kubectl
- Setup reverse proxy to redirect traffic to containers (nginx) and lets encrypt for ssl.
- Deploy registry and postgres with storage
- Deploy a .Net application which connects to the postgres database

## Parts

[Part 1. Setup MicroK8s With Ubuntu](/posts/setup-micro-k8s-with-ubuntu)

[Part 2. Setup Nginx and cert-manager in MicroK8s](/posts/setup-nginx-and-cert-manager-in-micro-k8s)

[Part 3. Deploy docker registry and postgres database in MicroK8s](/posts/deploy-docker-registry-and-postgres-database-in-micro-k8s)

[Part 4. Create and deploy .Net application in MicroK8s](/posts/create-and-deploy-dotnet-application-in-micro-k8s)

## Repository

you can find most of the code and yaml files used in the series [here](https://github.com/antosubash/microk8s-hetzner-deployment)

## Conclusion

This series is created with developers in mind. I wanted to show how easy it is to use k8s without the complexities. I think after docker swarm this is the best option for the my personal use. Give it a try and let me know how do you like it. I will be happy to hear your feedback. If you have any questions or suggestions please leave a comment below. I will be happy to answer them.
]]></content:encoded>
          </item><item>
          <title>Create and deploy .Net application in MicroK8s</title>
          <link>https://blog.antosubash.com/posts/create-and-deploy-dotnet-application-in-micro-k8s</link>
          <guid>https://blog.antosubash.com/posts/create-and-deploy-dotnet-application-in-micro-k8s</guid>
          <pubDate>Wed, 14 Sep 2022 19:55:43 GMT</pubDate>
          <description>In this post we will create a simple abp application and deploy it in the microk8s instance.</description>
          <content:encoded><![CDATA[
## Table of contents

## Introduction

In this post we will create a simple abp application and deploy it in the microk8s instance. We will use tye to deploy the application in the cluster and setup the ingress for the application the ingress will use cert-manager to get the certificate for the application. this app will connect to a postgres database to store its data.

## Parts

[Part 1. Setup MicroK8s With Ubuntu](/posts/setup-micro-k8s-with-ubuntu)

[Part 2. Setup Nginx and cert-manager in MicroK8s](/posts/setup-nginx-and-cert-manager-in-micro-k8s)

[Part 3. Deploy docker registry and postgres database in MicroK8s](/posts/deploy-docker-registry-and-postgres-database-in-micro-k8s)

Part 4. Create and deploy .Net application in MicroK8s (this post)

## Repository

you can find the sample application we will use in this post [here](https://github.com/antosubash/abp-single-layer) and the yaml files used in this post [here](https://github.com/antosubash/abp-single-layer/blob/main/todoapp-generate-production.yaml)

## Create a new application

We will use the abp cli to create a new application. If you want to create a new application you can use the following command.

```bash
abp new TodoApp -t app-nolayers --preview -dbms PostgreSQL
```

We are using the app-nolayers template and we are using the PostgreSQL database. You can use the other templates as well. You can find more information about this template [here](https://docs.abp.io/en/abp/latest/Startup-Templates/Application-Single-Layer).

## Build the application

We will use the tye to build the application. You can find more information about tye [here](https://github.com/dotnet/tye)

```bash
tye init # this will create a tye.yaml file
tye build # this will build the application
```

## Update the application

We will update the application and make some changes. we will remove the migration check and migrate the database on startup. We will also update the tye file with registry information.

lets update the `Program.cs` file with the following code.

```csharp
var builder = WebApplication.CreateBuilder(args);
builder.Host.AddAppSettingsSecretsJson()
    .UseAutofac()
    .UseSerilog();
await builder.AddApplicationAsync<TodoAppModule>();
var app = builder.Build();
await app.InitializeApplicationAsync();
await app.Services.GetRequiredService<TodoAppDbMigrationService>(). MigrateAsync(); // add this line
Log.Information("Starting TodoApp.");
await app.RunAsync();
return 0;
```

Since we are going to use nginx to serve the application we need to add the forwarded headers middleware. We will add the following code to the `TodoAppModule.cs` file.

```csharp
context.Services.Configure<ForwardedHeadersOptions>(options =>
        {
            options.ForwardedHeaders =
                ForwardedHeaders.XForwardedProto;
        }); // add this line in ConfigureServices method

app.UseForwardedHeaders(); // add this line in  OnApplicationInitialization method
```

lets update the `tye.yaml` file with the following code.

```yaml
name: todoapp
registry: registry.kdev.antosubash.com
services:
- name: todoapp
  project: TodoApp/TodoApp.csproj
```

lets add the version to the `TodoApp.csproj` file.

```xml
<Project Sdk="Microsoft.NET.Sdk.Web">
  <PropertyGroup>
    <TargetFramework>net6.0</TargetFramework>
    <Version>1.0.0</Version> <!-- add this line -->
  </PropertyGroup>
</Project>
```

lets build the application again.

```bash
tye build
```

## Push the application to the registry

lets push the application to the registry. we will use tye to push the application to the registry. tye will build the application and push it to the registry.

```bash
tye push
```

> this will push the application to the registry. make sure you have logged in to the registry before pushing the application.

## Deploy the application

lets deploy the application to the microk8s instance. the first thing is to generate the yaml files. we will use the tye to generate the yaml files.

```bash
tye generate
```

this will generate the yaml file. we will rename the generated yaml file to `todoapp-generate.yaml`. we will use the `todoapp-generate.yaml` file to deploy the application. before deploying the application we need to update the `todoapp-generate.yaml` file. we will update the image name and add the environment variables. we will also add the ingress resource. we will use the following code to update the `todoapp-generate.yaml` file.

```yaml
kind: Deployment
apiVersion: apps/v1
metadata:
  name: todoapp
  labels:
    app.kubernetes.io/name: 'todoapp'
    app.kubernetes.io/part-of: 'todoapp'
spec:
  replicas: 1
  selector:
    matchLabels:
      app.kubernetes.io/name: todoapp
  template:
    metadata:
      labels:
        app.kubernetes.io/name: 'todoapp'
        app.kubernetes.io/part-of: 'todoapp'
    spec:
      imagePullSecrets:
      - name: regcred
      containers:
      - name: todoapp
        image: registry.kdev.antosubash.com/todoapp:1.0.4
        imagePullPolicy: Always
        resources:
          limits:
            cpu: "1"
            memory: 1Gi
          requests:
            cpu: "0.5"
            memory: 1Gi
        env:
        - name: ASPNETCORE_URLS
          value: 'http://*'
        - name: PORT
          value: '80'
        - name: CONNECTIONSTRINGS__Default
          value: 'Host=postgres.default.svc.cluster.local;Port=5432;Database=TodoApp;User ID=postgres;Password=my_postgres_password;'
        - name: ASPNETCORE_ENVIRONMENT
          value: 'Production'
        - name: App__SelfUrl
          value: 'https://todoapp.kdev.antosubash.com'
        ports:
        - containerPort: 80
...
---
kind: Service
apiVersion: v1
metadata:
  name: todoapp
  labels:
    app.kubernetes.io/name: 'todoapp'
    app.kubernetes.io/part-of: 'todoapp'
spec:
  selector:
    app.kubernetes.io/name: todoapp
  type: ClusterIP
  ports:
  - name: http
    protocol: TCP
    port: 80
    targetPort: 80
...
---
kind: Ingress
apiVersion: networking.k8s.io/v1
metadata:
  name: http-ingress-todoapp
  annotations:
    cert-manager.io/cluster-issuer: "lets-encrypt"
    kubernetes.io/ingress.class: "public"
    nginx.ingress.kubernetes.io/rewrite-target: '/$2'
  labels:
    app.kubernetes.io/part-of: 'todoapp'
spec:
  tls:
  - hosts:
    - todoapp.kdev.antosubash.com
    secretName: todoapp-tls
  rules:
  - host: todoapp.kdev.antosubash.com
    http:
      paths:
      - backend:
          service:
            name: todoapp
            port:
              number: 80
        pathType: Prefix
        path: /()(.*)
...
```

lets deploy the application to the microk8s instance.

```bash
kubectl apply -f todoapp-generate.yaml
```

## Access the application

lets access the application. we will use the following url to access the application.

```bash
https://todoapp.kdev.antosubash.com
```

## Conclusion

This is the final post of the series. In this post we have seen how to deploy the application to the microk8s instance. we have also seen how to use the tye to deploy the application, build the application and push the application to the registry. we have also seen how to use the ingress resource to access the application. I hope you have enjoyed this series. I will see you in the next post.
]]></content:encoded>
          </item><item>
          <title>Deploy docker registry and postgres database in MicroK8s</title>
          <link>https://blog.antosubash.com/posts/deploy-docker-registry-and-postgres-database-in-micro-k8s</link>
          <guid>https://blog.antosubash.com/posts/deploy-docker-registry-and-postgres-database-in-micro-k8s</guid>
          <pubDate>Wed, 14 Sep 2022 19:53:18 GMT</pubDate>
          <description>In this post we will see how to deploy and secure the registry along with deploying a postgres database in microk8s</description>
          <content:encoded><![CDATA[
## Table of contents

## Introduction

In this post we will see how to deploy and secure the registry along with deploying a postgres database in microk8s. We will also see how to connect to the created registry. We will also see how to create a secret in kubernetes and use it in the deployment. We will also see how to create a persistent volume and use it in the deployment.  

## Parts

[Part 1. Setup MicroK8s With Ubuntu](/posts/setup-micro-k8s-with-ubuntu)

[Part 2. Setup Nginx and cert-manager in MicroK8s](/posts/setup-nginx-and-cert-manager-in-micro-k8s)

Part 3. Deploy docker registry and postgres database in MicroK8s (this post)

[Part 4. Create and deploy .Net application in MicroK8s](/posts/create-and-deploy-dotnet-application-in-micro-k8s)

## Docker Registry

### Registry login info

first lets create a username and password and store it in `registry.password` file.

```bash
touch registry.password
```

lets create the username and password.

```bash
docker run --entrypoint htpasswd httpd:2 -Bbn youruser yourpassword
```

lets store the username and password in the `registry.password` file.

```bash
docker run --entrypoint htpasswd httpd:2 -Bbn youruser yourpassword
```

> make sure to replace `youruser` and `yourpassword` with your own username and password.

this will output the username and password. copy the output and paste it in the `registry.password` file.

### Deploy registry

lets create a namespace for the registry.

```bash
microk8s kubectl create namespace registry
```

lets create a secret for the registry.

```bash
microk8s create secret generic auth-secret --from-file=registry.password -n registry
```

Now we have the auth-secret created. lets create the secret for the docker registry.

```yml
kubectl create secret docker-registry regcred -n default --docker-server=registry.yourdomain.com --docker-username=youruser --docker-password=yourpassword --docker-email=myemail@something.com
````

> make sure to replace the `yourdomain.com` with your domain name. also replace the `youruser` and `yourpassword` with the username and password you created earlier. also replace the `registry.yourdomain.com` with your domain name.

lets create the folder for the registry.

```bash
mkdir /mnt/registry
```

lets create the registry deployment.

```yml
apiVersion: v1
kind: Namespace
metadata:
  name: registry
  labels:
    app: registry
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: registry
  namespace: registry
  labels:
    app: registry
spec:
  replicas: 1
  selector:
    matchLabels:
      app: registry
  template:
    metadata:
      labels:
        app: registry
    spec:
      containers:
      - name: registry
        resources:
          requests:
            memory: "100Mi"
            cpu: "250m"
          limits:
            memory: "200Mi"
            cpu: "500m"
        image: registry:2
        ports:
        - containerPort: 5000
        volumeMounts:
        - name: repo-vol
          mountPath: "/var/lib/registry"
        - name: certs-vol
          mountPath: "/certs"
          readOnly: true
        - name: auth-vol
          mountPath: "/auth"
          readOnly: true
        env:
        - name: REGISTRY_AUTH
          value: "htpasswd"
        - name: REGISTRY_AUTH_HTPASSWD_REALM
          value: "Registry Realm"
        - name: REGISTRY_AUTH_HTPASSWD_PATH
          value: "/auth/registry.password"
        - name: REGISTRY_HTTP_TLS_CERTIFICATE
          value: "/certs/tls.crt"
        - name: REGISTRY_HTTP_TLS_KEY
          value: "/certs/tls.key"
        - name: VIRTUAL_HOST
          value: "registry.kdev.antosubash.com"
     
      volumes:
      - name: repo-vol
        hostPath:
          # directory location on host
          path: /mnt/registry
          # this field is optional
          type: Directory
      - name: certs-vol
        secret:
          secretName: registry-tls-secret
      - name: auth-vol
        secret:
          secretName: auth-secret
---
apiVersion: v1
kind: Service
metadata:
  name: docker-registry
  namespace: registry
spec:
  selector:
    app: registry
  ports:
  - port: 5000
    targetPort: 5000
---
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: registry
  namespace: registry
  labels:
    app: registry
  annotations:
    cert-manager.io/cluster-issuer: "lets-encrypt"
    nginx.ingress.kubernetes.io/backend-protocol: "HTTPS"
    nginx.ingress.kubernetes.io/proxy-body-size: 1024m
spec:
  tls:
  - hosts:
    - registry.kdev.antosubash.com
    secretName: registry-tls-secret
  rules:
  - host: registry.kdev.antosubash.com
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: docker-registry
            port:
              number: 5000   
```

> make sure to replace the `registry.kdev.antosubash.com` with your domain name.

apply the deployment.

```bash
microk8s kubectl apply -f registry.yml
```

lets check the pods.

```bash
microk8s kubectl get pods -n registry
```

lets check the services.

```bash
microk8s kubectl get services -n registry
```

lets check the ingress.

```bash
microk8s kubectl get ingress -n registry
```

Now we have the registry deployed. lets test it.

```bash
docker login registry.kdev.antosubash.com
```

> make sure to replace the `registry.kdev.antosubash.com` with your domain name.

if you managed to login to the registry, then you have successfully deployed the registry.

## Postgres Database

For this post, I am using the postgres database. you can use any database you want. I will be using the postgres database because it is the database I am most familiar with.

we will use the `PersistentVolume` to store the database data. so lets make we have the storage addon enabled.

```bash
microk8s status
```

if the storage addon is not enabled, then enable it.

```bash
microk8s enable hostpath-storage
```

Now we have the storage addon enabled. lets deploy the postgres database.

```yml
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: postgres-pvc
spec:
  accessModes: [ReadWriteOnce]
  resources: { requests: { storage: 5Gi } }
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: postgres
  labels:
    app: postgres
    name: postgres
spec:
  replicas: 1
  selector:
    matchLabels:
      app: postgres
      task: postgres
  template:
    metadata:
      labels:
        app: postgres
        task: postgres
    spec:
      containers:
        - name: postgres
          image: kartoza/postgis:12.0
          ports:
            - containerPort: 5432
          env:
            - name: POSTGRES_DB
              value: "test"
            - name: POSTGRES_USER
              value: postgres
            - name: POSTGRES_PASS
              value: "my_postgres_password"
            - name: --auth
              value: "md5"
            - name: POSTGRES_MULTIPLE_EXTENSIONS
              value: "postgis,hstore,postgis_topology"
          resources:
            requests:
              memory: "100Mi"
              cpu: "250m"
            limits:
              memory: "200Mi"
              cpu: "500m"
          volumeMounts:
            - name: postgres-data
              mountPath: /var/lib/postgresql
      volumes:
        - name: postgres-data
          persistentVolumeClaim:
            claimName: postgres-pvc
---
apiVersion: v1
kind: Service
metadata:
  name: postgres
  labels:
    app: postgres
spec:
  ports:
    - port: 5432
      targetPort: 5432
  selector:
    app: postgres
    task: postgres
---
```

apply the deployment.

```bash
microk8s kubectl apply -f postgres.yml
```

lets check the pods.

```bash
microk8s kubectl get pods
```

lets check the services.

```bash
microk8s kubectl get services
```

lets check the persistent volume claim.

```bash
microk8s kubectl get pvc
```

Now we have the postgres database deployed. lets test it.

To test the database, we will use the `adminer` tool. you can use any tool you want.

we will deploy the `adminer` tool.

```yml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: pgweb
spec:
  selector:
    matchLabels:
      app: pgweb
  template:
    metadata:
      labels:
        app: pgweb
    spec:
      containers:
      - name: pgweb
        image: adminer
        resources:
          limits:
            memory: "128Mi"
            cpu: "500m"
        ports:
        - containerPort: 8080
---
apiVersion: v1
kind: Service
metadata:
  name: pgweb-service
spec:
  selector:
    app: pgweb
  ports:
  - port: 8080
    targetPort: 8080
---
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: pgweb-ingress
  labels:
    name: pgweb-ingress
  annotations:
    kubernetes.io/ingress.class: "public"
    cert-manager.io/cluster-issuer: "lets-encrypt"
spec:
  tls:
    - hosts:
      - pgweb.kdev.antosubash.com
      secretName: pgweb-tls
  rules:
  - host: pgweb.kdev.antosubash.com
    http:
      paths:
      - pathType: Prefix
        path: "/"
        backend:
          service:
            name: pgweb-service
            port: 
              number: 8080
```

apply the deployment.

```bash
microk8s kubectl apply -f pgweb.yml
```

lets check the pods.

```bash
microk8s kubectl get pods
```

lets check the services.

```bash
microk8s kubectl get services
```

lets check the ingress.

```bash
microk8s kubectl get ingress
```

Now we have the `adminer` tool deployed. lets test it.

> make sure to replace the `pgweb.kdev.antosubash.com` with your domain name.

Lets visit the `adminer` tool. [https://pgweb.kdev.antosubash.com](https://pgweb.kdev.antosubash.com) and login with the following credentials.

```bash
System: PostgreSQL
Server: postgres.default.svc.cluster.local
Username: postgres
Password: my_postgres_password
Database: test
```

## Conclusion

In this post, we have deployed the docker registry and postgres database to the microk8s cluster. we have also deployed the `adminer` tool to test the database. In the next post, we will deploy a simple dotnet core application to the microk8s cluster.

[Part 4. Create and deploy .Net application in MicroK8s](/posts/create-and-deploy-dotnet-application-in-micro-k8s)

## Credits

Docker registry is secured based on this post <https://timvw.be/2021/11/08/hosting-a-secure-registry-on-microk8s/>
]]></content:encoded>
          </item><item>
          <title>Setup Nginx and cert-manager in MicroK8s</title>
          <link>https://blog.antosubash.com/posts/setup-nginx-and-cert-manager-in-micro-k8s</link>
          <guid>https://blog.antosubash.com/posts/setup-nginx-and-cert-manager-in-micro-k8s</guid>
          <pubDate>Wed, 14 Sep 2022 19:51:51 GMT</pubDate>
          <description>In this post we will see how to setup nginx reverse proxy and cert-manager in microk8s</description>
          <content:encoded><![CDATA[
## Table of contents

## Introduction

In this post we will see how to setup nginx reverse proxy and cert-manager in microk8s. We will use the nginx ingress controller to create a reverse proxy for our applications. We will also use cert-manager to create and manage SSL certificates for our applications.

## Parts

[Part 1. Setup MicroK8s With Ubuntu](/posts/setup-micro-k8s-with-ubuntu)

Part 2. Setup Nginx and cert-manager in MicroK8s (this post)

[Part 3. Deploy docker registry and postgres database in MicroK8s](/posts/deploy-docker-registry-and-postgres-database-in-micro-k8s)

[Part 4. Create and deploy .Net application in MicroK8s](/posts/create-and-deploy-dotnet-application-in-micro-k8s)

### Cert-Manager

### What is cert-manager?

cert-manager adds certificates and certificate issuers as resource types in Kubernetes clusters, and simplifies the process of obtaining, renewing and using those certificates.

It can issue certificates from a variety of supported sources, including Let's Encrypt, HashiCorp Vault, and Venafi as well as private PKI. It will ensure certificates are valid and up to date, and attempt to renew certificates at a configured time before expiry.

We are going to use Let's Encrypt for the ssl certificates.

### Enable cert-manger

cert-manager comes as an addon for the microk8s. Make sure the addon is enabled. To check if the addons is enabled. just check the status of the microk8s.

```bash
microk8s status
```

`cert-manager` addons should be inside the enabled section.

If it is not available in the enabled section. then, run the following command to enable it.

```bash
microk8s enable cert-manager
```

This will enable the cert-manager in microk8s.

### Add ClusterIssuer

The first thing you'll need to configure after you've enabled cert-manager is an Issuer or a ClusterIssuer. These are resources that represent certificate authorities (CAs) able to sign certificates in response to certificate signing requests.

### Production Issuer

lets create a production issuer which can be used to get the ssl certificate from lets encrypt.

```yaml
apiVersion: cert-manager.io/v1
kind: ClusterIssuer
metadata:
 name: lets-encrypt
spec:
 acme:
   email:  username@yourdomain.com # Change the email here
   server: https://acme-v02.api.letsencrypt.org/directory
   privateKeySecretRef:
     name: lets-encrypt-prod
   solvers:
   - http01:
       ingress:
         class: public
```

### Staging issuer

```yaml
apiVersion: cert-manager.io/v1
kind: ClusterIssuer
metadata:
 name: lets-encrypt-staging
spec:
 acme:
   server: https://acme-staging-v02.api.letsencrypt.org/directory
   email: username@yourdomain.com # Change the email here
   privateKeySecretRef:
     name: lets-encrypt-staging
   solvers:
   - http01:
       ingress:
         class:  public
```

## Setup nginx

### What is Ingress

Ingress exposes HTTP and HTTPS routes from outside the cluster to services within the cluster. Traffic routing is controlled by rules defined on the Ingress resource. An Ingress may be configured to give Services externally-reachable URLs, load balance traffic, terminate SSL / TLS, and offer name-based virtual hosting. An Ingress controller is responsible for fulfilling the Ingress, usually with a load balancer, though it may also configure your edge router or additional frontends to help handle the traffic.

We are going to use [NGINX Ingress Controller](https://kubernetes.github.io/ingress-nginx/) which comes as an addon for the microk8s.

### Enable Ingress

The first step is to make sure the addon is enabled. To verify the that just run the `status` command.

```bash
microk8s status
```

Make sure `ingress` is inside the enabled section.

If it is not available in the enabled section. then, run the following command to enable it.

```bash
microk8s enable ingress
```

This will enable the ingress in microk8s.

## Testing Ingress and cert-manager

Now, we have our `ingress` and `cert-manager` enabled. lets test these with deploying a simple `whoami` application.

```yaml
kind: Deployment
apiVersion: apps/v1
metadata:
  name: whoami
  labels:
    app: traefiklabs
    name: whoami

spec:
  replicas: 1
  selector:
    matchLabels:
      app: traefiklabs
      task: whoami
  template:
    metadata:
      labels:
        app: traefiklabs
        task: whoami
    spec:
      containers:
        - name: whoami
          image: traefik/whoami
          ports:
            - containerPort: 80
          resources:
            requests:
              memory: "100Mi"
              cpu: "250m"
            limits:
              memory: "200Mi"
              cpu: "500m"

---
apiVersion: v1
kind: Service
metadata:
  name: whoami-service
spec:
  ports:
    - name: http
      port: 80
  selector:
    app: traefiklabs
    task: whoami
---
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: http-ingress-whoami
  annotations:
    cert-manager.io/cluster-issuer: "lets-encrypt"
    kubernetes.io/ingress.class: "public"
spec:
  tls:
    - hosts:
      -  whoami.kdev.antosubash.com
      secretName: whoami-tls
  rules:
  - host: "whoami.kdev.antosubash.com"
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service: 
            name: whoami-service
            port: 
              number: 80
```

you can also find this file in the repo [here](https://github.com/antosubash/microk8s-hetzner-deployment/blob/main/whoami/whoami.yaml)

### Deploy

We will use the `kubectl` to deploy this application.

```bash
kubectl apply -f whoami.yaml
```

## Conclusion

In this post we enabled and configured two addons of microk8s. its cert-manager and ingress and to test these addons we also deployed a sample app. In the next post we will see how to deploy registry and postgres database.

[Part 3. Deploy docker registry and postgres database in MicroK8s](/posts/deploy-docker-registry-and-postgres-database-in-micro-k8s)
]]></content:encoded>
          </item><item>
          <title>Setup MicroK8s With Ubuntu</title>
          <link>https://blog.antosubash.com/posts/setup-micro-k8s-with-ubuntu</link>
          <guid>https://blog.antosubash.com/posts/setup-micro-k8s-with-ubuntu</guid>
          <pubDate>Wed, 14 Sep 2022 19:50:03 GMT</pubDate>
          <description>In this post we will see how to setup microk8s in ubuntu server.</description>
          <content:encoded><![CDATA[
## Table of contents

## Introduction

In this post we will see how to create a single node kubernetes cluster using microk8s. We will use hetzner cloud to create the server and install ubuntu server on it. We will then install microk8s and connect to the cluster using kubectl.

## Parts

Part 1. Setup MicroK8s With Ubuntu (this post)

[Part 2. Setup Nginx and cert-manager in MicroK8s](/posts/setup-nginx-and-cert-manager-in-micro-k8s)

[Part 3. Deploy docker registry and postgres database in MicroK8s](/posts/deploy-docker-registry-and-postgres-database-in-micro-k8s)

[Part 4. Create and deploy .Net application in MicroK8s](/posts/create-and-deploy-dotnet-application-in-micro-k8s)

## Creating the Ubuntu Server

### Prerequisites

- Hetzner Account

I'm going to use hetzner cloud to create this machine if you don't have one then you can use the referral link [https://hetzner.cloud/?ref=ENhA4rCZ5JUM](here) and get 20â‚¬ for free to try it out.

### Creating a project

Once you have the hetzner account. login and create a project.

![Create Project](/assets/posts/microk8s/microk8s1.gif)

### Setup SSH

The first step in the project is to SSH for the project.

![SSH key](/assets/posts/microk8s/microk8s2.gif)

### Setup Firewall

Now lets setup the firewall for our server.

![Firewall](/assets/posts/microk8s/microk8s3.gif)

### Create server with firewall and ssh key

![Create server](/assets/posts/microk8s/microk8s4.gif)

## Add DNS entry

Now you have to add a DNS entry for your newly created machine. you can fine the the IP address of the machine in the Hetzner server page.

We need to add `A` record and a `CNAME` record.

```bash
A XX.XX.XX.XX yourdomain.com
CNAME * yourdomain.com
```

For example this is how my sample entry looks like

Record      Host        Value
A           youtube1    95.217.191.119
CNAME       *           kdev1.antosubash.com

This might take some time to reflect so wait for a while to verify it.

## Verify DNS entry

To verify dns entry we will use a tool called dig.

you can find it here <https://toolbox.googleapps.com/apps/dig/#A/>

Make sure your domain is pointing to your ip and your subdomain is pointing to your domain

yourdomain.com -> XX.XX.XX.XX
subdomain.yourdomain.com -> XX.XX.XX.XX

So both your domain and subdomain should point to the same IP Which is the IP of the machine we just created.

## Update ssh config

ssh config file can be "~/.ssh/config"

In the config file add a entry for the newly created server.

```bash
Host kdev1.yourdomain.com
   IdentitiesOnly yes
   IdentityFile ~/.ssh/yournewlycreatedkey # Not the pub file
```

## Update the server

Run the following command to update the server

```bash
sudo apt update
sudo apt upgrade
```

## Install Snapd daemon

We will use the snap to microk8s. so we will install the snapd first.

```bash
sudo apt install snapd
```

once the it is installed verify it by checking the version

```bash
snap version
```

## Install MicroK8s

The current version of the kubernetes is 1.25 so we are using the following command. To verify the current version take a look at [https://microk8s.io/docs/getting-started](https://microk8s.io/docs/getting-started)

```bash
sudo snap install microk8s --classic --channel=1.25
```

### Join the group

```bash
sudo usermod -a -G microk8s $USER

sudo chown -f -R $USER ~/.kube

su - $USER
```

### Check the status

```bash
microk8s status --wait-ready
```

### Access Kubernetes

```bash
microk8s kubectl get nodes
```

### Create alias

```bash
alias kubectl='microk8s kubectl'
```

### View Cluster Info

```bash
kubectl cluster-info
```

### View Kube config

```bash
microk8s config
```

This config which is displayed here is the one we will use to connect to the cluster. copy it and configure your kubectl in your machine.

If you want to know how to install `kubectl` look here <https://kubernetes.io/docs/tasks/tools/>

## Enable addons

```bash
microk8s enable dns ingress prometheus cert-manager hostpath-storage
```

## Verify addons

```bash
microk8s kubectl get all --all-namespaces
```

## Create a setup script

you can create a setup script to automate the setup process. I have created a setup script which you can find below. this script will install the microk8s and enable the addons.

let's create a file called `setup.sh` and add the following content.

```bash
sudo nano setup.sh
```

lets set the permissions for the script

```bash
sudo chmod +x setup.sh
```

Now we have the file and the permissions. lets add the following content to the file.

```bash
#!/bin/bash
sudo apt update
sudo apt upgrade
sudo apt install snapd -y
snap version
sudo snap install microk8s --classic --channel=1.25
sudo usermod -a -G microk8s $USER
sudo chown -f -R $USER ~/.kube
su - $USER
microk8s status --wait-ready
alias kubectl='microk8s kubectl'
kubectl cluster-info
microk8s enable dns ingress prometheus cert-manager hostpath-storage
microk8s kubectl get all --all-namespaces
microk8s kubectl get nodes
```

## Run the setup script

```bash
sudo bash setup.sh
```

this will take some time to complete. once it is completed you can verify the status of the cluster by running the following command.

```bash
microk8s status
```

## Access the cluster

To access the cluster we will use the `kubectl` command. you can find the installation guide for kubectl [here](https://kubernetes.io/docs/tasks/tools/)

Once you have the kubectl installed you can run the following command to access the cluster.

```bash
microk8s config > ~/.kube/config
```

you can copy the content of the config file and paste it in your `~/.kube/config` file.

## Using Lens to access the cluster

Lens is a tool to access the kubernetes cluster. you can find the installation guide [here](https://k8slens.dev/). once you have installed the lens you can add the cluster by clicking the `+` button. and paste the config file in the `kubeconfig` field and click the `connect` button.

## Prepare the terminal with oh-my-zsh

I am using the oh-my-zsh to prepare my terminal. you can find the installation guide [here](https://ohmyz.sh/)

## Install oh-my-zsh

```bash
sudo apt install zsh
sh -c "$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)"
```

## Install autosuggestions and syntax highlighting

```bash
git clone https://github.com/zsh-users/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting
git clone https://github.com/zsh-users/zsh-autosuggestions ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-autosuggestions
```

## Update the .zshrc file

```bash
nano ~/.zshrc
```

add the following lines to the file

```bash
plugins=(git kubectl zsh-autosuggestions zsh-syntax-highlighting)
```

Also update the theme to `agnoster`

```bash
ZSH_THEME="agnoster"
```

add the kubectl alias to the file

```bash
alias kubectl='microk8s kubectl'
```

## Update the terminal

```bash
source ~/.zshrc
```

## Conclusion

This is it for this post. We have created a server and installed microk8s and enabled few addons. we have also configured the kubectl to access the cluster. Now we are ready for the next step. In the next step we will see how to setup nginx and cert manager. so that we can deploy our first app.

[Part 2. Setup Nginx and cert-manager in MicroK8s](/posts/setup-nginx-and-cert-manager-in-micro-k8s)
]]></content:encoded>
          </item><item>
          <title>NDepend - A tool you can depend on</title>
          <link>https://blog.antosubash.com/posts/ndepend</link>
          <guid>https://blog.antosubash.com/posts/ndepend</guid>
          <pubDate>Tue, 06 Sep 2022 00:00:00 GMT</pubDate>
          <description>In this post we will see how to use NDepend to improve your .net development.</description>
          <content:encoded><![CDATA[
## Table of contents

## Intro

In this post we will see how to use the NDepends to improve you .net development.

## What is NDepend?

NDepends is a static analyzer. It analyses your code and help you to improve code quality. It creates a dashboard to view the stats about your project and display most relevant info. It creates a in-depth reports that helps to maintain large complex project. It also helps to enforce coding standards.

you can find all the features available here : <https://www.ndepend.com/features/>

## Benefits of using NDepend

- Code maintainability
- Enforce code rules
- View the Impact of code change and trends
- Visualize code dependencies
- Explore the technical debt
- and many more

## Is it free?

No. It is a paid product. At the time of the this writing it cost â‚¬399 for dev machines. I have received the test license to play around.

## Sample Report

Orchard core sample report: <https://www.ndepend.com/Sample-Reports/OnOrchadCore/NDependReport.html#Main>

## Getting NDepend

you can do download it from here <https://www.ndepend.com/download>

Here is the install guide <https://www.ndepend.com/docs/getting-started-with-ndepend#Part1>

## Using NDepend

For this purpose I will use the Tasky Abp Microservice solution. It is a ABP Microservice application which I have created for a youtube series.

The first step is to add NDpend to your solution.

### Adding NDepend

![Adding NDepend](/assets/posts/ndepend/ndepend1.png)

As shown in the image adding `ndepend` to your solution is very easy. once added it will start the analysis of the solution and find all the projects and assemblies of your project. once it is done it will prompt with the list of found assemblies. you might want to ignore some assemblies like test and those can be managed in the next step.

### Start Analysis

![Start Analysis](/assets/posts/ndepend/ndepend2.png)

After the clicking the analysis `ndepend` will start the analysis of your code. it might take a min for it show the dashboard.

### Dashboard

![Dashboard](/assets/posts/ndepend/ndepend3.png)

Dashboard is where you will see most of the info about you solution. based on the status of you solution it will create a rating. In my case the rating was `B` for my tasky microservice solution. It also displays more basic metrics like "Types" and "Line of code". What I found most interesting is the "Quality Gates" and "Rules" section of the dashboard. It showed 2 problems I didn't see before in my code and gave me an explanation on why they are bad.

The problems were

- Avoid methods with too many parameters

It was a Identity server seed method which was very big and doing too many things.

- Avoid having different types with same name

This was a sample Dto class which I forgot to delete. So, the same type was available in multiple services.

This was really helpful. After seeing these problems I was more curious to find out what else was wrong in my solution and I had lots of minor issues. It was a great learning process.

### Info Window

![Info Window](/assets/posts/ndepend/ndepend4.png)

Info window explains your problem. It show what rules were broken and explain the rule clearly in a simple way. It also shows suggestion on how to fix the problem.

### Dependency graph

![Dependency graph](/assets/posts/ndepend/ndepend5.png)

This is one thing I wished that VS already had. When I saw the Dependency graph it was easy to understand the structure of the application. This will the first thing I do on any new solution to get the overall view of the solution. This helps to create a memory map of project.

### And many more

Once it is added the to the solution it starts to track the trend. the trend can be viewed in the graph. it will help us in improving the codebase. there are many more feature for this tool this is just an introduction of very few benefits.

## Final thoughts

If your are managing a large project then a tool like `ndepend` is very useful. It has good CI/CD integration so we can generate the nice report for every build and monitor the progress. The only problem I had is with the VS Code integration. There is a standalone instance which we can try with VS Code but there is no integration with VS Code. The rules helps you to write code with best practices and make you a better developer. It also helps with consistency in the codebase.

Next version of the `ndepend` will have more integration with Rider and VS Code to open source file declaration and diff source files. but not a full integration. Here is how it will look like.

![Dependency graph](/assets/posts/ndepend/ndepend6.png)

## Will I buy it?

For a personal project - No

For a Commercial project - Yes, for sure.

399 Euro is bit on the expensive side for me to buy it for using it on the hobby project. on the other hand I will buy it for me and my team at work. When you compare the cost and benefit it provides at work. it is worth every penny. hope this helps.
]]></content:encoded>
          </item><item>
          <title>Docker Deployment using docker swarm</title>
          <link>https://blog.antosubash.com/posts/docker-swarm-hetzner</link>
          <guid>https://blog.antosubash.com/posts/docker-swarm-hetzner</guid>
          <pubDate>Sun, 31 Jul 2022 00:00:00 GMT</pubDate>
          <description>In this post we will see how to setup docker swarm for your development environment.</description>
          <content:encoded><![CDATA[## Table of contents

## State is Docker swarm

The state of docker swarm is a big question for a while now. I have been a docker swarm user for a while and I really like the simplicity of it. But it seems like there is no major development taking place and the only alternative seems to be kubernetes which is quite complex compare to docker swarm. the main take away is that the future of docker swarm is uncertain.

## Why use docker swarm

Docker include swarm mode for natively managing a cluster of Docker Engines called a swarm. It is very simple to manage multiple docker nodes and create a cluster. It provides a basic cluster management, networking, service discovery and many more. you can find the full list of features [here](https://docs.docker.com/engine/swarm/#feature-highlights). For my personal use I don't want to use the complex kubernetes cluster. If you are looking for simple easy to use docker deployment then docker swarm is the best option I can find.

## How much does it cost?

Main goal of this series is to make sure the cost is low. So, the cost will be less than 15â‚¬ or 15$. I'm going to use hetzner cloud and you can use the referral link [here](https://hetzner.cloud/?ref=ENhA4rCZ5JUM) and get 20â‚¬ for free to try it out.

## What are the goals

The goals are as follows

- Secure the machine properly with proper firewall setup and ssh
- Reverse proxy to redirect traffic to containers (traefik)
- Deploy Redis, postgres, rabbitmq, registry
- Interface for container management (portainer)
- Deploy tasky microservice

## Parts

[Part 1. Setting up Ubuntu Server with docker in Hetzner](/posts/part-1-setup-docker-with-ubuntu-server-in-hetzner)

[Part 2. Setting up docker swarm with traefik and portainer](/posts/part-2-setup-docker-swarm-with-traefik-and-portainer)

[Part 3. Deploy redis, rabbitmq, seq, registry and postgres in docker swarm](/posts/part-3-deploy-registry-redis-rabitmq-postgresql-in-docker)

[Part 4. Deploy the microservice in docker swarm](/posts/part-4-prepare-and-deploy-microservice-in-docker)]]></content:encoded>
          </item><item>
          <title>Prepare and deploy the microservice</title>
          <link>https://blog.antosubash.com/posts/part-4-prepare-and-deploy-microservice-in-docker</link>
          <guid>https://blog.antosubash.com/posts/part-4-prepare-and-deploy-microservice-in-docker</guid>
          <pubDate>Sat, 30 Jul 2022 00:00:00 GMT</pubDate>
          <description>In this post we will see how to deploy the microservice solution to the our server.</description>
          <content:encoded><![CDATA[
## Posts in the Series

[Part 1. Setting up Ubuntu Server with docker in Hetzner](/posts/part-1-setup-docker-with-ubuntu-server-in-hetzner)

[Part 2. Setting up docker swarm with traefik and portainer](/posts/part-2-setup-docker-swarm-with-traefik-and-portainer)

[Part 3. Deploy redis, rabbitmq, seq, registry and postgres in docker swarm](/posts/part-3-deploy-registry-redis-rabitmq-postgresql-in-docker)

Part 4. Prepare and deploy the microservice for deployment (this post)

## Table of contents

## Intro

In this post we will prepare the microservice project for deployment and deploy it to the docker swarm. I'm going to use this [Sample microservice application](/posts/abp-microservice-series) you can find the repo [here](https://github.com/antosubash/Tasky)

## Update the github actions

```yml
name: Docker Image CI

on:
  push:
    branches: [ main ]

jobs:

  build:

    runs-on: ubuntu-latest

    steps:
    - name: Docker Login
      # You may pin to the exact commit or the version.
      # uses: docker/login-action@dd4fa0671be5250ee6f50aedf4cb05514abda2c7
      uses: docker/login-action@v1.14.1
      with:
        # Server address of Docker registry. If not set then will default to Docker Hub
        registry: registry.yourdomain.com
        # Username used to log against the Docker registry
        username: ${{ secrets.REGISTRY_USERNAME }}
        # Password or personal access token used to log against the Docker registry
        password: ${{ secrets.REGISTRY_PASSWORD }}
    - uses: actions/checkout@v2
    - name: Build the Gateway Docker image
      run: docker build . --file gateway/Tasky.Gateway/Dockerfile --tag gateway:dev
    - name: Docker tag images
      run: docker tag gateway:dev registry.yourdomain.com/gateway:dev
    - name: Push Gateway image
      run: docker push registry.yourdomain.com/gateway:dev
      
    - name: Build the IdentityServer Docker image
      run: docker build . --file apps/Tasky.IdentityServer/Dockerfile --tag identityserver:dev
    - name: Docker tag IdentityServer images
      run: docker tag identityserver:dev registry.yourdomain.com/identityserver:dev
    - name: Push IdentityServer image
      run: docker push registry.yourdomain.com/identityserver:dev
  
    - name: Build the Administration Docker image
      run: docker build . --file services/administration/host/Tasky.Administration.HttpApi.Host/Dockerfile --tag administration:dev
    - name: Docker tag Administration images
      run: docker tag administration:dev registry.yourdomain.com/administration:dev
    - name: Push Administration image
      run: docker push registry.yourdomain.com/administration:dev
      
    - name: Build the IdentityService Docker image
      run: docker build . --file services/identity/host/Tasky.IdentityService.HttpApi.Host/Dockerfile --tag identityservice:dev
    - name: Docker tag identityservice images
      run: docker tag identityservice:dev registry.yourdomain.com/identityservice:dev
    - name: Push IdentityService image
      run: docker push registry.yourdomain.com/identityservice:dev
    
    - name: Build the SaaS Docker image
      run: docker build . --file services/saas/host/Tasky.SaaS.HttpApi.Host/Dockerfile --tag saas:dev
    - name: Docker tag SaaS images
      run: docker tag saas:dev registry.yourdomain.com/saas:dev
    - name: Push SaaS image
      run: docker push registry.yourdomain.com/saas:dev

    - name: Build the DbMigrator Docker image
      run: docker build . --file shared/Tasky.DbMigrator/Dockerfile --tag migrator:dev
    - name: Docker tag DbMigrator images
      run: docker tag migrator:dev registry.yourdomain.com/migrator:dev
    - name: Push DbMigrator image
      run: docker push registry.yourdomain.com/migrator:dev
```

`secrets.REGISTRY_USERNAME` and `secrets.REGISTRY_PASSWORD` are coming from the repository secrets.

## Create docker compose

### Migrator

```yml
version: '3.4'

services:
  dbmigrator:
    image: registry.antosubash.com/migrator:dev
    environment:
      ConnectionStrings__SaaSService: "User ID=postgres;Password=my_postgres_password;Host=10.0.0.2;Port=5432;Database=TaskySaaSService;Pooling=false;"
      ConnectionStrings__IdentityService: "User ID=postgres;Password=my_postgres_password;Host=10.0.0.2;Port=5432;Database=TaskyIdentityService;Pooling=false;"
      ConnectionStrings__AdministrationService : "User ID=postgres;Password=my_postgres_password;Host=10.0.0.2;Port=5432;Database=TaskyAdministrationService;Pooling=false;"
      ConnectionStrings__ProjectService : "User ID=postgres;Password=my_postgres_password;Host=10.0.0.2;Port=5432;Database=TaskyProjectService;Pooling=false;"
```

### Tasky Services Compose

```yml
version: '3.4'

services:
  identityserver:
    image: registry.youtube.antosubash.com/identityserver:dev
    networks:
      - traefik-public
    environment:
      App__SelfUrl: "https://id.tasky.youtube.antosubash.com"
      App__ClientUrl: "https://app.tasky.youtube.antosubash.com,https://gw.tasky.youtube.antosubash.com"
      App__CorsOrigins: "https://app.tasky.youtube.antosubash.com,https://gw.tasky.youtube.antosubash.com"
      App__RedirectAllowedUrls: "https://app.tasky.youtube.antosubash.com,https://gw.tasky.youtube.antosubash.com"
      ConnectionStrings__SaaSService: "User ID=postgres;Password=my_postgres_password;Host=10.0.0.2;Port=5432;Database=TaskySaaSService;Pooling=false;"
      ConnectionStrings__IdentityService: "User ID=postgres;Password=my_postgres_password;Host=10.0.0.2;Port=5432;Database=TaskyIdentityService;Pooling=false;"
      ConnectionStrings__AdministrationService : "User ID=postgres;Password=my_postgres_password;Host=10.0.0.2;Port=5432;Database=TaskyAdministrationService;Pooling=false;"
      ConnectionStrings__ProjectService : "User ID=postgres;Password=my_postgres_password;Host=10.0.0.2;Port=5432;Database=TaskyProjectService;Pooling=false;"
      Redis__Configuration : "10.0.0.2:6379,password=my_master_password"
      RabbitMQ__Connections__Default__HostName : "10.0.0.2"
      RabbitMQ__Connections__EventBus__ClientName : "TaskyIdentityService"
      RabbitMQ__Connections__EventBus__ExchangeName : "Tasky"
      Serilog__WriteTo__[0]__Name : "Seq"
      Serilog__WriteTo__[0]__Args__serverUrl : "https://seq.youtube.antosubash.com"
    deploy:
      labels:
        - "traefik.enable=true"
        - "traefik.http.routers.identityserver.rule=Host(`id.tasky.youtube.antosubash.com`)"
        - "traefik.http.services.identityserver.loadbalancer.server.port=80"
        - "traefik.http.routers.identityserver.entrypoints=websecure"
        - "traefik.http.routers.identityserver.tls=true"
        - "traefik.http.routers.identityserver.tls.certresolver=leresolver"

  gateway:
    image: registry.youtube.antosubash.com/gateway:dev
    networks:
      - traefik-public
    environment:
      ReverseProxy__Clusters__main__Destinations__main__Address : "http://10.0.0.2:7001"
      ReverseProxy__Clusters__identity__Destinations__identity__Address : "http://10.0.0.2:7002"
      ReverseProxy__Clusters__account__Destinations__account__Address : "http://10.0.0.2:7002"
      ReverseProxy__Clusters__saas__Destinations__saas__Address : "http://10.0.0.2:7003"
      ReverseProxy__Clusters__project__Destinations__project__Address : "http://10.0.0.2:7004"
      Serilog__WriteTo__[0]__Name : "Seq"
      Serilog__WriteTo__[0]__Args__serverUrl : "https://seq.youtube.antosubash.com"
    deploy:
      labels:
        - "traefik.enable=true"
        - "traefik.http.routers.gateway.rule=Host(`gw.tasky.youtube.antosubash.com`)"
        - "traefik.http.services.gateway.loadbalancer.server.port=80"
        - "traefik.http.routers.gateway.entrypoints=websecure"
        - "traefik.http.routers.gateway.tls=true"
        - "traefik.http.routers.gateway.tls.certresolver=leresolver"

  administrationservice:
    image: registry.youtube.antosubash.com/administration:dev
    ports:
      - target: 80
        published: 7001
        protocol: tcp
        mode: host
    environment:
      App__CorsOrigins: http://10.0.0.2:7000
      ConnectionStrings__SaaSService: "User ID=postgres;Password=my_postgres_password;Host=10.0.0.2;Port=5432;Database=TaskySaaSService;Pooling=false;"
      ConnectionStrings__IdentityService: "User ID=postgres;Password=my_postgres_password;Host=10.0.0.2;Port=5432;Database=TaskyIdentityService;Pooling=false;"
      ConnectionStrings__AdministrationService : "User ID=postgres;Password=my_postgres_password;Host=10.0.0.2;Port=5432;Database=TaskyAdministrationService;Pooling=false;"
      ConnectionStrings__ProjectService : "User ID=postgres;Password=my_postgres_password;Host=10.0.0.2;Port=5432;Database=TaskyProjectService;Pooling=false;"
      Redis__Configuration : "10.0.0.2:6379,password=my_master_password"
      AuthServer__Authority : "https://id.tasky.youtube.antosubash.com"
      AuthServer__RequireHttpsMetadata : "false"
      AuthServer__SwaggerClientId : "AdministrationService_Swagger"
      AuthServer__SwaggerClientSecret : "1q2w3e*"
      RabbitMQ__Connections__Default__HostName : "10.0.0.2"
      RabbitMQ__Connections__EventBus__ClientName : "TaskyAdministrationService"
      RabbitMQ__Connections__EventBus__ExchangeName : "Tasky"
      Serilog__WriteTo__[0]__Name : "Seq"
      Serilog__WriteTo__[0]__Args__serverUrl : "https://seq.youtube.antosubash.com"

  identityservice:
    image: registry.youtube.antosubash.com/identityservice:dev
    ports:
      - target: 80
        published: 7002
        protocol: tcp
        mode: host
    environment:
      App__CorsOrigins: http://10.0.0.2:7000
      ConnectionStrings__SaaSService: "User ID=postgres;Password=my_postgres_password;Host=10.0.0.2;Port=5432;Database=TaskySaaSService;Pooling=false;"
      ConnectionStrings__IdentityService: "User ID=postgres;Password=my_postgres_password;Host=10.0.0.2;Port=5432;Database=TaskyIdentityService;Pooling=false;"
      ConnectionStrings__AdministrationService : "User ID=postgres;Password=my_postgres_password;Host=10.0.0.2;Port=5432;Database=TaskyAdministrationService;Pooling=false;"
      ConnectionStrings__ProjectService : "User ID=postgres;Password=my_postgres_password;Host=10.0.0.2;Port=5432;Database=TaskyProjectService;Pooling=false;"
      Redis__Configuration : "10.0.0.2:6379,password=my_master_password"
      AuthServer__Authority : "https://id.tasky.youtube.antosubash.com"
      AuthServer__RequireHttpsMetadata : "false"
      AuthServer__SwaggerClientId : "IdentityService_Swagger"
      AuthServer__SwaggerClientSecret : "1q2w3e*"
      RabbitMQ__Connections__Default__HostName : "10.0.0.2"
      RabbitMQ__Connections__EventBus__ClientName : "TaskyIdentityService"
      RabbitMQ__Connections__EventBus__ExchangeName : "Tasky"
      Serilog__WriteTo__[0]__Name : "Seq"
      Serilog__WriteTo__[0]__Args__serverUrl : "https://seq.youtube.antosubash.com"

  saasservice:
    image: registry.youtube.antosubash.com/saas:dev
    ports:
      - target: 80
        published: 7003
        protocol: tcp
        mode: host
    environment:
      App__CorsOrigins: http://10.0.0.2:7000
      ConnectionStrings__SaaSService: "User ID=postgres;Password=my_postgres_password;Host=10.0.0.2;Port=5432;Database=TaskySaaSService;Pooling=false;"
      ConnectionStrings__IdentityService: "User ID=postgres;Password=my_postgres_password;Host=10.0.0.2;Port=5432;Database=TaskyIdentityService;Pooling=false;"
      ConnectionStrings__AdministrationService : "User ID=postgres;Password=my_postgres_password;Host=10.0.0.2;Port=5432;Database=TaskyAdministrationService;Pooling=false;"
      ConnectionStrings__ProjectService : "User ID=postgres;Password=my_postgres_password;Host=10.0.0.2;Port=5432;Database=TaskyProjectService;Pooling=false;"
      Redis__Configuration : "10.0.0.2:6379,password=my_master_password"
      AuthServer__Authority : "https://id.tasky.youtube.antosubash.com"
      AuthServer__RequireHttpsMetadata : "false"
      AuthServer__SwaggerClientId : "IdentityService_Swagger"
      AuthServer__SwaggerClientSecret : "1q2w3e*"
      RabbitMQ__Connections__Default__HostName : "10.0.0.2"
      RabbitMQ__Connections__EventBus__ClientName : "TaskyIdentityService"
      RabbitMQ__Connections__EventBus__ExchangeName : "Tasky"
      Serilog__WriteTo__[0]__Name : "Seq"
      Serilog__WriteTo__[0]__Args__serverUrl : "https://seq.youtube.antosubash.com"

  projectservice:
    image: registry.youtube.antosubash.com/project:dev
    ports:
      - target: 80
        published: 7004
        protocol: tcp
        mode: host
    environment:
      App__CorsOrigins: http://10.0.0.2:7000
      ConnectionStrings__SaaSService: "User ID=postgres;Password=my_postgres_password;Host=10.0.0.2;Port=5432;Database=TaskySaaSService;Pooling=false;"
      ConnectionStrings__IdentityService: "User ID=postgres;Password=my_postgres_password;Host=10.0.0.2;Port=5432;Database=TaskyIdentityService;Pooling=false;"
      ConnectionStrings__AdministrationService : "User ID=postgres;Password=my_postgres_password;Host=10.0.0.2;Port=5432;Database=TaskyAdministrationService;Pooling=false;"
      ConnectionStrings__ProjectService : "User ID=postgres;Password=my_postgres_password;Host=10.0.0.2;Port=5432;Database=TaskyProjectService;Pooling=false;"
      Redis__Configuration : "10.0.0.2:6379,password=my_master_password"
      AuthServer__Authority : "https://id.tasky.youtube.antosubash.com"
      AuthServer__RequireHttpsMetadata : "false"
      AuthServer__SwaggerClientId : "IdentityService_Swagger"
      AuthServer__SwaggerClientSecret : "1q2w3e*"
      RabbitMQ__Connections__Default__HostName : "10.0.0.2"
      RabbitMQ__Connections__EventBus__ClientName : "TaskyIdentityService"
      RabbitMQ__Connections__EventBus__ExchangeName : "Tasky"
      Serilog__WriteTo__[0]__Name : "Seq"
      Serilog__WriteTo__[0]__Args__serverUrl : "https://seq.youtube.antosubash.com"

networks:
  traefik-public:
    external: true
```


]]></content:encoded>
          </item><item>
          <title>Deploy redis, rabbitmq, seq, registry and postgres in docker swarm</title>
          <link>https://blog.antosubash.com/posts/part-3-deploy-registry-redis-rabitmq-postgresql-in-docker</link>
          <guid>https://blog.antosubash.com/posts/part-3-deploy-registry-redis-rabitmq-postgresql-in-docker</guid>
          <pubDate>Tue, 21 Jun 2022 00:00:00 GMT</pubDate>
          <description>In this post we will see how to deploy redis, rabbitmq, postgres and registry.</description>
          <content:encoded><![CDATA[
## Posts in the Series

[Part 1. Setting up Ubuntu Server with docker in Hetzner](/posts/part-1-setup-docker-with-ubuntu-server-in-hetzner)

[Part 2. Setting up docker swarm with traefik and portainer](/posts/part-2-setup-docker-swarm-with-traefik-and-portainer)

Part 3. Deploy redis, rabbitmq, seq, registry and postgres in docker swarm (this post)

[Part 4. Deploy the microservice in docker swarm](/posts/part-4-prepare-and-deploy-microservice-in-docker)

## Table of contents

## Intro

In this post we will see how to deploy redis, rabbitmq, postgres and registry.

## Deploy docker registry

We will deploy a docker registry

### Create folder for registry deployment

```bash
mkdir /mnt/auth
mkdir /mnt/registry
```

Auth folder is for storing the password and registry folder is for storing the images.

### Create password for registry

```bash
docker run --entrypoint htpasswd httpd:2 -Bbn testuser testpassword
```

Copy the output to `/mnt/auth/registry.password`

### Registry docker compose

```yml
version: '3'

services:
  registry:
    image: registry:2
    networks:
      - traefik-public
    environment:
      VIRTUAL_HOST: registry.yourdomain.com
      REGISTRY_AUTH: htpasswd
      REGISTRY_AUTH_HTPASSWD_REALM: Registry Realm
      REGISTRY_AUTH_HTPASSWD_PATH: /auth/registry.password
    volumes:
      - /mnt/auth:/auth
      - /mnt/registry:/var/lib/registry
    deploy:
      labels:
        - "traefik.enable=true"
        - "traefik.http.routers.registry.rule=Host(`registry.yourdomain.com`)"
        - "traefik.http.services.registry.loadbalancer.server.port=5000"
        - "traefik.http.routers.registry.entrypoints=websecure"
        - "traefik.http.routers.registry.tls=true"
        - "traefik.http.routers.registry.tls.certresolver=leresolver"
        
networks:
  traefik-public:
    external: true
```

## Deploy redis

Redis is an in-memory data structure store, used as a distributed, in-memory keyâ€“value database, cache and message broker, with optional durability. Redis supports different kinds of abstract data structures, such as strings, lists, maps, sets, sorted sets, HyperLogLogs, bitmaps, streams, and spatial indices.

### Create folder for redis deployment

```bash
mkdir /mnt/redis
```

### Redis docker compose

```yml
version: "3"
  
services:
  redis-master:
    image: "bitnami/redis:latest"
    ports:
      - "6379:6379"
    environment:
      - REDIS_REPLICATION_MODE=master
      - REDIS_PASSWORD=my_master_password
    volumes:
      - '/mnt/redis:/bitnami'
```

## Deploy postgres

PostgreSQL, also known as Postgres, is a free and open-source relational database management system emphasizing extensibility and SQL compliance.

### Create folder for postgres deployment

```bash
mkdir /mnt/postgres
```

### Postgres docker compose

```yml
version: "3.2"

services:
  postgres:
    image: kartoza/postgis:12.0
    ports:
      - 5432:5432
    volumes:
      - /mnt/postgres:/var/lib/postgresql
    environment:
      POSTGRES_DB: test
      POSTGRES_USER: postgres
      POSTGRES_PASS: my_postgres_password
      --auth: "md5"
      POSTGRES_MULTIPLE_EXTENSIONS: postgis,hstore,postgis_topology
```

## Deploy rabbitmq

RabbitMQ is an open-source message-broker Software that originally implemented the Advanced Message Queuing Protocol and has since been extended with a plug-in architecture to support Streaming Text Oriented Messaging Protocol, MQ Telemetry Transport, and other protocols.

### rabbitmq docker compose

```yml
version: '3.7'

services:
  rabbitmq:
    container_name: rabbitmq
    image: rabbitmq:management-alpine
    ports:
      - "15672:15672"
      - "5672:5672"
```

## Deploy seq

Seq is the intelligent search, Analysis, and alerting server built specifically for modern structured log data.

### Create folder for seq deployment

```bash
mkdir /mnt/seq
```

### seq docker compose

```yml
version: '3'

services:
  seq:
    image: datalust/seq
    networks:
      - traefik-public
    environment:
      ACCEPT_EULA: "Y"
    volumes:
      - /mnt/seq:/data
    deploy:
      labels:
        - "traefik.enable=true"
        - "traefik.http.routers.seq.rule=Host(`seq.yourdomain.com`)"
        - "traefik.http.services.seq.loadbalancer.server.port=80"
        - "traefik.http.routers.seq.entrypoints=websecure"
        - "traefik.http.routers.seq.tls=true"
        - "traefik.http.routers.seq.tls.certresolver=leresolver"
        
networks:
  traefik-public:
    external: true
```
]]></content:encoded>
          </item><item>
          <title>Setting up docker swarm with traefik and portainer</title>
          <link>https://blog.antosubash.com/posts/part-2-setup-docker-swarm-with-traefik-and-portainer</link>
          <guid>https://blog.antosubash.com/posts/part-2-setup-docker-swarm-with-traefik-and-portainer</guid>
          <pubDate>Mon, 20 Jun 2022 00:00:00 GMT</pubDate>
          <description>In this post we will see how to create a docker swarm and deploy traefik and portainer in our ubuntu server.</description>
          <content:encoded><![CDATA[
## Posts in the Series

[Part 1. Setting up Ubuntu Server with docker in Hetzner](/posts/part-1-setup-docker-with-ubuntu-server-in-hetzner)

Part 2. Setting up docker swarm with traefik and portainer (this post)

[Part 3. Deploy redis, rabbitmq, seq, registry and postgres in docker swarm](/posts/part-3-deploy-registry-redis-rabitmq-postgresql-in-docker)

[Part 4. Deploy the microservice in docker swarm](/posts/part-4-prepare-and-deploy-microservice-in-docker)

## Table of contents

## Intro

In this post we will see how to create a docker swarm and deploy traefik and portainer in our ubuntu server.

## What is traefik?

Traefik is a leading modern reverse proxy and load balancer that makes deploying microservices easy. Traefik integrates with your existing infrastructure components and configures itself automatically and dynamically.

For more info visit : <https://traefik.io/traefik/>

## What is portainer?

Portainer is the definitive container management tool for Docker, Docker Swarm with it's highly intuitive GUI and API. Portainer is a fully featured management tool for Docker. It runs locally, giving developers a rich UI to build and publish container images, deploy and manage applications and leverage data persistence and horizontal scaling for their applications. And, once an application is deployed into a container, Portainer makes it easy for users to secure, monitor and measure the performance of the platform. The tool negates the need for developers to learn Infrastructure as Code and makes it easy for them to maximize their efficiency which means both users and organizations love it.

For more info visit: <https://www.portainer.io/>

## What is Docker Swarm?

Docker swarm is a container orchestration tool, meaning that it allows the user to manage multiple containers deployed across multiple host machines. One of the key benefits associated with the operation of a docker swarm is the high level of availability offered for applications.

For more info: <https://docs.docker.com/engine/swarm/>

## Init Docker Swarm

```bash
docker swarm init --advertise-addr 10.0.0.3 # change the ip here with your machine ip
```

This will initialize docker in swarm mode and also display a join token for the other machines to join the cluster.

## Create a traefik network

```bash
docker network create --driver overlay traefik-public 
```

This is our primary network for the traefik.

## Create a htpasswd password

```bash
docker run --rm httpd:2.4-alpine htpasswd -nbB admin <password> | cut -d ":" -f 2
```

Escape the $ sign in the password by adding one more $ to the generated password. We need this password to protect our end point in the traefik proxy.

## Create folders

### for Traefik

create a folder and set 600 as permission.

```bash
mkdir /mnt/data
mkdir /mnt/data/traefik
touch /mnt/data/traefik/acme.json
chmod 600 /mnt/data/traefik/acme.json
```

### for Portainer

```bash
mkdir /mnt/data/portainer
```

## Traefik docker compose

Traefik is our main reverse proxy and it will sit in front of all out application. we will control all the routes to our containers using traefik.

```yml
version: "3.3"

services:
  traefik:
    image: "traefik:v2.1.4"
    command:
      - --log.level=INFO
      - --entrypoints.web.address=:80
      - --entrypoints.websecure.address=:443
      - --providers.docker
      - --providers.docker.exposedbydefault=false
      - --providers.docker.swarmmode=true
      - --providers.docker.network=traefik-public
      - --api
      - --api.dashboard=true
      - --certificatesresolvers.leresolver.acme.caserver=https://acme-v02.api.letsencrypt.org/directory
      # update your email here
      - --certificatesresolvers.leresolver.acme.email=youremail@test.com
      # Make sure the this file is available and permission is set correctly
      - --certificatesresolvers.leresolver.acme.storage=/le/acme.json
      - --certificatesresolvers.leresolver.acme.tlschallenge=true
    ports:
      - "80:80"
      - "443:443"
    networks:
      - traefik-public
    volumes:
      - "/var/run/docker.sock:/var/run/docker.sock:ro"
      # Make sure the volume folder is created
      - "/mnt/data/traefik/acme.json:/le/acme.json"
    deploy:
      labels:
        # Dashboard
        - "traefik.enable=true"
        # Change the host url here
        - "traefik.http.routers.traefik.rule=Host(`traefik.example.com`)"
        - "traefik.http.routers.traefik.service=api@internal"
        - "traefik.http.services.traefik.loadbalancer.server.port=8080"
        - "traefik.http.routers.traefik.tls.certresolver=leresolver"
        - "traefik.http.routers.traefik.entrypoints=websecure"
        - "traefik.http.routers.traefik.middlewares=authtraefik"
        # Change the auth password here
        - "traefik.http.middlewares.authtraefik.basicauth.users=admin:yournewpassword" # user/password

        # global redirect to https
        - "traefik.http.routers.http-catchall.rule=hostregexp(`{host:.+}`)"
        - "traefik.http.routers.http-catchall.entrypoints=web"
        - "traefik.http.routers.http-catchall.middlewares=redirect-to-https"

        # middleware redirect
        - "traefik.http.middlewares.redirect-to-https.redirectscheme.scheme=https"

  my-app:
    image: containous/whoami:v1.3.0
    networks:
      - traefik-public
    command:
      - --port=8082 # Our service listens on 8082
    deploy:
      labels:
        - "traefik.enable=true"
        # Change the host url here
        - "traefik.http.routers.my-app.rule=Host(`whoami.example.com`)"
        - "traefik.http.services.my-app.loadbalancer.server.port=8082"
        - "traefik.http.routers.my-app.middlewares=auth"
        - "traefik.http.routers.my-app.entrypoints=websecure"
        - "traefik.http.routers.my-app.tls=true"
        - "traefik.http.routers.my-app.tls.certresolver=leresolver"
        # Change the password here
        - "traefik.http.middlewares.auth.basicauth.users=admin:changeme" # user/password

networks:
  traefik-public:
    external: true
```

## Portainer

Portainer is our container management software. We will use to deploy our docker containers.

```yml
version: "3.2"

services:
  agent:
    image: portainer/agent
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock
      - /var/lib/docker/volumes:/var/lib/docker/volumes
    networks:
      - traefik-public
    deploy:
      mode: global
      placement:
        constraints: [node.platform.os == linux]

  portainer:
    image: portainer/portainer
    command: -H tcp://tasks.agent:9001 --tlsskipverify
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock
      # make sure the folder is available
      - /mnt/volume2/portainer:/data
    networks:
      - traefik-public
    deploy:
      labels:
        - "traefik.enable=true"
        # change the host here
        - "traefik.http.routers.portainer.rule=Host(`admin.example.com`)"
        - "traefik.http.services.portainer.loadbalancer.server.port=9000"
        - "traefik.http.routers.portainer.entrypoints=websecure"
        - "traefik.http.routers.portainer.tls=true"
        - "traefik.http.routers.portainer.tls.certresolver=leresolver"
      mode: replicated
      placement:
        constraints: [node.role == manager]

networks:
  traefik-public:
    external: true
```

]]></content:encoded>
          </item><item>
          <title>Setting up Ubuntu Server with docker in Hetzner</title>
          <link>https://blog.antosubash.com/posts/part-1-setup-docker-with-ubuntu-server-in-hetzner</link>
          <guid>https://blog.antosubash.com/posts/part-1-setup-docker-with-ubuntu-server-in-hetzner</guid>
          <pubDate>Sun, 19 Jun 2022 00:00:00 GMT</pubDate>
          <description>In this post we will see how to create a ubuntu server for docker deployment.</description>
          <content:encoded><![CDATA[
## Posts in the Series

Part 1. Setting up Ubuntu Server with docker in Hetzner (this post)

[Part 2. Setting up docker swarm with traefik and portainer](/posts/part-2-setup-docker-swarm-with-traefik-and-portainer)

[Part 3. Deploy redis, rabbitmq, seq, registry and postgres in docker swarm](/posts/part-3-deploy-registry-redis-rabitmq-postgresql-in-docker)

[Part 4. Deploy the microservice in docker swarm](/posts/part-4-prepare-and-deploy-microservice-in-docker)

## Table of contents

## Intro

In this post we will see how to setup a ubuntu server for our docker deployment.

## Prerequisites

- Hetzner cloud account

you can use the referral link here and get 20 Euro to play around. <https://hetzner.cloud/?ref=ENhA4rCZ5JUM>

## Creating ssh key

we will use ssh key to login to the server. so lets first create a ssh key.

```bash
ssh-keygen -t ed25519 -C "demo@antosubash.com"
```

this command will create a ssh key.

## Create ubuntu machine with docker

For this we will the hetzner apps. Hetzner provides machine with docker CE. this will save us some time.

### Add ssh key to hetzner project

![Add ssh to your hetzner project](/assets/posts/docker-deployment/hetzner1.png)

![Add ssh to your hetzner project](/assets/posts/docker-deployment/hetzner2.png)

![Add ssh to your hetzner project](/assets/posts/docker-deployment/hetzner3.png)

### Create server

![Create Server](/assets/posts/docker-deployment/hetzner4.png)

![Create Server](/assets/posts/docker-deployment/hetzner5.png)

![Create Server](/assets/posts/docker-deployment/hetzner6.png)

![Create Server](/assets/posts/docker-deployment/hetzner7.png)

![Create Server](/assets/posts/docker-deployment/hetzner8.png)

![Create Server](/assets/posts/docker-deployment/hetzner9.png)

![Create Server](/assets/posts/docker-deployment/hetzner10.png)

![Create Server](/assets/posts/docker-deployment/hetzner11.png)

### Create the firewall for the server

![Create firewall](/assets/posts/docker-deployment/hetzner12.png)

![Create firewall](/assets/posts/docker-deployment/hetzner13.png)

![Create firewall](/assets/posts/docker-deployment/hetzner14.png)

![Create firewall](/assets/posts/docker-deployment/hetzner15.png)

![Create firewall](/assets/posts/docker-deployment/hetzner16.png)

### IP address of our machine

![IP address](/assets/posts/docker-deployment/hetzner17.png)

## Add DNS entry

Now you have to add a DNS entry for your newly created machine. you can fine the the IP address of the machine in the Hetzner server page.

We need to add `A` record and a `CNAME` record.

```bash
A XX.XX.XX.XX yourdomain.com
CNAME * yourdomain.com
```

For example this is how my sample entry looks like

Record      Host        Value
A           youtube1    95.217.191.119
CNAME       *           youtube1.antosubash.com

This might take some time to reflect so wait for a while to verify it.

## Verify DNS entry

To verify dns entry we will use a tool called dig.

you can find it here <https://toolbox.googleapps.com/apps/dig/#A/>

Make sure your domain is pointing to your ip and your subdomain is pointing to your domain

yourdomain.com -> XX.XX.XX.XX
subdomain.yourdomain.com -> XX.XX.XX.XX

So both your domain and subdomain should point to the same IP Which is the IP of the machine we just created.

## Update ssh config

ssh config file can be "~/.ssh/config"

In the config file add a entry for the newly created server.

```bash
Host youtube1.yourdomain.com
   IdentitiesOnly yes
   IdentityFile ~/.ssh/yournewlycreatedkey # Not the pub file
```
]]></content:encoded>
          </item><item>
          <title>Blazor state management with Fluxor</title>
          <link>https://blog.antosubash.com/posts/state-management-blazor-fluxor</link>
          <guid>https://blog.antosubash.com/posts/state-management-blazor-fluxor</guid>
          <pubDate>Wed, 01 Jun 2022 00:00:00 GMT</pubDate>
          <description>In this post we will see how to setup fluxor in Blazor Wasm App</description>
          <content:encoded><![CDATA[## Table of contents

## What is Fluxor

Fluxor is a zero boilerplate Flux/Redux library for .Net. The aim of Fluxor is to create a multi-UI, single-state store approach to front-end development without the headaches typically associated with other implementations, such as the overwhelming amount of boiler-plate code required just to add a very basic feature.
Repo: <https://github.com/mrpmorris/Fluxor>
Docs: <https://github.com/mrpmorris/Fluxor/blob/master/Docs/README.md>

## When to use Fluxor

Fluxor uses Flux/Redux approach. It helps you to manage your appâ€™s state in a single place and keep changes in your app more predictable and traceable. It makes it easier to manage the state. But all of these benefits come with tradeoffs and constraints. One might feel it adds up boilerplate code, making simple things a little overwhelming; but that depends upon the architecture decisions. If you are wondering if you need state management or not then you don't need it. When your app grows to the scale where managing app state becomes a hassle; and you start looking out for making it easy and simple. That is where you will find Fluxor helpful.

## Creating Blazor Wasm project

```bash
dotnet new blazorwasm -n FluxorWithBlazor
```

This will create a blazor wasm app.

## Install Fluxor Packages

Install Nuget packages

```xml
<PackageReference Include="Fluxor" Version="5.4.0" />
<PackageReference Include="Fluxor.Blazor.Web" Version="5.4.0" />
<PackageReference Include="Fluxor.Blazor.Web.ReduxDevTools" Version="5.4.0" />
```

Update the `Program.cs`

```cs
using Fluxor;

builder.Services.AddFluxor(o =>
{
    o.ScanAssemblies(typeof(Program).Assembly);
    o.UseReduxDevTools(rdt =>
      {
          rdt.Name = "My application";
      });
});
```

Update the `App.razor`

```xml
<Fluxor.Blazor.Web.StoreInitializer />
```

Now we are ready to create state in our Blazor application.

## Fluxor Rules

- State should always be read-only.
- To alter state our app should dispatch an action.
- Every reducer that processes the dispatched action type will create new state to reflect the old state combined with the changes expected for the action.
- The UI then uses the new state to render its display.

## Core Concepts (State, Actions, and Reducers)

### State

Imagine your appâ€™s state is described as a plain object. For example, the state of a counter app might look like this:

```cs
[FeatureState]
public class CounterState
{
  public int ClickCount { get; }

  public CounterState(int clickCount)
  {
    ClickCount = clickCount;
  }
}
```

This object is like a â€œmodelâ€ except that there are no setters. This is so that different parts of the code canâ€™t change the state arbitrarily, causing hard-to-reproduce bugs. To change something in the state, you need to dispatch an action.

### Action

An action is a plain c# object (notice how we donâ€™t introduce any magic?) that describes what happened. Here are a few example actions:

```cs
public class IncrementCounterAction
{
}
```

Enforcing that every change is described as an action lets us have a clear understanding of whatâ€™s going on in the app. If something changed, we know why it changed. Actions are like breadcrumbs of what has happened. 

### Reducers

Finally, to tie state and actions together, we write a function called a reducer. Again, nothing magical about itâ€”itâ€™s just a function that takes state and action as arguments, and returns the next state of the app. It would be hard to write such a function for a big app, so we write smaller functions managing parts of the state:

```cs
public static class Reducers
{
    [ReducerMethod]
    public static CounterState ReduceIncrementCounterAction(CounterState state, IncrementCounterAction action) =>
        new(clickCount: state.ClickCount + 1);
}
```

## Using the State

To use the state management we will update the `counter` page which comes with the default app.

```html
@page "/counter"
@using FluxorWithBlazor.State.Counter
@inject IDispatcher dispatcher
@inject IState<CounterState> counterState
<PageTitle>Counter</PageTitle>

<h1>Counter</h1>

<p role="status">Current count: @counterState.Value.ClickCount</p>

<button class="btn btn-primary" @onclick="IncrementCount">Click me</button>

@code {
    private void IncrementCount()
    {
        dispatcher.Dispatch(new IncrementCounterAction());
    }
}
```

In the `IncrementCount` method we are dispatching an action and the current count is displayed buy injecting the state.

## Effects

Flux state is supposed to be immutable, and that state replaced only by pure functions, which should only take input from their parameters. With this in mind, we need something that will enable us to access other sources of data such as web services, and then reduce the results into our state. That is where the effects comes in. Effect handlers cannot (and should not) affect state directly. They are triggered when the action they are interested in is dispatched through the store, and as a response they can dispatch new actions.

## Fetch data with effects

We will update the fetch data sample provided in the default blazor application with Effects.

### Fetch data action

Lets create a action which will initiate the action. this will the be a empty action which will be used to trigger the effect.

```cs
public class FetchDataAction
{
}
```

### Fetch data result action

Once the data is received from the server we need a action to update the state. we will use the Â´FetchDataResultActionÂ´ for that. It will have a the list of Weather forecast available.

```cs
public class FetchDataResultAction
{
    public IEnumerable<WeatherForecast> Forecasts { get; }

    public FetchDataResultAction(IEnumerable<WeatherForecast> forecasts)
    {
        Forecasts = forecasts;
    }
}
```

## Weather state

Weather state will the two property Â´ForecastsÂ´ and Â´IsLoadingÂ´.

```cs
[FeatureState]
public class WeatherState
{
  public bool IsLoading { get; }
  public IEnumerable<WeatherForecast> Forecasts { get; }

  private WeatherState() { }
  public WeatherState(bool isLoading, IEnumerable<WeatherForecast> forecasts)
  {
    IsLoading = isLoading;
    Forecasts = forecasts ?? Array.Empty<WeatherForecast>();
  }
}
```

## Weather Reducers

In the reducer we need to manage 2 action which are created by us. One is to trigger the data fetch and the next one is to handle the data result.

```cs
public static class Reducers
{
  [ReducerMethod]
  public static WeatherState ReduceFetchDataAction(WeatherState state, FetchDataAction action) =>
    new(isLoading: true, forecasts: null);

  [ReducerMethod]
  public static WeatherState ReduceFetchDataResultAction(WeatherState state, FetchDataResultAction action) =>
    new(isLoading: false, forecasts: action.Forecasts);
}
```

## Weather effects

Effects is where we will make our Â´httpÂ´ call. We will inject the Â´HttpClientÂ´ and use that in the effect method. once the call is successful we will dispatch an action with the data result.

```cs
public class Effects
{
    private readonly HttpClient Http;

    public Effects(HttpClient http)
    {
        Http = http;
    }

    [EffectMethod]
    public async Task HandleFetchDataAction(FetchDataAction action, IDispatcher dispatcher)
    {
        var forecasts = await Http.GetFromJsonAsync<WeatherForecast[]>("sample-data/weather.json");
        if(forecasts is not null)
        {
            dispatcher.Dispatch(new FetchDataResultAction(forecasts: forecasts!));
        }
    }
}
```

### Update the fetch data page

We need to update the fetch data page to use the weather state.

```html
@page "/fetchdata"
@inject IDispatcher dispatcher
@inject IState<WeatherState> weather
@inherits Fluxor.Blazor.Web.Components.FluxorComponent
<PageTitle>Weather forecast</PageTitle>

<h1>Weather forecast</h1>

<p>This component demonstrates fetching data from the server.</p>

@if (weather.Value.IsLoading)
{
	<p><em>Loading...</em></p>
}
else
{
	<table class="table">
		<thead>
			<tr>
				<th>Date</th>
				<th>Temp. (C)</th>
				<th>Temp. (F)</th>
				<th>Summary</th>
			</tr>
		</thead>
		<tbody>
			@foreach (var forecast in weather.Value.Forecasts)
			{
			<tr>
				<td>@forecast.Date.ToShortDateString()</td>
				<td>@forecast.TemperatureC</td>
				<td>@forecast.TemperatureF</td>
				<td>@forecast.Summary</td>
			</tr>
			}
		</tbody>
	</table>
}

@code {

	protected override void OnInitialized()
	{
		base.OnInitialized();
		dispatcher.Dispatch(new FetchDataAction());
	}
}
```

Repo : <https://github.com/antosubash/blazor-state-management-with-fluxor>
]]></content:encoded>
          </item><item>
          <title>.NET Microservice with ABP - Full Series</title>
          <link>https://blog.antosubash.com/posts/abp-microservice-series</link>
          <guid>https://blog.antosubash.com/posts/abp-microservice-series</guid>
          <pubDate>Sat, 23 Apr 2022 00:00:00 GMT</pubDate>
          <description>This post contains all the parts of the microservice development with ABP</description>
          <content:encoded><![CDATA[
## Posts in the Series

[Part 1. Initial Setup](/posts/netcore-microservice-with-abp-init-part-1)

[Part 2. Shared Project](/posts/netcore-microservice-with-abp-shared-project-part-2)

[Part 3. Administration Service](/posts/netcore-microservice-with-abp-administration-services-part-3)

[Part 4. Identity Service](/posts/netcore-microservice-with-abp-identity-services-part-4)

[Part 5. SaaS Service](/posts/netcore-microservice-with-abp-saas-services-part-5)

[Part 6. DB Migration](/posts/netcore-microservice-with-abp-db-migration-part-6)

[Part 7. Yarp and Tye](/posts/netcore-microservice-with-abp-yarp-and-tye-part-7)

[Part 8. Identity server and Angular App](/posts/netcore-microservice-with-abp-identity-server-and-angular-part-8)

[Part 9. Distributed event bus](/posts/netcore-microservice-with-abp-distributed-event-bus-part-9)

[Part 10. Docker and CI/CD](/posts/netcore-microservice-with-abp-docker-and-ci-cd-part-10)

[Part 11. Add a New service](/posts/netcore-microservice-with-abp-add-new-service-part-11)

[Part 12. Central Logging](/posts/netcore-microservice-with-abp-add-central-logging-part-12)

## Table of contents

## Intro

This post consolidates all the parts of the microservice development in the single place.

## What is ABP?

ABP framework is a complete infrastructure to create modern web applications by following the best practices and conventions of software development. ABP offers a complete, modular and layered software architecture based on Domain Driven Design principles and patterns. There are a lot of features provided by the ABP Framework to achieve real world scenarios easier, like Event Bus, Background Job System, Audit Logging, BLOB Storing, Data Seeding, Data Filtering, etc. ABP also simplifies (and even automates wherever possible) cross cutting concerns and common non-functional requirements like Exception Handling, Validation, Authorization, Localization, Caching, Dependency Injection, Setting Management, etc.

You can find more info here: <https://github.com/abpframework/abp>

You can find the documentation here: <https://docs.abp.io/en/abp/latest>

Here is the [Quick Start Guide](https://docs.abp.io/en/abp/latest/Tutorials/Todo/Index?UI=MVC&DB=EF)

## Why Microservice with ABP?

One of the major goals of the ABP framework is to provide a convenient infrastructure to create microservice solutions. To make this possible,

- Provides a module system that allows you to split your application into modules where each module may have its own database, entities, services, APIs, UI components/pages... etc.
- Offers an architectural model to develop your modules to be compatible to microservice development and deployment.
- Provides best practices guide to develop your module standards-compliance.
- Provides base infrastructure to implement Domain Driven Design in your microservice.
- Provide services to automatically create REST-style APIs from your application services.
- Provide services to automatically create C# API clients that makes easy to consume your services from another service/application.
- Provides a distributed event bus to communicate your services.

## Purpose

By default when you create a ABP application it will be a monolith. There is no definitive guide on how to create a microservice application with all the modules. The purpose of this blog series is to have a base solution of the ABP running as a microservice application. We will have a SaaS service for Tenant Management and Identity Service for Identity and IdentityServer and Admin Service for features, permissions, settings and audit logs. this will be a great base solution for your microservice and you will see how to setup the microservice from the scratch.


]]></content:encoded>
          </item><item>
          <title>Logging with Seq</title>
          <link>https://blog.antosubash.com/posts/netcore-microservice-with-abp-add-central-logging-part-12</link>
          <guid>https://blog.antosubash.com/posts/netcore-microservice-with-abp-add-central-logging-part-12</guid>
          <pubDate>Wed, 13 Apr 2022 00:00:00 GMT</pubDate>
          <description>In this post, we will see how to add centralized logging to our microservice application</description>
          <content:encoded><![CDATA[
This is the part 12 of the series: [.NET Microservice with ABP](/posts/abp-microservice-series)

## Posts in the Series

[Part 1. Initial Setup](/posts/netcore-microservice-with-abp-init-part-1)

[Part 2. Shared Project](/posts/netcore-microservice-with-abp-shared-project-part-2)

[Part 3. Administration Service](/posts/netcore-microservice-with-abp-administration-services-part-3)

[Part 4. Identity Service](/posts/netcore-microservice-with-abp-identity-services-part-4)

[Part 5. SaaS Service](/posts/netcore-microservice-with-abp-saas-services-part-5)

[Part 6. DB Migration](/posts/netcore-microservice-with-abp-db-migration-part-6)

[Part 7. Yarp and Tye](/posts/netcore-microservice-with-abp-yarp-and-tye-part-7)

[Part 8. Identity server and Angular App](/posts/netcore-microservice-with-abp-identity-server-and-angular-part-8)

[Part 9. Distributed event bus](/posts/netcore-microservice-with-abp-distributed-event-bus-part-9)

[Part 10. Docker and CI/CD](/posts/netcore-microservice-with-abp-docker-and-ci-cd-part-10)

[Part 11. Add a New service](/posts/netcore-microservice-with-abp-add-new-service-part-11)

Part 12. Central Logging (this post)

## Table of contents

## Intro

This is the Part 12 of the Microservice with ABP series. In this post, we will see how to add centralized logging to our microservice application

## What is Seq?

Seq is the intelligent search, analysis, and alerting server built specifically for modern structured log data. Seq creates the visibility you need to quickly identify and diagnose problems in complex applications and microservices.

## Why use Seq?

Application logs are the most useful data available for detecting and solving a wide range of production issues and outages. Seq makes it easier to pinpoint the events and patterns in application behavior that show your system is working correctly â€” or why it isn't.

More info here : <https://docs.datalust.co/docs/using-serilog>

## Purpose

In our microservice application, there are four services and one Identity server, and one gateway. This count will keep growing. We use serilog to log the data. But the logs are only available inside the application. This creates a problem. To solve this problem we will use seq. Seq will store all the logs in a central location so that it will make it easy for us to view the application logs and analyze them.

## Pricing

Seq is free if you run Seq on your developer workstation, or in production if you're going solo. what does this mean? it means that if you are using only one user account then it is free.

## Setup the shared project

Since the logging has to be applied in all the projects we can create the configuration in the shared project and apply it to all the services.

### Install the shared project

Install the Seq sinks for the serilog

```xml
<PackageReference Include="Serilog.Sinks.Seq" Version="5.1.1" />
<PackageReference Include="Serilog.Settings.Configuration" Version="3.3.0" />
```

### Create a serilog config helper

```cs
public static class SerilogConfigurationHelper
{
    public static void Configure(string applicationName)
    {
        var configuration = new ConfigurationBuilder()
            .SetBasePath(Directory.GetCurrentDirectory())
            .AddJsonFile("appsettings.json")
            .AddEnvironmentVariables()
            .Build();

        Log.Logger = new LoggerConfiguration()
            .ReadFrom.Configuration(configuration)
#if DEBUG
            .MinimumLevel.Debug()
#else
                .MinimumLevel.Information()
#endif
            .MinimumLevel.Override("Microsoft", LogEventLevel.Information)
            .MinimumLevel.Override("Microsoft.EntityFrameworkCore", LogEventLevel.Warning)
            .Enrich.FromLogContext()
            .Enrich.WithProperty("Application", $"{applicationName}")
            .WriteTo.Async(c => c.File("Logs/logs.txt"))
            .WriteTo.Async(c => c.Console())
            .CreateLogger();
    }
}
```

This Seirlog helper will replace all the other log configurations. 

### Add Serilog appsettings

```json
"Serilog": {
    "WriteTo": [
        { "Name": "Seq", "Args": { "serverUrl": "http://localhost:5341" } }
    ]
}
```

Server url points to location where the seq is hosted. In the above example it is pointed to the localhost instance of the seq.

## Update services

Logger configuration are preset in the `Program.cs` file in the services. we need to update the `Program.cs` file in the with the new log config.

```cs
var assemblyName = typeof(Program).Assembly.GetName().Name;
SerilogConfigurationHelper.Configure(assemblyName);
```

We are going to read the assembly name and send it to configure the logging. this is useful for separating the logs based on the services.

## Check the logs

Once all the services are updated run the services and you will be able to see the logs in the seq admin app.

Repo: <https://github.com/antosubash/Tasky>
]]></content:encoded>
          </item><item>
          <title>Add New Service</title>
          <link>https://blog.antosubash.com/posts/netcore-microservice-with-abp-add-new-service-part-11</link>
          <guid>https://blog.antosubash.com/posts/netcore-microservice-with-abp-add-new-service-part-11</guid>
          <pubDate>Thu, 07 Apr 2022 00:00:00 GMT</pubDate>
          <description>In this post we will see how to add docker support and create a CI/CD with github actions</description>
          <content:encoded><![CDATA[
This is the part 11 of the series: [.NET Microservice with ABP](/posts/abp-microservice-series)

## Posts in the Series

[Part 1. Initial Setup](/posts/netcore-microservice-with-abp-init-part-1)

[Part 2. Shared Project](/posts/netcore-microservice-with-abp-shared-project-part-2)

[Part 3. Administration Service](/posts/netcore-microservice-with-abp-administration-services-part-3)

[Part 4. Identity Service](/posts/netcore-microservice-with-abp-identity-services-part-4)

[Part 5. SaaS Service](/posts/netcore-microservice-with-abp-saas-services-part-5)

[Part 6. DB Migration](/posts/netcore-microservice-with-abp-db-migration-part-6)

[Part 7. Yarp and Tye](/posts/netcore-microservice-with-abp-yarp-and-tye-part-7)

[Part 8. Identity server and Angular App](/posts/netcore-microservice-with-abp-identity-server-and-angular-part-8)

[Part 9. Distributed event bus](/posts/netcore-microservice-with-abp-distributed-event-bus-part-9)

[Part 10. Docker and CI/CD](/posts/netcore-microservice-with-abp-docker-and-ci-cd-part-10)

Part 11. Add a New service (this post)

[Part 12. Central Logging](/posts/netcore-microservice-with-abp-add-central-logging-part-12)


## Table of contents

## Intro

In this post, we will add a new service to our microservice application.

## Create service script

```bash
$serviceNameInput = $args[0]

$solution = Get-ChildItem *.sln | Select-Object -First 1 | Get-ItemProperty -Name Name
$name = (Get-Item $solution.PSPath).Basename
$pascalCase = $serviceNameInput -replace '(?:^|_)(\p{L})', { $_.Groups[1].Value.ToUpper() }
$service = $pascalCase + "Service"
$folder = $serviceNameInput.ToLower()

abp new "$name.$service" -t module --no-ui -o services\$folder
Remove-Item -Recurse -Force (Get-ChildItem -Path "services\$folder" -Recurse -Include *.IdentityServer)
Remove-Item -Recurse -Force (Get-ChildItem -Path "services\$folder" -Recurse -Include *.MongoDB.Tests)
Remove-Item -Recurse -Force (Get-ChildItem -Path "services\$folder" -Recurse -Include *.MongoDB)
Remove-Item -Recurse -Force (Get-ChildItem -Path "services\$folder" -Recurse -Include *.Host.Shared)
Remove-Item -Recurse -Force (Get-ChildItem -Path "services\$folder" -Recurse -Include *.Installer)
dotnet sln ".\$name.sln" add (Get-ChildItem -Path "services\$folder" -Recurse -Include *.csproj)
```

## Run the script

Please make sure to run this command in the root of your project where the solution file is located.

```bash
.\newservice.ps1 project
```

This script will create a new service and do some cleanup and add the project to solution.

## Create shared hosting for Microservice

```bash
dotnet new classlib -n Tasky.Microservice.Shared -o shared\Tasky.Microservice.Shared
```

We are creating this project as a shared project for all the new microservice.

Add the reference to `AdministrationService` and `SaaSService`

```xml
<ItemGroup>
  <ProjectReference Include="..\..\services\administration\src\Tasky.AdministrationService.EntityFrameworkCore\Tasky.AdministrationService.EntityFrameworkCore.csproj" />
  <ProjectReference Include="..\..\services\saas\src\Tasky.SaaSService.EntityFrameworkCore\Tasky.SaaSService.EntityFrameworkCore.csproj" />
  <ProjectReference Include="..\Tasky.Shared.Hosting\Tasky.Shared.Hosting.csproj" />
</ItemGroup>
```

Create the `TaskyMicroserviceHosting` module

```cs
[DependsOn(
    typeof(TaskyHostingModule),
    typeof(AdministrationServiceEntityFrameworkCoreModule),
    typeof(SaaSServiceEntityFrameworkCoreModule)
)]
public class TaskyMicroserviceHosting : AbpModule
{

}
```

Now we have the shared project we can use for all the new microservice

## Prepare the host project

Add the reference the of the Shared microservice project

```xml
<ProjectReference Include="..\..\..\..\shared\Tasky.Shared.Microservice.Hosting\Tasky.Shared.Microservice.Hosting.csproj" />
```

Update the `DependsOn` in the host project

```cs
[DependsOn(
    typeof(TaskyMicroserviceHosting),
    typeof(ProjectServiceApplicationModule),
    typeof(ProjectServiceEntityFrameworkCoreModule),
    typeof(ProjectServiceHttpApiModule)
    )]
```

Update the host port to `7004`

Update the `appsettings.json`

```json
{
  "App": {
    "CorsOrigins": "http://localhost:4200"
  },
  "ConnectionStrings": {
    "ProjectService": "User ID=postgres;Password=postgres;Host=localhost;Port=5432;Database=TaskyProjectService;Pooling=false;",
    "SaaSService": "User ID=postgres;Password=postgres;Host=localhost;Port=5432;Database=TaskySaaSService;Pooling=false;",
    "AdministrationService": "User ID=postgres;Password=postgres;Host=localhost;Port=5432;Database=TaskyAdministrationService;Pooling=false;"
  },
  "Redis": {
    "Configuration": "127.0.0.1"
  },
  "AuthServer": {
    "Authority": "https://localhost:7000/",
    "RequireHttpsMetadata": "false",
    "SwaggerClientId": "ProjectService_Swagger",
    "SwaggerClientSecret": "1q2w3e*"
  },
  "RabbitMQ": {
    "Connections": {
      "Default": {
        "HostName": "localhost"
      }
    },
    "EventBus": {
      "ClientName": "Tasky_ProjectService",
      "ExchangeName": "Tasky"
    }
  }
}
```

## Update the EF core project

create a `ProjectServiceDbContextFactory` in the EF core project

```cs
public class ProjectServiceDbContextFactory : IDesignTimeDbContextFactory<ProjectServiceDbContext>
{
    public ProjectServiceDbContext CreateDbContext(string[] args)
    {
        var configuration = BuildConfiguration();

        var builder = new DbContextOptionsBuilder<ProjectServiceDbContext>()
            .UseNpgsql(GetConnectionStringFromConfiguration());

        return new ProjectServiceDbContext(builder.Options);
    }

    private static string GetConnectionStringFromConfiguration()
    {
        return BuildConfiguration()
            .GetConnectionString(ProjectServiceDbProperties.ConnectionStringName);
    }

    private static IConfigurationRoot BuildConfiguration()
    {
        var builder = new ConfigurationBuilder()
            .SetBasePath(
                Path.Combine(
                    Directory.GetParent(Directory.GetCurrentDirectory())?.Parent!.FullName!,
                    $"host{Path.DirectorySeparatorChar}Tasky.ProjectService.HttpApi.Host"
                )
            )
            .AddJsonFile("appsettings.json", false);

        return builder.Build();
    }
}
```

## Create a project API

Create the project entity

```cs
public class Project : AggregateRoot<Guid>, IMultiTenant
{
    public string Name { get; set; }

    public Guid? TenantId { get; set; }

    public Project(string name)
    {
        Name = name;
    }
}
```

Add `Projects` to the `DbContext`

```cs
public DbSet<Project> Projects { get; set; }
```

Update the `ProjectServiceDbContextModelCreatingExtensions` in the `ConfigureProjectService` method

```cs
builder.Entity<Project>(b =>
{
    //Configure table & schema name
    b.ToTable(ProjectServiceDbProperties.DbTablePrefix + "Projects", ProjectServiceDbProperties.DbSchema);

    b.ConfigureByConvention();
});
```

Update the `ProjectServiceEntityFrameworkCoreModule` in the `AddAbpDbContext`

```cs
context.Services.AddAbpDbContext<ProjectServiceDbContext>(options =>
{
    options.AddDefaultRepositories(true);
});
```

## Prepare for the migration

Add the ef core design nuget for the migrations.

```xml
<PackageReference Include="Microsoft.EntityFrameworkCore.Design" Version="6.0.1">
    <PrivateAssets>all</PrivateAssets>
    <IncludeAssets>runtime; build; native; contentfiles; analyzers</IncludeAssets>
</PackageReference>
```

Once this is created delete `EntityFrameworkCore` folder can be created from the host project.

## Migration

To create migrations

`dotnet ef migrations add Init`

To update database

`dotnet ef database update`

## Create feature definition in contracts

Add the Feature package

```xml
<PackageReference Include="Volo.Abp.Features" Version="5.2.0" />
```

Create `ProjectServiceFeatures` for the constants 

```cs
public class ProjectServiceFeatures
{
    public const string GroupName = "ProjectService";

    public static class Project
    {
        public const string Default = GroupName + ".Project";
    }
}
```

Create `ProjectServiceFeaturesDefinitionProvider` for creating permissions

```cs
public class ProjectServiceFeaturesDefinitionProvider : FeatureDefinitionProvider
{
    public override void Define(IFeatureDefinitionContext context)
    {
        var myGroup = context.AddGroup(ProjectServiceFeatures.GroupName);
        myGroup.AddFeature(
            ProjectServiceFeatures.Project.Default, 
            defaultValue: "false",            
            displayName: L("Project"),
            valueType: new ToggleStringValueType());
    }

    private static LocalizableString L(string name)
    {
        return LocalizableString.Create<ProjectServiceResource>(name);
    }
}
```

## Create permission

Create `ProjectServicePermissions` file

```cs
public const string GroupName = "ProjectService";

public static class Project
{
    public const string Default = GroupName + ".Project";
    public const string Create = Default + ".Create";
}
```

Create `ProjectServicePermissionDefinitionProvider` file

```cs
public class ProjectServicePermissionDefinitionProvider : PermissionDefinitionProvider
{
    public override void Define(IPermissionDefinitionContext context)
    {
        var projectGroup = context.AddGroup(ProjectServicePermissions.GroupName, L("Permission:ProjectService"));
        var projectPermission = projectGroup.AddPermission(ProjectServicePermissions.Project.Default, L("Permission:ProjectService:Default"));
        projectPermission.AddChild(ProjectServicePermissions.Project.Create);

    }

    private static LocalizableString L(string name)
    {
        return LocalizableString.Create<ProjectServiceResource>(name);
    }
}
```

## Create AppService Contract

Create `ProjectDto` file

```cs
public class ProjectDto : EntityDto<Guid>
{
    public string Name { get; set; }
}
```

Create `IProjectAppService` file

```cs
public interface IProjectAppService : IApplicationService
{
    Task<List<ProjectDto>> GetAllAsync();

    Task<ProjectDto> Create(ProjectDto projectDto);
}
```

## Create AppService in the Application

Create `ProjectAppService` file

```cs
[RequiresFeature(ProjectServiceFeatures.Project.Default)]
[Authorize(ProjectServicePermissions.Project.Default)]
public class ProjectAppService : ProjectServiceAppService, IProjectAppService
{
    private readonly IRepository<Project, Guid> repository;

    public ProjectAppService(IRepository<Project, Guid> repository)
    {
        this.repository = repository;
    }

    [Authorize(ProjectServicePermissions.Project.Default)]    
    public async Task<List<ProjectDto>> GetAllAsync()
    {
        var projects = await repository.GetListAsync();
        return ObjectMapper.Map<List<Project>,List<ProjectDto>>(projects);
    }

    [Authorize(ProjectServicePermissions.Project.Create)]
    public async Task<ProjectDto> Create(ProjectDto projectDto)
    {
        var project = await repository.InsertAsync(new Project(projectDto.Name));
        return new ProjectDto
        {
            Name = project.Name
        };
    }
}
```

## Create a Controller

```cs
[Area(ProjectServiceRemoteServiceConsts.ModuleName)]
[RemoteService(Name = ProjectServiceRemoteServiceConsts.RemoteServiceName)]
[Route("api/project")]
public class ProjectController : ProjectServiceController, IProjectAppService
{
    private readonly IProjectAppService _projectService;

    public ProjectController(IProjectAppService sampleAppService)
    {
        _projectService = sampleAppService;
    }

    [HttpGet]
    public async Task<List<ProjectDto>> GetAllAsync()
    {
        return await _projectService.GetAllAsync();
    }

    
    [HttpPost]    
    public async Task<ProjectDto> Create(ProjectDto projectDto)
    {
        return await _projectService.Create(projectDto);
    }
}
```

## Update the DbMigrator project

Add the project reference for the new service

```xml
<ProjectReference Include="..\..\services\project\src\Tasky.ProjectService.Application.Contracts\Tasky.ProjectService.Application.Contracts.csproj" />
<ProjectReference Include="..\..\services\project\src\Tasky.ProjectService.EntityFrameworkCore\Tasky.ProjectService.EntityFrameworkCore.csproj" />
```

Update the dependency

```cs
typeof(ProjectServiceEntityFrameworkCoreModule),
typeof(ProjectServiceApplicationContractsModule)
```

Update the `MigrateAllDatabasesAsync` function in the  `TaskyDbMigrationService` file

```cs
await MigrateDatabaseAsync<ProjectServiceDbContext>(cancellationToken);
```

Update the `appsettings.json`

```json
{
  "ConnectionStrings": {
    "SaaSService": "User ID=postgres;Password=postgres;Host=localhost;Port=5432;Database=TaskySaaSService;Pooling=false;",
    "IdentityService": "User ID=postgres;Password=postgres;Host=localhost;Port=5432;Database=TaskyIdentityService;Pooling=false;",
    "AdministrationService": "User ID=postgres;Password=postgres;Host=localhost;Port=5432;Database=TaskyAdministrationService;Pooling=false;",
    "ProjectService": "User ID=postgres;Password=postgres;Host=localhost;Port=5432;Database=TaskyProjectService;Pooling=false;"
  },
  "ApiScope": [
    "AuthServer",
    "SaaSService",
    "IdentityService",
    "AdministrationService",
    "ProjectService"
  ],
  "ApiResource": [
    "AuthServer",
    "SaaSService",
    "IdentityService",
    "AdministrationService",
    "ProjectService"
  ],
  "Clients": [
    {
      "ClientId": "Tasky_Web",
      "ClientSecret": "1q2w3e*",
      "RootUrls": [
        "https://localhost:5000"
      ],
      "Scopes": [
        "SaaSService",
        "IdentityService",
        "AdministrationService",
        "ProjectService"
      ],
      "GrantTypes": [
        "hybrid"
      ],
      "RedirectUris": [
        "https://localhost:5000/signin-oidc"
      ],
      "PostLogoutRedirectUris": [
        "https://localhost:5000/signout-callback-oidc"
      ],
      "AllowedCorsOrigins": [
        "https://localhost:5000"
      ]
    },
    {
      "ClientId": "Tasky_App",
      "ClientSecret": "1q2w3e*",
      "RootUrls": [
        "http://localhost:4200"
      ],
      "Scopes": [
        "AuthServer",
        "SaaSService",
        "IdentityService",
        "AdministrationService",
        "ProjectService"
      ],
      "GrantTypes": [
        "authorization_code"
      ],
      "RedirectUris": [
        "http://localhost:4200"
      ],
      "PostLogoutRedirectUris": [
        "http://localhost:4200"
      ],
      "AllowedCorsOrigins": [
        "http://localhost:4200"
      ]
    },
    {
      "ClientId": "AdministrationService_Swagger",
      "ClientSecret": "1q2w3e*",
      "RootUrls": [
        "https://localhost:7001"
      ],
      "Scopes": [
        "SaaSService",
        "IdentityService",
        "AdministrationService",
        "ProjectService"
      ],
      "GrantTypes": [
        "authorization_code"
      ],
      "RedirectUris": [
        "https://localhost:7001/swagger/oauth2-redirect.html"
      ],
      "PostLogoutRedirectUris": [
        "https://localhost:7001/signout-callback-oidc"
      ],
      "AllowedCorsOrigins": [
        "https://localhost:7001"
      ]
    },
    {
      "ClientId": "IdentityService_Swagger",
      "ClientSecret": "1q2w3e*",
      "RootUrls": [
        "https://localhost:7002"
      ],
      "Scopes": [
        "SaaSService",
        "IdentityService",
        "AdministrationService",
        "ProjectService"
      ],
      "GrantTypes": [
        "authorization_code"
      ],
      "RedirectUris": [
        "https://localhost:7002/swagger/oauth2-redirect.html"
      ],
      "PostLogoutRedirectUris": [
        "https://localhost:7002"
      ],
      "AllowedCorsOrigins": [
        "https://localhost:7002"
      ]
    },
    {
      "ClientId": "SaaSService_Swagger",
      "ClientSecret": "1q2w3e*",
      "RootUrls": [
        "https://localhost:7003"
      ],
      "Scopes": [
        "SaaSService",
        "IdentityService",
        "AdministrationService",
        "ProjectService"
      ],
      "GrantTypes": [
        "authorization_code"
      ],
      "RedirectUris": [
        "https://localhost:7003/swagger/oauth2-redirect.html"
      ],
      "PostLogoutRedirectUris": [
        "https://localhost:7003"
      ],
      "AllowedCorsOrigins": [
        "https://localhost:7003"
      ]
    },
    {
      "ClientId": "ProjectService_Swagger",
      "ClientSecret": "1q2w3e*",
      "RootUrls": [
        "https://localhost:7004"
      ],
      "Scopes": [
        "SaaSService",
        "IdentityService",
        "AdministrationService",
        "ProjectService"
      ],
      "GrantTypes": [
        "authorization_code"
      ],
      "RedirectUris": [
        "https://localhost:7004/swagger/oauth2-redirect.html"
      ],
      "PostLogoutRedirectUris": [
        "https://localhost:7004"
      ],
      "AllowedCorsOrigins": [
        "https://localhost:7004"
      ]
    }
  ]
}
```

## Prepare the Administration service

Add reference to the `ProjectService.Application.Contracts` project.

```cs
<ProjectReference Include="..\..\..\project\src\Tasky.ProjectService.Application.Contracts\Tasky.ProjectService.Application.Contracts.csproj" />
```

Update the dependency in the Admin Host

```cs
typeof(ProjectServiceApplicationContractsModule)
```

Repo: <https://github.com/antosubash/Tasky>
]]></content:encoded>
          </item><item>
          <title>Docker and CI/CD</title>
          <link>https://blog.antosubash.com/posts/netcore-microservice-with-abp-docker-and-ci-cd-part-10</link>
          <guid>https://blog.antosubash.com/posts/netcore-microservice-with-abp-docker-and-ci-cd-part-10</guid>
          <pubDate>Sat, 26 Mar 2022 00:00:00 GMT</pubDate>
          <description>In this post we will see how to add docker support and create a CI/CD with github actions</description>
          <content:encoded><![CDATA[
This is the part 10 of the series: [.NET Microservice with ABP](/posts/abp-microservice-series)

## Posts in the Series

[Part 1. Initial Setup](/posts/netcore-microservice-with-abp-init-part-1)

[Part 2. Shared Project](/posts/netcore-microservice-with-abp-shared-project-part-2)

[Part 3. Administration Service](/posts/netcore-microservice-with-abp-administration-services-part-3)

[Part 4. Identity Service](/posts/netcore-microservice-with-abp-identity-services-part-4)

[Part 5. SaaS Service](/posts/netcore-microservice-with-abp-saas-services-part-5)

[Part 6. DB Migration](/posts/netcore-microservice-with-abp-db-migration-part-6)

[Part 7. Yarp and Tye](/posts/netcore-microservice-with-abp-yarp-and-tye-part-7)

[Part 8. Identity server and Angular App](/posts/netcore-microservice-with-abp-identity-server-and-angular-part-8)

[Part 9. Distributed event bus](/posts/netcore-microservice-with-abp-distributed-event-bus-part-9)

Part 10. Docker and CI/CD (this post)

[Part 11. Add a New service](/posts/netcore-microservice-with-abp-add-new-service-part-11)

[Part 12. Central Logging](/posts/netcore-microservice-with-abp-add-central-logging-part-12)


## Table of contents

## Intro

In this post we will see how to add docker support to all the services and setup a CI/CD pipeline with github actions.

## Docker support

Docker support can be added easily by using visual studio. since all the project is available in the solution vs will create a Docker file and add it to the project. In this we will use the Identity server it will be similar for all the other services.

To add Docker support right click on the Identity server project and choose add.

![Add Docker](/assets/posts/microservice/part10/docker0.png)

In the add menu choose docker support

![Add Menu](/assets/posts/microservice/part10/docker1.png)

In the docker file option choose linux

![Docker Options](/assets/posts/microservice/part10/docker2.png)

The final docker file will look like this. Here is the location of this sample file <https://github.com/antosubash/AbpMicroservice/blob/main/apps/Tasky.IdentityServer/Dockerfile>

![Docker file](/assets/posts/microservice/part10/docker3.png)

We have to do this to all the services.

## CI/CD

Here is the sample github action file.

```yaml
name: Docker Image CI

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:

  build:

    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v2
    - name: Build the Gateway Docker image
      run: docker build . --file gateway/Tasky.Gateway/Dockerfile --tag gateway:dev
    - name: Build the IdentityServer Docker image
      run: docker build . --file apps/Tasky.IdentityServer/Dockerfile --tag identityserver:dev
    - name: Build the Administration Docker image
      run: docker build . --file services/administration/host/Tasky.AdministrationService.HttpApi.Host/Dockerfile --tag administration:dev
    - name: Build the IdentityService Docker image
      run: docker build . --file services/identity/host/Tasky.IdentityService.HttpApi.Host/Dockerfile --tag identityservice:dev
    - name: Build the SaaS Docker image
      run: docker build . --file services/saas/host/Tasky.SaaSService.HttpApi.Host/Dockerfile --tag saas:dev
```
]]></content:encoded>
          </item><item>
          <title>Distributed Event Bus</title>
          <link>https://blog.antosubash.com/posts/netcore-microservice-with-abp-distributed-event-bus-part-9</link>
          <guid>https://blog.antosubash.com/posts/netcore-microservice-with-abp-distributed-event-bus-part-9</guid>
          <pubDate>Fri, 25 Mar 2022 00:00:00 GMT</pubDate>
          <description>In this post we will see how to get the RabbitMQ working for service to service communication</description>
          <content:encoded><![CDATA[
This is the part 9 of the series: [.NET Microservice with ABP](/posts/abp-microservice-series)

## Posts in the Series

[Part 1. Initial Setup](/posts/netcore-microservice-with-abp-init-part-1)

[Part 2. Shared Project](/posts/netcore-microservice-with-abp-shared-project-part-2)

[Part 3. Administration Service](/posts/netcore-microservice-with-abp-administration-services-part-3)

[Part 4. Identity Service](/posts/netcore-microservice-with-abp-identity-services-part-4)

[Part 5. SaaS Service](/posts/netcore-microservice-with-abp-saas-services-part-5)

[Part 6. DB Migration](/posts/netcore-microservice-with-abp-db-migration-part-6)

[Part 7. Yarp and Tye](/posts/netcore-microservice-with-abp-yarp-and-tye-part-7)

[Part 8. Identity server and Angular App](/posts/netcore-microservice-with-abp-identity-server-and-angular-part-8)

Part 9. Distributed event bus (this post)

[Part 10. Docker and CI/CD](/posts/netcore-microservice-with-abp-docker-and-ci-cd-part-10)

[Part 11. Add a New service](/posts/netcore-microservice-with-abp-add-new-service-part-11)

[Part 12. Central Logging](/posts/netcore-microservice-with-abp-add-central-logging-part-12)


## Table of contents

## Intro

In this post, we will see how to set up service-to-service communication. We will use RabbitMQ as an event bus. Each service will have a RabbitMQ configuration. ABP comes with the inbuilt support to use the RabbitMQ for events. The packages are already available in the shared project we created in part 2. We just have to add the configuration in the appsettings and implement the events.

## Update appsettings.json

### Administration service

```xml
"RabbitMQ": {
  "Connections": {
    "Default": {
      "HostName": "localhost"
    }
  },
  "EventBus": {
    "ClientName": "Tasky_Administration",
    "ExchangeName": "Tasky"
  }
}
```

### Identity service

```xml
"RabbitMQ": {
  "Connections": {
    "Default": {
      "HostName": "localhost"
    }
  },
  "EventBus": {
    "ClientName": "Tasky_Identity",
    "ExchangeName": "Tasky"
  }
}
```

### SaaS service

```xml
"RabbitMQ": {
  "Connections": {
    "Default": {
      "HostName": "localhost"
    }
  },
  "EventBus": {
    "ClientName": "Tasky_SaaS",
    "ExchangeName": "Tasky"
  }
}
```

### Identity Server

```xml
"RabbitMQ": {
  "Connections": {
    "Default": {
      "HostName": "localhost"
    }
  },
  "EventBus": {
    "ClientName": "Tasky_AuthServer",
    "ExchangeName": "Tasky"
  }
}
```

## Tenant Created Event handlers for Administration Service

When the tenant is created in the SaaS service, the administration service needs to know about the newly created tenant so that we can add permission for the new tenant. This permission is given to the admin role. So that when the user is created with the admin role then he can log in to the newly created tenant. The tenant management module triggers a tenant-created event every time a tenant is created. We don't have to do anything extra in our code. We just have to handle the created event. Following is how you can manage the tenant-created event.

```cs
using System;
using System.Linq;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using Volo.Abp.Authorization.Permissions;
using Volo.Abp.DependencyInjection;
using Volo.Abp.EventBus.Distributed;
using Volo.Abp.MultiTenancy;
using Volo.Abp.PermissionManagement;
using Volo.Abp.Uow;

namespace Tasky.Administration.EventHandler;

public class TenantCreatedEventHandler : IDistributedEventHandler<TenantCreatedEto>, ITransientDependency
{
    private readonly ICurrentTenant _currentTenant;
    private readonly ILogger<TenantCreatedEventHandler> _logger;
    private readonly IPermissionDataSeeder _permissionDataSeeder;
    private readonly IPermissionDefinitionManager _permissionDefinitionManager;
    private readonly IUnitOfWorkManager _unitOfWorkManager;

    public TenantCreatedEventHandler(
        ICurrentTenant currentTenant,
        IUnitOfWorkManager unitOfWorkManager,
        IPermissionDefinitionManager permissionDefinitionManager,
        IPermissionDataSeeder permissionDataSeeder,
        ILogger<TenantCreatedEventHandler> logger)
    {
        _currentTenant = currentTenant;
        _unitOfWorkManager = unitOfWorkManager;
        _permissionDefinitionManager = permissionDefinitionManager;
        _permissionDataSeeder = permissionDataSeeder;
        _logger = logger;
    }

    public async Task HandleEventAsync(TenantCreatedEto eventData)
    {
        try
        {
            await SeedDataAsync(eventData.Id);
        }
        catch (Exception ex)
        {
            await HandleErrorTenantCreatedAsync(eventData, ex);
        }
    }

    private Task HandleErrorTenantCreatedAsync(TenantCreatedEto eventData, Exception ex)
    {
        throw new NotImplementedException();
    }

    private async Task SeedDataAsync(Guid? tenantId)
    {
        _logger.LogInformation($"Seeding ${tenantId}");
        using (_currentTenant.Change(tenantId))
        {
            var abpUnitOfWorkOptions = new AbpUnitOfWorkOptions {IsTransactional = true};
            using var uow = _unitOfWorkManager.Begin(abpUnitOfWorkOptions, true);
            var multiTenancySide = tenantId is null
                ? MultiTenancySides.Host
                : MultiTenancySides.Tenant;

            var permissionNames = _permissionDefinitionManager
                .GetPermissions()
                .Where(p => p.MultiTenancySide.HasFlag(multiTenancySide))
                .Where(p => !p.Providers.Any() || p.Providers.Contains(RolePermissionValueProvider.ProviderName))
                .Select(p => p.Name)
                .ToArray();

            await _permissionDataSeeder.SeedAsync(
                RolePermissionValueProvider.ProviderName,
                "admin",
                permissionNames,
                tenantId
            );

            await uow.CompleteAsync();
        }
    }
}
```

## Tenant Created Event handlers for Identity Service

Similar to what we have done in the administration service. we need to handle the tenant created event in the identity service to create the admin user for the newly created tenant. we can create the event handler and seed the user with the default username and password.

```cs
using System;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using Volo.Abp.DependencyInjection;
using Volo.Abp.EventBus.Distributed;
using Volo.Abp.MultiTenancy;
using Volo.Abp.Identity;
using System.Collections.Generic;

namespace Tasky.IdentityService.EventHandler;

public class TenantCreatedEventHandler : IDistributedEventHandler<TenantCreatedEto>, ITransientDependency
{
    private readonly ICurrentTenant _currentTenant;
    private readonly ILogger<TenantCreatedEventHandler> _logger;
    private readonly IIdentityDataSeeder _identityDataSeeder;
    public TenantCreatedEventHandler(
        ICurrentTenant currentTenant,
        IIdentityDataSeeder identityDataSeeder,
        ILogger<TenantCreatedEventHandler> logger)
    {
        _currentTenant = currentTenant;
        _identityDataSeeder = identityDataSeeder;
        _logger = logger;
    }

    public async Task HandleEventAsync(TenantCreatedEto eventData)
    {
        try
        {
            using (_currentTenant.Change(eventData.Id))
            {
                
                _logger.LogInformation($"Creating admin user for tenant {eventData.Id}...");
                await _identityDataSeeder.SeedAsync(
                    eventData.Properties.GetOrDefault(IdentityDataSeedContributor.AdminEmailPropertyName) ?? "admin@abp.io",
                    eventData.Properties.GetOrDefault(IdentityDataSeedContributor.AdminPasswordPropertyName) ?? "1q2w3E*",
                    eventData.Id
                );
            }
        }
        catch (Exception ex)
        {
            await HandleErrorTenantCreatedAsync(eventData, ex);
        }
    }

    private Task HandleErrorTenantCreatedAsync(TenantCreatedEto eventData, Exception ex)
    {
        throw new NotImplementedException();
    }
}
```

## Run

Use tye to run all the services. When the service starts it will create the queue in the RabbitMQ. So make sure you have RabbitMQ running.

```bash
tye run
```

## Test

To test the event bus. Login to the angular app in `http://localhost:4200` as admin and create a new tenant. Once the tenant is created logout and try to login to the tenant you just created. if the event bus is working then you can login with default username and password for the newly created tenant.
]]></content:encoded>
          </item><item>
          <title>IdentityServer and Angular</title>
          <link>https://blog.antosubash.com/posts/netcore-microservice-with-abp-identity-server-and-angular-part-8</link>
          <guid>https://blog.antosubash.com/posts/netcore-microservice-with-abp-identity-server-and-angular-part-8</guid>
          <pubDate>Sun, 20 Mar 2022 00:00:00 GMT</pubDate>
          <description>In this post we will see how to get the IdentityServer and the Angular App working with other services</description>
          <content:encoded><![CDATA[
This is eight post of the series: [.NET Microservice with ABP](/posts/abp-microservice-series)

## Posts in the Series

[Part 1. Initial Setup](/posts/netcore-microservice-with-abp-init-part-1)

[Part 2. Shared Project](/posts/netcore-microservice-with-abp-shared-project-part-2)

[Part 3. Administration Service](/posts/netcore-microservice-with-abp-administration-services-part-3)

[Part 4. Identity Service](/posts/netcore-microservice-with-abp-identity-services-part-4)

[Part 5. SaaS Service](/posts/netcore-microservice-with-abp-saas-services-part-5)

[Part 6. DB Migration](/posts/netcore-microservice-with-abp-db-migration-part-6)

[Part 7. Yarp and Tye](/posts/netcore-microservice-with-abp-yarp-and-tye-part-7)

Part 8. Identity server and Angular App (this post)

[Part 9. Distributed event bus](/posts/netcore-microservice-with-abp-distributed-event-bus-part-9)

[Part 10. Docker and CI/CD](/posts/netcore-microservice-with-abp-docker-and-ci-cd-part-10)

[Part 11. Add a New service](/posts/netcore-microservice-with-abp-add-new-service-part-11)

[Part 12. Central Logging](/posts/netcore-microservice-with-abp-add-central-logging-part-12)


## Table of contents

## Intro

We have copied the IdentityServer and Angular app from the default tired app. So they are configured to work with the tired app. we will modify the Identity server to use the newly created services and the change the config of the angular app to use the Reverse proxy we created with Yarp.

## IdentityServer

Even thought we already have the Identity service. it only provides the API endpoints to manage the user. We need the Identity server to do the JWT auth and also for the login and registration. IdentityServer is the default way to login user in the ABP framework right now. But there are plans to replace IdentityServer and replace it with the [OpenIdDict](https://github.com/openiddict/openiddict-core) if you want to know more about this go and check here <https://github.com/abpframework/abp/issues/11989>

### Remove the wrong reference

During the code generation by default Identity server will have the reference for the `EFCore` project. But after moving the Identity server this reference will be wrong. So the first step is to remove all the project reference in the `csproj` file of the identity server.

### Add new reference

Once the old references are removed we need to add the new reference to the identity server project. The Identity server should know about all 3 base services `identity`, `administration` and `saas`. So we need to add the reference for the `EFCore` projects of all the 3 services. Along with we also need to add the reference for the Shared project so that we can reuse some code.

```xml
<ItemGroup>
    <ProjectReference Include="..\..\services\administration\src\Tasky.AdministrationService.EntityFrameworkCore\Tasky.AdministrationService.EntityFrameworkCore.csproj" />
    <ProjectReference Include="..\..\services\identity\src\Tasky.IdentityService.EntityFrameworkCore\Tasky.IdentityService.EntityFrameworkCore.csproj" />
    <ProjectReference Include="..\..\services\saas\src\Tasky.SaaSService.EntityFrameworkCore\Tasky.SaaSService.EntityFrameworkCore.csproj" />
    <ProjectReference Include="..\..\shared\Tasky.Shared.Hosting\Tasky.Shared.Hosting.csproj" />
</ItemGroup>
```

### Update the connection string

Once we added the reference to the `EFCore` projects we need to add the connection string for the services in the `appsettings.json` file so that the Identity server can find the database.

```xml
"ConnectionStrings": {
  "SaaSService": "User ID=postgres;Password=postgres;Host=localhost;Port=5432;Database=TaskySaaSService;Pooling=false;",
  "IdentityService": "User ID=postgres;Password=postgres;Host=localhost;Port=5432;Database=TaskyIdentityService;Pooling=false;",
  "AdministrationService": "User ID=postgres;Password=postgres;Host=localhost;Port=5432;Database=TaskyAdministrationService;Pooling=false;"
},
```

### Update CORS urls

All the services and apps need to contact the Identity server to validate the tokens. so we should add the urls of the service in the `CorsOrigins` section of the `appsettings.json`

```json
"CorsOrigins": "http://localhost:4200,https://localhost:7001,https://localhost:7002,https://localhost:7003",
```

### Update the Authority URL

All the service has `Authority` url in the `appsettings.json` file. we have to change that file to point to the identity server.

```json
"Authority": "https://localhost:7000/",
```

### Update the module dependency

Identity server project should have a `IdentityServerModule` in the root of the project directory. In that module we need update the module dependency so that the `EFCore` modules will be loaded correctly. We also should add the shared module.

```cs
typeof(AbpAccountWebIdentityServerModule),
typeof(AbpAccountApplicationModule),
typeof(AbpAccountHttpApiModule),
typeof(AbpAspNetCoreMvcUiBasicThemeModule),
typeof(AdministrationServiceEntityFrameworkCoreModule),
typeof(SaaSServiceEntityFrameworkCoreModule),
typeof(IdentityServiceEntityFrameworkCoreModule),
typeof(TaskyHostingModule)
```

Once this is done. our identity server is ready for our use. launch the identity server and see if you can login as a super admin.

### Running Identity server

```bash
dotnet run
```

This should launch the identity server and it should be running in the port `7000`

## Angular App

angular app in abp is a self contained app. there is not dependency to any other abp project. so to run the we just have to point the angular app in the correct direction and it should work. We need to change 2 things in the angular app. one is the `OAuthConfig` so that it know where is the identity server is running and the `API` endpoint which is the reverse proxy in our case which has all the endpoints. you will be able to find the `environment.ts` file in `apps\angular\src\environments`.

```ts
import { Environment } from '@abp/ng.core';

const baseUrl = 'http://localhost:4200';

export const environment = {
  production: false,
  application: {
    baseUrl: 'http://localhost:4200/',
    name: 'Tasky',
    logoUrl: '',
  },
  oAuthConfig: {
    issuer: 'https://localhost:7000',
    redirectUri: baseUrl,
    clientId: 'Tasky_App',
    responseType: 'code',
    scope: 'offline_access IdentityService AdministrationService SaaSService role email openid profile',
    requireHttps: true
  },
  apis: {
    default: {
      url: 'https://localhost:7500',
      rootNamespace: 'Tasky',
    }
  },
} as Environment;
```

### Run

Once you have updated the `environment.ts` make sure the packages are installed for your angular app.

#### To install packages

```bash
yarn
```

> you need to have yarn installed for this command to work

This command will install all the packages needed for your angular app.

#### To Run

To run the angular app run the following command

```bash
yarn start
```

This will start the angular dev server and your application will be running in the port `4200`.
]]></content:encoded>
          </item><item>
          <title>Yarp and Tye</title>
          <link>https://blog.antosubash.com/posts/netcore-microservice-with-abp-yarp-and-tye-part-7</link>
          <guid>https://blog.antosubash.com/posts/netcore-microservice-with-abp-yarp-and-tye-part-7</guid>
          <pubDate>Sat, 19 Mar 2022 05:00:00 GMT</pubDate>
          <description>In this post we will see how to create a reverse proxy with Yarp and integrate Tye for our microservice application</description>
          <content:encoded><![CDATA[
This is seventh post of the series: [.NET Microservice with ABP](/posts/abp-microservice-series)

## Posts in the Series

[Part 1. Initial Setup](/posts/netcore-microservice-with-abp-init-part-1)

[Part 2. Shared Project](/posts/netcore-microservice-with-abp-shared-project-part-2)

[Part 3. Administration Service](/posts/netcore-microservice-with-abp-administration-services-part-3)

[Part 4. Identity Service](/posts/netcore-microservice-with-abp-identity-services-part-4)

[Part 5. SaaS Service](/posts/netcore-microservice-with-abp-saas-services-part-5)

[Part 6. DB Migration](/posts/netcore-microservice-with-abp-db-migration-part-6)

Part 7. Yarp and Tye (this post)

[Part 8. Identity server and Angular App](/posts/netcore-microservice-with-abp-identity-server-and-angular-part-8)

[Part 9. Distributed event bus](/posts/netcore-microservice-with-abp-distributed-event-bus-part-9)

[Part 10. Docker and CI/CD](/posts/netcore-microservice-with-abp-docker-and-ci-cd-part-10)

[Part 11. Add a New service](/posts/netcore-microservice-with-abp-add-new-service-part-11)

[Part 12. Central Logging](/posts/netcore-microservice-with-abp-add-central-logging-part-12)

## Table of contents

## Tye

Lets init the tye.

### Install tye

```bash
dotnet tool install -g Microsoft.Tye --version "0.11.0-alpha.22111.1"
```

### Init Tye

```bash
tye init --force
```

This will generate a `tye.yaml` file.

```yaml
name: tasky
services:
- name: tasky-identityserver
  project: apps/Tasky.IdentityServer/Tasky.IdentityServer.csproj
  bindings:
    - protocol: https
      port: 7000
- name: tasky-gateway
  project: gateway/Tasky.Gateway/Tasky.Gateway.csproj
  bindings:
    - protocol: https
      port: 7500
- name: tasky-administrationservice-httpapi-host
  project: services/administration/host/Tasky.AdministrationService.HttpApi.Host/Tasky.AdministrationService.HttpApi.Host.csproj
  bindings:
    - protocol: https
      port: 7001
- name: tasky-identityservice-httpapi-host
  project: services/identity/host/Tasky.IdentityService.HttpApi.Host/Tasky.IdentityService.HttpApi.Host.csproj
  bindings:
    - protocol: https
      port: 7002
- name: tasky-saasservice-httpapi-host
  project: services/saas/host/Tasky.SaaSService.HttpApi.Host/Tasky.SaaSService.HttpApi.Host.csproj
  bindings:
    - protocol: https
      port: 7003
```

### Run Tye

```bash
tye run --watch
```

## Yarp

Yarp is our proxy server which will redirect the request to other services. So lets update the `Tasky.Gateway`.

### Install nuget

```xml
<PackageReference Include="Yarp.ReverseProxy" Version="1.0.0" />
```

### Update the Program.cs

```cs
var builder = WebApplication.CreateBuilder(args);
builder.Services.AddReverseProxy()
    .LoadFromConfig(builder.Configuration.GetSection("ReverseProxy"));
var app = builder.Build();
app.MapReverseProxy();
app.Run();
```

### Update appsettings.json

```json
{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning"
    }
  },
  "AllowedHosts": "*",
  "ReverseProxy": {
    "Routes": {
      "main": {
        "ClusterId": "main",
        "Match": {
          "Path": "{**catch-all}"
        }
      },
      "identity": {
        "ClusterId": "identity",
        "Match": {
          "Path": "/api/identity/{*any}"
        }
      },
      "account": {
        "ClusterId": "account",
        "Match": {
          "Path": "/api/account/{*any}"
        }
      },
      "saas": {
        "ClusterId": "saas",
        "Match": {
          "Path": "/api/multi-tenancy/{*any}"
        }
      }
    },
    "Clusters": {
      "main": {
        "Destinations": {
          "main": {
            "Address": "https://localhost:7001"
          }
        }
      },
      "identity": {
        "Destinations": {
          "identity": {
            "Address": "https://localhost:7002"
          }
        }
      },
      "account": {
        "Destinations": {
          "account": {
            "Address": "https://localhost:7002"
          }
        }
      },
      "saas": {
        "Destinations": {
          "saas": {
            "Address": "https://localhost:7003"
          }
        }
      }
    }
  }
}
```
]]></content:encoded>
          </item><item>
          <title>DbMigration</title>
          <link>https://blog.antosubash.com/posts/netcore-microservice-with-abp-db-migration-part-6</link>
          <guid>https://blog.antosubash.com/posts/netcore-microservice-with-abp-db-migration-part-6</guid>
          <pubDate>Sat, 19 Mar 2022 04:00:00 GMT</pubDate>
          <description>In this post we will see how to create migration project for our microservice application</description>
          <content:encoded><![CDATA[
This is sixth post of the series: [.NET Microservice with ABP](/posts/abp-microservice-series)

## Posts in the Series

[Part 1. Initial Setup](/posts/netcore-microservice-with-abp-init-part-1)

[Part 2. Shared Project](/posts/netcore-microservice-with-abp-shared-project-part-2)

[Part 3. Administration Service](/posts/netcore-microservice-with-abp-administration-services-part-3)

[Part 4. Identity Service](/posts/netcore-microservice-with-abp-identity-services-part-4)

[Part 5. SaaS Service](/posts/netcore-microservice-with-abp-saas-services-part-5)

Part 6. DB Migration (this post)

[Part 7. Yarp and Tye](/posts/netcore-microservice-with-abp-yarp-and-tye-part-7)

[Part 8. Identity server and Angular App](/posts/netcore-microservice-with-abp-identity-server-and-angular-part-8)

[Part 9. Distributed event bus](/posts/netcore-microservice-with-abp-distributed-event-bus-part-9)

[Part 10. Docker and CI/CD](/posts/netcore-microservice-with-abp-docker-and-ci-cd-part-10)

[Part 11. Add a New service](/posts/netcore-microservice-with-abp-add-new-service-part-11)

[Part 12. Central Logging](/posts/netcore-microservice-with-abp-add-central-logging-part-12)


## Table of contents

## Add the references

For migrations we need to first add contracts and EF core projects as a reference in the db migrator. We need to do this for all the services.

```xml
    <ItemGroup>
        <ProjectReference Include="..\..\services\AdministrationService\src\Tasky.AdministrationService.Application.Contracts\Tasky.AdministrationService.Application.Contracts.csproj"/>
        <ProjectReference Include="..\..\services\AdministrationService\src\Tasky.AdministrationService.EntityFrameworkCore\Tasky.AdministrationService.EntityFrameworkCore.csproj"/>
        <ProjectReference Include="..\..\services\identity\src\Tasky.IdentityService.Application.Contracts\Tasky.IdentityService.Application.Contracts.csproj"/>
        <ProjectReference Include="..\..\services\identity\src\Tasky.IdentityService.EntityFrameworkCore\Tasky.IdentityService.EntityFrameworkCore.csproj"/>
        <ProjectReference Include="..\..\services\SaaSService\src\Tasky.SaaSService.Application.Contracts\Tasky.SaaSService.Application.Contracts.csproj"/>
        <ProjectReference Include="..\..\services\SaaSService\src\Tasky.SaaSService.EntityFrameworkCore\Tasky.SaaSService.EntityFrameworkCore.csproj"/>
    </ItemGroup>
```

We are adding `EntityFrameworkCore` and `Contracts` projects to the DbMigrations project.

## Create `DbMigrationService`

Db migration service is where we can manage the migration and seeding of data of all the services in a single location.

```cs
using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;
using Tasky.AdministrationService.EntityFrameworkCore;
using Tasky.IdentityService.EntityFrameworkCore;
using Tasky.SaaSService.EntityFrameworkCore;
using Volo.Abp.Data;
using Volo.Abp.DependencyInjection;
using Volo.Abp.EntityFrameworkCore;
using Volo.Abp.Identity;
using Volo.Abp.MultiTenancy;
using Volo.Abp.TenantManagement;
using Volo.Abp.Uow;

namespace Tasky.DbMigrator;

public class TaskyDbMigrationService : ITransientDependency
{
    private readonly ICurrentTenant _currentTenant;
    private readonly IDataSeeder _dataSeeder;
    private readonly ILogger<TaskyDbMigrationService> _logger;
    private readonly ITenantRepository _tenantRepository;
    private readonly IUnitOfWorkManager _unitOfWorkManager;

    public TaskyDbMigrationService(
        ILogger<TaskyDbMigrationService> logger,
        ITenantRepository tenantRepository,
        IDataSeeder dataSeeder,
        ICurrentTenant currentTenant,
        IUnitOfWorkManager unitOfWorkManager)
    {
        _logger = logger;
        _tenantRepository = tenantRepository;
        _dataSeeder = dataSeeder;
        _currentTenant = currentTenant;
        _unitOfWorkManager = unitOfWorkManager;
    }

    public async Task MigrateAsync(CancellationToken cancellationToken)
    {
        await MigrateHostAsync(cancellationToken);
        await MigrateTenantsAsync(cancellationToken);
        _logger.LogInformation("Migration completed!");
    }

    private async Task MigrateHostAsync(CancellationToken cancellationToken)
    {
        _logger.LogInformation("Migrating Host side...");
        await MigrateAllDatabasesAsync(null, cancellationToken);
        await SeedDataAsync();
    }

    private async Task MigrateTenantsAsync(CancellationToken cancellationToken)
    {
        _logger.LogInformation("Migrating tenants...");

        var tenants =
            await _tenantRepository.GetListAsync(includeDetails: true, cancellationToken: cancellationToken);
        var migratedDatabaseSchemas = new HashSet<string>();
        foreach (var tenant in tenants)
        {
            using (_currentTenant.Change(tenant.Id))
            {
                // Database schema migration
                var connectionString = tenant.FindDefaultConnectionString();
                if (!connectionString.IsNullOrWhiteSpace() && //tenant has a separate database
                    !migratedDatabaseSchemas.Contains(connectionString)) //the database was not migrated yet
                {
                    _logger.LogInformation($"Migrating tenant database: {tenant.Name} ({tenant.Id})");
                    await MigrateAllDatabasesAsync(tenant.Id, cancellationToken);
                    migratedDatabaseSchemas.AddIfNotContains(connectionString);
                }

                //Seed data
                _logger.LogInformation($"Seeding tenant data: {tenant.Name} ({tenant.Id})");
                await SeedDataAsync();
            }
        }
    }

    private async Task MigrateAllDatabasesAsync(
        Guid? tenantId,
        CancellationToken cancellationToken)
    {
        using (var uow = _unitOfWorkManager.Begin(true))
        {
            if (tenantId == null)
            {
                /* SaaSService schema should only be available in the host side */
                await MigrateDatabaseAsync<SaaSServiceDbContext>(cancellationToken);
            }

            await MigrateDatabaseAsync<AdministrationServiceDbContext>(cancellationToken);
            await MigrateDatabaseAsync<IdentityServiceDbContext>(cancellationToken);

            await uow.CompleteAsync(cancellationToken);
        }

        _logger.LogInformation(
            $"All databases have been successfully migrated ({(tenantId.HasValue ? $"tenantId: {tenantId}" : "HOST")}).");
    }

    private async Task MigrateDatabaseAsync<TDbContext>(
        CancellationToken cancellationToken)
        where TDbContext : DbContext, IEfCoreDbContext
    {
        _logger.LogInformation($"Migrating {typeof(TDbContext).Name.RemovePostFix("DbContext")} database...");

        var dbContext = await _unitOfWorkManager.Current.ServiceProvider
            .GetRequiredService<IDbContextProvider<TDbContext>>()
            .GetDbContextAsync();

        await dbContext
            .Database
            .MigrateAsync(cancellationToken);
    }

    private async Task SeedDataAsync()
    {
        await _dataSeeder.SeedAsync(
            new DataSeedContext(_currentTenant.Id)
                .WithProperty(IdentityDataSeedContributor.AdminEmailPropertyName, "admin@abp.io")
                .WithProperty(IdentityDataSeedContributor.AdminPasswordPropertyName, "1q2w3E*")
        );
    }
}
```

## Update appsettings.json

The appsettings has a different structure form the normal structure you will usually see in the abp projects. We use this as a data source to seed the `ApiScope`, `ApiResource` and `Identity server clients`.

```json
{
  "ConnectionStrings": {
    "SaaSService": "User ID=postgres;Password=postgres;Host=localhost;Port=5432;Database=TaskySaaSService;Pooling=false;",
    "IdentityService": "User ID=postgres;Password=postgres;Host=localhost;Port=5432;Database=TaskyIdentityService;Pooling=false;",
    "AdministrationService": "User ID=postgres;Password=postgres;Host=localhost;Port=5432;Database=TaskyAdministrationService;Pooling=false;"
  },
  "ApiScope": [
    "AuthServer",
    "SaaSService",
    "IdentityService",
    "AdministrationService"
  ],
  "ApiResource": [
    "AuthServer",
    "SaaSService",
    "IdentityService",
    "AdministrationService"
  ],
  "Clients": [
    {
      "ClientId": "Tasky_Web",
      "ClientSecret": "1q2w3e*",
      "RootUrls": [
        "https://localhost:7004"
      ],
      "Scopes": [
        "SaaSService",
        "IdentityService",
        "AdministrationService"
      ],
      "GrantTypes": [
        "hybrid"
      ],
      "RedirectUris": [
        "https://localhost:7004/signin-oidc"
      ],
      "PostLogoutRedirectUris": [
        "https://localhost:7004/signout-callback-oidc"
      ],
      "AllowedCorsOrigins": [
        "https://localhost:7004"
      ]
    },
    {
      "ClientId": "Tasky_App",
      "ClientSecret": "1q2w3e*",
      "RootUrls": [
        "http://localhost:4200"
      ],
      "Scopes": [
        "AuthServer",
        "SaaSService",
        "IdentityService",
        "AdministrationService"
      ],
      "GrantTypes": [
        "authorization_code"
      ],
      "RedirectUris": [
        "http://localhost:4200"
      ],
      "PostLogoutRedirectUris": [
        "http://localhost:4200"
      ],
      "AllowedCorsOrigins": [
        "http://localhost:4200"
      ]
    },
    {
      "ClientId": "AdministrationService_Swagger",
      "ClientSecret": "1q2w3e*",
      "RootUrls": [
        "https://localhost:7001"
      ],
      "Scopes": [
        "SaaSService",
        "IdentityService",
        "AdministrationService"
      ],
      "GrantTypes": [
        "authorization_code"
      ],
      "RedirectUris": [
        "https://localhost:7001/swagger/oauth2-redirect.html"
      ],
      "PostLogoutRedirectUris": [
        "https://localhost:7001/signout-callback-oidc"
      ],
      "AllowedCorsOrigins": [
        "https://localhost:7001"
      ]
    },
    {
      "ClientId": "IdentityService_Swagger",
      "ClientSecret": "1q2w3e*",
      "RootUrls": [
        "https://localhost:7002"
      ],
      "Scopes": [
        "SaaSService",
        "IdentityService",
        "AdministrationService"
      ],
      "GrantTypes": [
        "authorization_code"
      ],
      "RedirectUris": [
        "https://localhost:7002/swagger/oauth2-redirect.html"
      ],
      "PostLogoutRedirectUris": [
        "https://localhost:7002"
      ],
      "AllowedCorsOrigins": [
        "https://localhost:7002"
      ]
    },
    {
      "ClientId": "SaaSService_Swagger",
      "ClientSecret": "1q2w3e*",
      "RootUrls": [
        "https://localhost:7003"
      ],
      "Scopes": [
        "SaaSService",
        "IdentityService",
        "AdministrationService"
      ],
      "GrantTypes": [
        "authorization_code"
      ],
      "RedirectUris": [
        "https://localhost:7003/swagger/oauth2-redirect.html"
      ],
      "PostLogoutRedirectUris": [
        "https://localhost:7003"
      ],
      "AllowedCorsOrigins": [
        "https://localhost:7003"
      ]
    }
  ]
}
```

## Create `IdentityServerDataSeedContributor` for identity server

```cs
using System.Threading.Tasks;
using Volo.Abp.Data;
using Volo.Abp.DependencyInjection;

namespace Tasky.DbMigrator;

public class IdentityServerDataSeedContributor : IDataSeedContributor, ITransientDependency
{
    private readonly IdentityServerDataSeeder _identityServerDataSeeder;

    public IdentityServerDataSeedContributor(IdentityServerDataSeeder identityServerDataSeeder)
    {
        _identityServerDataSeeder = identityServerDataSeeder;
    }


    public async Task SeedAsync(DataSeedContext context)
    {
        await _identityServerDataSeeder.SeedAsync();
    }
}
```

## Create `IdentityServerDataSeeder` for reading json and create resource

This service seeds the `ApiScope`, `ApiResource` and `Identity server clients` for the Identity server.

`ServiceClient` is a class to parse the Identity server clients

```cs
public class ServiceClient
{
    public string ClientId { get; set; }
    public string ClientSecret { get; set; }
    public string[] RootUrls { get; set; }
    public string[] Scopes { get; set; }
    public string[] GrantTypes { get; set; }
    public string[] RedirectUris { get; set; }
    public string[] PostLogoutRedirectUris { get; set; }
    public string[] AllowedCorsOrigins { get; set; }
}
```

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using IdentityServer4.Models;
using Microsoft.Extensions.Configuration;
using Volo.Abp.Authorization.Permissions;
using Volo.Abp.DependencyInjection;
using Volo.Abp.Guids;
using Volo.Abp.IdentityServer.ApiResources;
using Volo.Abp.IdentityServer.ApiScopes;
using Volo.Abp.IdentityServer.Clients;
using Volo.Abp.IdentityServer.IdentityResources;
using Volo.Abp.MultiTenancy;
using Volo.Abp.PermissionManagement;
using Volo.Abp.Uow;
using ApiResource = Volo.Abp.IdentityServer.ApiResources.ApiResource;
using ApiScope = Volo.Abp.IdentityServer.ApiScopes.ApiScope;
using Client = Volo.Abp.IdentityServer.Clients.Client;

namespace Tasky.DbMigrator;

public class IdentityServerDataSeeder : ITransientDependency
{
    private readonly IApiResourceRepository _apiResourceRepository;
    private readonly IApiScopeRepository _apiScopeRepository;
    private readonly IClientRepository _clientRepository;
    private readonly IConfiguration _configuration;
    private readonly ICurrentTenant _currentTenant;
    private readonly IGuidGenerator _guidGenerator;
    private readonly IIdentityResourceDataSeeder _identityResourceDataSeeder;
    private readonly IPermissionDataSeeder _permissionDataSeeder;

    public IdentityServerDataSeeder(
        IClientRepository clientRepository,
        IApiResourceRepository apiResourceRepository,
        IApiScopeRepository apiScopeRepository,
        IIdentityResourceDataSeeder identityResourceDataSeeder,
        IGuidGenerator guidGenerator,
        IPermissionDataSeeder permissionDataSeeder,
        IConfiguration configuration,
        ICurrentTenant currentTenant)
    {
        _clientRepository = clientRepository;
        _apiResourceRepository = apiResourceRepository;
        _apiScopeRepository = apiScopeRepository;
        _identityResourceDataSeeder = identityResourceDataSeeder;
        _guidGenerator = guidGenerator;
        _permissionDataSeeder = permissionDataSeeder;
        _configuration = configuration;
        _currentTenant = currentTenant;
    }

    [UnitOfWork]
    public async virtual Task SeedAsync()
    {
        using (_currentTenant.Change(null))
        {
            await _identityResourceDataSeeder.CreateStandardResourcesAsync();
            await CreateApiResourcesAsync();
            await CreateApiScopesAsync();
            await CreateClientsAsync();
        }
    }

    private async Task CreateClientsAsync()
    {
        var clients = _configuration.GetSection("Clients").Get<List<ServiceClient>>();
        var commonScopes = new[] {
            "email",
            "openid",
            "profile",
            "role",
            "phone",
            "address"
        };

        foreach (var client in clients)
        {
            await CreateClientAsync(
                client.ClientId,
                commonScopes.Union(client.Scopes),
                client.GrantTypes,
                client.ClientSecret.Sha256(),
                requireClientSecret: false,
                redirectUris: client.RedirectUris,
                postLogoutRedirectUris: client.PostLogoutRedirectUris,
                corsOrigins: client.AllowedCorsOrigins
            );
        }
    }


    private async Task CreateApiResourcesAsync()
    {
        var commonApiUserClaims = new[] {
            "email",
            "email_verified",
            "name",
            "phone_number",
            "phone_number_verified",
            "role"
        };

        var apiResources = _configuration.GetSection("ApiResource").Get<string[]>();

        foreach (var item in apiResources)
        {
            await CreateApiResourceAsync(item, commonApiUserClaims);
        }
    }

    private async Task CreateApiScopesAsync()
    {
        var apiScopes = _configuration.GetSection("ApiScope").Get<string[]>();
        foreach (var item in apiScopes)
        {
            await CreateApiScopeAsync(item);
        }
    }

    private async Task<ApiResource> CreateApiResourceAsync(string name, IEnumerable<string> claims)
    {
        var apiResource = await _apiResourceRepository.FindByNameAsync(name);
        if (apiResource == null)
        {
            apiResource = await _apiResourceRepository.InsertAsync(
                new ApiResource(
                    _guidGenerator.Create(),
                    name,
                    name + " API"
                ),
                true
            );
        }

        foreach (var claim in claims)
        {
            if (apiResource.FindClaim(claim) == null)
            {
                apiResource.AddUserClaim(claim);
            }
        }

        return await _apiResourceRepository.UpdateAsync(apiResource);
    }

    private async Task<ApiScope> CreateApiScopeAsync(string name)
    {
        var apiScope = await _apiScopeRepository.FindByNameAsync(name);
        if (apiScope == null)
        {
            apiScope = await _apiScopeRepository.InsertAsync(
                new ApiScope(
                    _guidGenerator.Create(),
                    name,
                    name + " API"
                ),
                true
            );
        }

        return apiScope;
    }

    private async Task<Client> CreateClientAsync(
        string name,
        IEnumerable<string> scopes,
        IEnumerable<string> grantTypes,
        string secret = null,
        IEnumerable<string> redirectUris = null,
        IEnumerable<string> postLogoutRedirectUris = null,
        string frontChannelLogoutUri = null,
        bool requireClientSecret = true,
        bool requirePkce = false,
        IEnumerable<string> permissions = null,
        IEnumerable<string> corsOrigins = null)
    {
        var client = await _clientRepository.FindByClientIdAsync(name);
        if (client == null)
        {
            client = await _clientRepository.InsertAsync(
                new Client(
                    _guidGenerator.Create(),
                    name
                ) {
                    ClientName = name,
                    ProtocolType = "oidc",
                    Description = name,
                    AlwaysIncludeUserClaimsInIdToken = true,
                    AllowOfflineAccess = true,
                    AbsoluteRefreshTokenLifetime = 31536000, //365 days
                    AccessTokenLifetime = 31536000, //365 days
                    AuthorizationCodeLifetime = 300,
                    IdentityTokenLifetime = 300,
                    RequireConsent = false,
                    FrontChannelLogoutUri = frontChannelLogoutUri,
                    RequireClientSecret = requireClientSecret,
                    RequirePkce = requirePkce
                },
                true
            );
        }

        foreach (var scope in scopes)
        {
            if (client.FindScope(scope) == null)
            {
                client.AddScope(scope);
            }
        }

        foreach (var grantType in grantTypes)
        {
            if (client.FindGrantType(grantType) == null)
            {
                client.AddGrantType(grantType);
            }
        }

        if (!secret.IsNullOrEmpty())
        {
            if (client.FindSecret(secret) == null)
            {
                client.AddSecret(secret);
            }
        }

        foreach (var redirectUrl in redirectUris)
        {
            if (client.FindRedirectUri(redirectUrl) == null)
            {
                client.AddRedirectUri(redirectUrl);
            }
        }

        foreach (var postLogoutRedirectUri in postLogoutRedirectUris)
        {
            if (client.FindPostLogoutRedirectUri(postLogoutRedirectUri) == null)
            {
                client.AddPostLogoutRedirectUri(postLogoutRedirectUri);
            }
        }

        if (permissions != null)
        {
            await _permissionDataSeeder.SeedAsync(
                ClientPermissionValueProvider.ProviderName,
                name,
                permissions
            );
        }

        if (corsOrigins != null)
        {
            foreach (var origin in corsOrigins)
            {
                if (!origin.IsNullOrWhiteSpace() && client.FindCorsOrigin(origin) == null)
                {
                    client.AddCorsOrigin(origin);
                }
            }
        }

        return await _clientRepository.UpdateAsync(client);
    }
}
```

## Update the `TaskyDbMigratorModule`

```cs
typeof(AdministrationServiceEntityFrameworkCoreModule),
typeof(AdministrationServiceApplicationContractsModule),
typeof(IdentityServiceEntityFrameworkCoreModule),
typeof(IdentityServiceApplicationContractsModule),
typeof(SaaSServiceEntityFrameworkCoreModule),
typeof(SaaSServiceApplicationContractsModule)
```

Repo: <https://github.com/antosubash/AbpMicroservice>
]]></content:encoded>
          </item><item>
          <title>SaaS Services</title>
          <link>https://blog.antosubash.com/posts/netcore-microservice-with-abp-saas-services-part-5</link>
          <guid>https://blog.antosubash.com/posts/netcore-microservice-with-abp-saas-services-part-5</guid>
          <pubDate>Sat, 19 Mar 2022 03:00:00 GMT</pubDate>
          <description>In this post we will see how to do the create SaaS Service for our microservice application</description>
          <content:encoded><![CDATA[
This is fifth post of the series: [.NET Microservice with ABP](/posts/abp-microservice-series)

## Posts in the Series

[Part 1. Initial Setup](/posts/netcore-microservice-with-abp-init-part-1)

[Part 2. Shared Project](/posts/netcore-microservice-with-abp-shared-project-part-2)

[Part 3. Administration Service](/posts/netcore-microservice-with-abp-administration-services-part-3)

[Part 4. Identity Service](/posts/netcore-microservice-with-abp-identity-services-part-4)

Part 5. SaaS Service (this post)

[Part 6. DB Migration](/posts/netcore-microservice-with-abp-db-migration-part-6)

[Part 7. Yarp and Tye](/posts/netcore-microservice-with-abp-yarp-and-tye-part-7)

[Part 8. Identity server and Angular App](/posts/netcore-microservice-with-abp-identity-server-and-angular-part-8)

[Part 9. Distributed event bus](/posts/netcore-microservice-with-abp-distributed-event-bus-part-9)

[Part 10. Docker and CI/CD](/posts/netcore-microservice-with-abp-docker-and-ci-cd-part-10)

[Part 11. Add a New service](/posts/netcore-microservice-with-abp-add-new-service-part-11)

[Part 12. Central Logging](/posts/netcore-microservice-with-abp-add-central-logging-part-12)


## Table of contents

## Intro

In this post we will see how to setup SaaS service. we only have tenant management module in this service.

## Add the shared project as a reference to the host

```xml
<ProjectReference Include="..\..\..\..\shared\Tasky.Shared.Hosting\Tasky.Shared.Hosting.csproj" />
```

## Update the connection string

`User ID=postgres;Password=postgres;Host=localhost;Port=5432;Database=TaskySaaSService;Pooling=false;`

## Update the `SaaSServiceHttpApiHostModule`

Update the depends on.

```cs
[DependsOn(
    typeof(TaskyHostingModule),
    typeof(SaaSServiceApplicationModule),
    typeof(SaaSServiceEntityFrameworkCoreModule),
    typeof(SaaSServiceHttpApiModule),
)]
```

Remove the things which are configured in the shared project.

## Create the `DbContextFactory` in the EntityFrameworkCore project

```cs
using System.IO;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Design;
using Microsoft.Extensions.Configuration;

namespace Tasky.SaaSService.EntityFrameworkCore;

public class SaaSServiceDbContextFactory : IDesignTimeDbContextFactory<SaaSServiceDbContext>
{
    public SaaSServiceDbContext CreateDbContext(string[] args)
    {
        var builder = new DbContextOptionsBuilder<SaaSServiceDbContext>()
            .UseNpgsql(GetConnectionStringFromConfiguration());

        return new SaaSServiceDbContext(builder.Options);
    }

    private static string GetConnectionStringFromConfiguration()
    {
        return BuildConfiguration()
            .GetConnectionString(SaaSServiceDbProperties.ConnectionStringName);
    }

    private static IConfigurationRoot BuildConfiguration()
    {
        var builder = new ConfigurationBuilder()
            .SetBasePath(
                Path.Combine(
                    Directory.GetParent(Directory.GetCurrentDirectory())?.Parent!.FullName!,
                    $"host{Path.DirectorySeparatorChar}Tasky.SaaSService.HttpApi.Host"
                )
            )
            .AddJsonFile("appsettings.json", false);

        return builder.Build();
    }
}
```

## Update the `Tasky.SaaSService.EntityFrameworkCore`

Update the nuget packages

```xml
<PackageReference Include="Volo.Abp.EntityFrameworkCore" Version="5.1.4"/>
<PackageReference Include="Volo.Abp.EntityFrameworkCore.PostgreSql" Version="5.1.4"/>
<PackageReference Include="Microsoft.EntityFrameworkCore.Tools" Version="6.0.1"/>
```

Update the `SaaSServiceDbContext`

```cs
using Microsoft.EntityFrameworkCore;
using Volo.Abp.Data;
using Volo.Abp.EntityFrameworkCore;
using Volo.Abp.TenantManagement;
using Volo.Abp.TenantManagement.EntityFrameworkCore;

namespace Tasky.SaaSService.EntityFrameworkCore;

[ConnectionStringName(SaaSServiceDbProperties.ConnectionStringName)]
public class SaaSServiceDbContext : AbpDbContext<SaaSServiceDbContext>, ITenantManagementDbContext, ISaaSServiceDbContext
{
    public SaaSServiceDbContext(DbContextOptions<SaaSDbContext> options)
        : base(options)
    {
    }

    public DbSet<Tenant> Tenants { get; set; }

    public DbSet<TenantConnectionString> TenantConnectionStrings { get; set; }

    protected override void OnModelCreating(ModelBuilder builder)
    {
        base.OnModelCreating(builder);

        builder.ConfigureSaaSService();
        builder.ConfigureTenantManagement();
    }
}
```

Update the `SaaSServiceEntityFrameworkCoreModule`

```cs
using System;
using Microsoft.Extensions.DependencyInjection;
using Volo.Abp.EntityFrameworkCore;
using Volo.Abp.Modularity;
using Volo.Abp.TenantManagement.EntityFrameworkCore;

namespace Tasky.SaaSService.EntityFrameworkCore;

[DependsOn(
    typeof(SaaSServiceDomainModule),
    typeof(AbpTenantManagementEntityFrameworkCoreModule),
    typeof(AbpEntityFrameworkCoreModule),
    typeof(AbpEntityFrameworkCorePostgreSqlModule)
)]
public class SaaSServiceEntityFrameworkCoreModule : AbpModule
{
    public override void ConfigureServices(ServiceConfigurationContext context)
    {
        Configure<AbpDbContextOptions>(options =>
        {
            options.UseNpgsql();
        });

        AppContext.SetSwitch("Npgsql.EnableLegacyTimestampBehavior", true);

        context.Services.AddAbpDbContext<SaaSDbContext>(options =>
        {
            options.ReplaceDbContext<ITenantManagementDbContext>();
            options.AddDefaultRepositories(true);
        });
    }
}
```

Once this is created delete `EntityFrameworkCore` folder can be created.

## Migration

To create migrations

`dotnet ef migrations add Init`

To update database

`dotnet ef database update`

Repo: <https://github.com/antosubash/AbpMicroservice>
]]></content:encoded>
          </item><item>
          <title>Identity Services</title>
          <link>https://blog.antosubash.com/posts/netcore-microservice-with-abp-identity-services-part-4</link>
          <guid>https://blog.antosubash.com/posts/netcore-microservice-with-abp-identity-services-part-4</guid>
          <pubDate>Sat, 19 Mar 2022 02:00:00 GMT</pubDate>
          <description>In this post we will see how to do the create Identity service for our microservice application</description>
          <content:encoded><![CDATA[
This is forth post of the series: [.NET Microservice with ABP](/posts/abp-microservice-series)

## Posts in the Series

[Part 1. Initial Setup](/posts/netcore-microservice-with-abp-init-part-1)

[Part 2. Shared Project](/posts/netcore-microservice-with-abp-shared-project-part-2)

[Part 3. Administration Service](/posts/netcore-microservice-with-abp-administration-services-part-3)

Part 4. Identity Service (this post)

[Part 5. SaaS Service](/posts/netcore-microservice-with-abp-saas-services-part-5)

[Part 6. DB Migration](/posts/netcore-microservice-with-abp-db-migration-part-6)

[Part 7. Yarp and Tye](/posts/netcore-microservice-with-abp-yarp-and-tye-part-7)

[Part 8. Identity server and Angular App](/posts/netcore-microservice-with-abp-identity-server-and-angular-part-8)

[Part 9. Distributed event bus](/posts/netcore-microservice-with-abp-distributed-event-bus-part-9)

[Part 10. Docker and CI/CD](/posts/netcore-microservice-with-abp-docker-and-ci-cd-part-10)

[Part 11. Add a New service](/posts/netcore-microservice-with-abp-add-new-service-part-11)

[Part 12. Central Logging](/posts/netcore-microservice-with-abp-add-central-logging-part-12)


## Table of contents

## Intro

In this post we will see how to configure Identity Service. In the identity service we have already add 2 modules Identity and IdentityServer. we need to configure the Identity service to use these modules.

## Add the shared project as a reference to the host

We need to do the same thing we did in the admin service. Add the shared project as a reference and clean up host module.

```xml
<ProjectReference Include="..\..\..\..\shared\Tasky.Shared.Hosting\Tasky.Shared.Hosting.csproj" />
```

## Update the connection string

`User ID=postgres;Password=postgres;Host=localhost;Port=5432;Database=TaskyIdentityService;Pooling=false;`

## Update the `IdentityServiceHttpApiHostModule`

Update the depends on with the shared hosting module.

```cs
[DependsOn(
    typeof(TaskyHostingModule),
    typeof(IdentityServiceApplicationModule),
    typeof(IdentityServiceEntityFrameworkCoreModule),
    typeof(IdentityServiceHttpApiModule),
)]
```

Remove the things which are configured in the shared project.

## Create the `DbContextFactory` in the EntityFrameworkCore project

```cs
using System.IO;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Design;
using Microsoft.Extensions.Configuration;

namespace Tasky.IdentityService.EntityFrameworkCore;

public class IdentityServiceDbContextFactory : IDesignTimeDbContextFactory<IdentityServiceDbContext>
{
    public IdentityServiceDbContext CreateDbContext(string[] args)
    {
        var builder = new DbContextOptionsBuilder<IdentityServiceDbContext>()
            .UseNpgsql(GetConnectionStringFromConfiguration());

        return new IdentityServiceDbContext(builder.Options);
    }

    private static string GetConnectionStringFromConfiguration()
    {
        return BuildConfiguration()
            .GetConnectionString(IdentityServiceDbProperties.ConnectionStringName);
    }

    private static IConfigurationRoot BuildConfiguration()
    {
        var builder = new ConfigurationBuilder()
            .SetBasePath(
                Path.Combine(
                    Directory.GetParent(Directory.GetCurrentDirectory())?.Parent!.FullName!,
                    $"host{Path.DirectorySeparatorChar}Tasky.IdentityService.HttpApi.Host"
                )
            )
            .AddJsonFile("appsettings.json", false);

        return builder.Build();
    }
}
```

## Update the `IdentityServiceDbContext`

```cs
using Microsoft.EntityFrameworkCore;
using Volo.Abp.Data;
using Volo.Abp.EntityFrameworkCore;
using Volo.Abp.Identity;
using Volo.Abp.Identity.EntityFrameworkCore;
using Volo.Abp.IdentityServer.ApiResources;
using Volo.Abp.IdentityServer.ApiScopes;
using Volo.Abp.IdentityServer.Clients;
using Volo.Abp.IdentityServer.Devices;
using Volo.Abp.IdentityServer.EntityFrameworkCore;
using Volo.Abp.IdentityServer.Grants;
using Volo.Abp.IdentityServer.IdentityResources;

namespace Tasky.IdentityService.EntityFrameworkCore;

[ConnectionStringName(IdentityServiceDbProperties.ConnectionStringName)]
public class IdentityServiceDbContext : AbpDbContext<IdentityServiceDbContext>, IIdentityDbContext,
    IIdentityServerDbContext, IIdentityServiceDbContext
{
    public IdentityServiceDbContext(DbContextOptions<IdentityServiceDbContext> options)
        : base(options)
    {
    }

    public DbSet<IdentityUser> Users { get; set; }
    public DbSet<IdentityRole> Roles { get; set; }
    public DbSet<IdentityClaimType> ClaimTypes { get; set; }
    public DbSet<OrganizationUnit> OrganizationUnits { get; set; }
    public DbSet<IdentitySecurityLog> SecurityLogs { get; set; }
    public DbSet<IdentityLinkUser> LinkUsers { get; set; }
    public DbSet<ApiResource> ApiResources { get; set; }
    public DbSet<ApiResourceSecret> ApiResourceSecrets { get; set; }
    public DbSet<ApiResourceClaim> ApiResourceClaims { get; set; }
    public DbSet<ApiResourceScope> ApiResourceScopes { get; set; }
    public DbSet<ApiResourceProperty> ApiResourceProperties { get; set; }
    public DbSet<ApiScope> ApiScopes { get; set; }
    public DbSet<ApiScopeClaim> ApiScopeClaims { get; set; }
    public DbSet<ApiScopeProperty> ApiScopeProperties { get; set; }
    public DbSet<IdentityResource> IdentityResources { get; set; }
    public DbSet<IdentityResourceClaim> IdentityClaims { get; set; }
    public DbSet<IdentityResourceProperty> IdentityResourceProperties { get; set; }
    public DbSet<Client> Clients { get; set; }
    public DbSet<ClientGrantType> ClientGrantTypes { get; set; }
    public DbSet<ClientRedirectUri> ClientRedirectUris { get; set; }
    public DbSet<ClientPostLogoutRedirectUri> ClientPostLogoutRedirectUris { get; set; }
    public DbSet<ClientScope> ClientScopes { get; set; }
    public DbSet<ClientSecret> ClientSecrets { get; set; }
    public DbSet<ClientClaim> ClientClaims { get; set; }
    public DbSet<ClientIdPRestriction> ClientIdPRestrictions { get; set; }
    public DbSet<ClientCorsOrigin> ClientCorsOrigins { get; set; }
    public DbSet<ClientProperty> ClientProperties { get; set; }
    public DbSet<PersistedGrant> PersistedGrants { get; set; }
    public DbSet<DeviceFlowCodes> DeviceFlowCodes { get; set; }

    protected override void OnModelCreating(ModelBuilder builder)
    {
        base.OnModelCreating(builder);

        builder.ConfigureIdentityService();
        builder.ConfigureIdentity();
        builder.ConfigureIdentityServer();
    }
}
```

## Update the `Tasky.IdentityService.EntityFrameworkCore` project

Update the nuget packages with ef core packages. we will replace the module db context and configure the DbContext options in this module.

```xml
<PackageReference Include="Volo.Abp.EntityFrameworkCore" Version="5.1.4"/>
<PackageReference Include="Volo.Abp.EntityFrameworkCore.PostgreSql" Version="5.1.4"/>
<PackageReference Include="Microsoft.EntityFrameworkCore.Tools" Version="6.0.1"/>
```

Update the `IdentityServiceEntityFrameworkCoreModule` file.

```cs
using System;
using Microsoft.Extensions.DependencyInjection;
using Volo.Abp.EntityFrameworkCore;
using Volo.Abp.Identity.EntityFrameworkCore;
using Volo.Abp.IdentityServer.EntityFrameworkCore;
using Volo.Abp.Modularity;

namespace Tasky.IdentityService.EntityFrameworkCore;

[DependsOn(
    typeof(IdentityServiceDomainModule),
    typeof(AbpEntityFrameworkCoreModule),
    typeof(AbpIdentityEntityFrameworkCoreModule),
    typeof(AbpIdentityServerEntityFrameworkCoreModule)
)]
public class IdentityServiceEntityFrameworkCoreModule : AbpModule
{
    public override void ConfigureServices(ServiceConfigurationContext context)
    {
        Configure<AbpDbContextOptions>(options =>
        {
            options.UseNpgsql();
        });
        AppContext.SetSwitch("Npgsql.EnableLegacyTimestampBehavior", true);
        context.Services.AddAbpDbContext<IdentityServiceDbContext>(options =>
        {
            options.ReplaceDbContext<IIdentityDbContext>();
            options.ReplaceDbContext<IIdentityServerDbContext>();

            options.AddDefaultRepositories(true);
        });
    }
}
```

Once this is created delete `EntityFrameworkCore` folder can be created.

## Migration

To create migrations

`dotnet ef migrations add Init`

To update database

`dotnet ef database update`

Repo: <https://github.com/antosubash/AbpMicroservice>
]]></content:encoded>
          </item><item>
          <title>Administration Services</title>
          <link>https://blog.antosubash.com/posts/netcore-microservice-with-abp-administration-services-part-3</link>
          <guid>https://blog.antosubash.com/posts/netcore-microservice-with-abp-administration-services-part-3</guid>
          <pubDate>Sat, 19 Mar 2022 01:00:00 GMT</pubDate>
          <description>In this post we will see how to do the create Administration service for our microservice application</description>
          <content:encoded><![CDATA[
This is third post of the series: [.NET Microservice with ABP](/posts/abp-microservice-series)

## Posts in the Series

[Part 1. Initial Setup](/posts/netcore-microservice-with-abp-init-part-1)

[Part 2. Shared Project](/posts/netcore-microservice-with-abp-shared-project-part-2)

Part 3. Administration Service (this post)

[Part 4. Identity Service](/posts/netcore-microservice-with-abp-identity-services-part-4)

[Part 5. SaaS Service](/posts/netcore-microservice-with-abp-saas-services-part-5)

[Part 6. DB Migration](/posts/netcore-microservice-with-abp-db-migration-part-6)

[Part 7. Yarp and Tye](/posts/netcore-microservice-with-abp-yarp-and-tye-part-7)

[Part 8. Identity server and Angular App](/posts/netcore-microservice-with-abp-identity-server-and-angular-part-8)

[Part 9. Distributed event bus](/posts/netcore-microservice-with-abp-distributed-event-bus-part-9)

[Part 10. Docker and CI/CD](/posts/netcore-microservice-with-abp-docker-and-ci-cd-part-10)

[Part 11. Add a New service](/posts/netcore-microservice-with-abp-add-new-service-part-11)

[Part 12. Central Logging](/posts/netcore-microservice-with-abp-add-central-logging-part-12)


## Table of contents

## Setup Administration service

Adminstration service is where we uses Audit log, feature, settings and permission management modules. We will use a separate database to store everything in the administration service.

## Add the shared project as a reference to the host

We need to add shared project as the reference to the Administration service. once this is added we can do some cleanup in the host module of the administration.

```xml
<ProjectReference Include="..\..\..\..\shared\Tasky.Shared.Hosting\Tasky.Shared.Hosting.csproj" />
```

## Update the connection string

`User ID=postgres;Password=postgres;Host=localhost;Port=5432;Database=AdministrationService;Pooling=false;`

## Update the `AdministrationServiceHttpApiHostModule`

Update the depends on with the shared module. Once the shared module is added then we can removed most of the modules in the host module. Below is how the final depends on looks like.

```cs
[DependsOn(
    typeof(TaskyHostingModule),
    typeof(AdministrationServiceApplicationModule),
    typeof(AdministrationServiceEntityFrameworkCoreModule),
    typeof(AdministrationServiceHttpApiModule),
)]
```

Remove the things which are configured in the shared project.

## Create the `DbContextFactory` in the EntityFrameworkCore project

We need to create a `Factory` class for the `DbContext` so that we can create migration in the `EfCore` project. this is necessary to build the configuration form the host project.

```cs
using System.IO;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Design;
using Microsoft.Extensions.Configuration;

namespace Tasky.AdministrationService.EntityFrameworkCore;

public class AdministrationServiceDbContextFactory : IDesignTimeDbContextFactory<AdministrationServiceDbContext>
{
    public AdministrationServiceDbContext CreateDbContext(string[] args)
    {
        var builder = new DbContextOptionsBuilder<AdministrationServiceDbContext>()
            .UseNpgsql(GetConnectionStringFromConfiguration());

        return new AdministrationServiceDbContext(builder.Options);
    }

    private static string GetConnectionStringFromConfiguration()
    {
        return BuildConfiguration()
            .GetConnectionString(AdministrationServiceDbProperties.ConnectionStringName);
    }

    private static IConfigurationRoot BuildConfiguration()
    {
        var builder = new ConfigurationBuilder()
            .SetBasePath(
                Path.Combine(
                    Directory.GetParent(Directory.GetCurrentDirectory())?.Parent!.FullName!,
                    $"host{Path.DirectorySeparatorChar}Tasky.AdministrationService.HttpApi.Host"
                )
            )
            .AddJsonFile("appsettings.json", false);

        return builder.Build();
    }
}
```

## Update the `AdministrationServiceDbContext`

In the `DbContext` we need to updated it with the DbContext of the modules. We have added 4 modules in the administration service and all modules have a db context. So we have to inherit from the db context of the modules. this is add the `DBSet` of the modules to the administration module.

```cs
using Microsoft.EntityFrameworkCore;
using Volo.Abp.Data;
using Volo.Abp.EntityFrameworkCore;
using Volo.Abp.AuditLogging.EntityFrameworkCore;
using Volo.Abp.FeatureManagement.EntityFrameworkCore;
using Volo.Abp.PermissionManagement.EntityFrameworkCore;
using Volo.Abp.SettingManagement.EntityFrameworkCore;
using Volo.Abp.AuditLogging;
using Volo.Abp.FeatureManagement;
using Volo.Abp.PermissionManagement;
using Volo.Abp.SettingManagement;

namespace Tasky.AdministrationService.EntityFrameworkCore;

[ConnectionStringName(AdministrationServiceDbProperties.ConnectionStringName)]
public class AdministrationServiceDbContext : AbpDbContext<AdministrationServiceDbContext>,
    IPermissionManagementDbContext,
    ISettingManagementDbContext,
    IFeatureManagementDbContext,
    IAuditLoggingDbContext,
    IAdministrationServiceDbContext
{
    /* Add DbSet for each Aggregate Root here. Example:
     * public DbSet<Question> Questions { get; set; }
     */

    public AdministrationServiceDbContext(DbContextOptions<AdministrationServiceDbContext> options)
        : base(options)
    {
    }

    public DbSet<AuditLog> AuditLogs { get; set; }
    public DbSet<FeatureValue> FeatureValues { get; set; }
    public DbSet<PermissionGrant> PermissionGrants { get; set; }
    public DbSet<Setting> Settings { get; set; }

    protected override void OnModelCreating(ModelBuilder builder)
    {
        base.OnModelCreating(builder);

        builder.ConfigureAdministrationService();
        builder.ConfigurePermissionManagement();
        builder.ConfigureSettingManagement();
        builder.ConfigureAuditLogging();
        builder.ConfigureFeatureManagement();
    }
}
```

## Update the `AdministrationServiceEntityFrameworkCoreModule`

This is the final setup before creating the migration. we have to inform the ef core that we are using `postgres` as database. we can do that configuring `AbpDbContextOptions` and replace the db context of the modules with the administration db context.

```cs
using Microsoft.Extensions.DependencyInjection;
using Volo.Abp.EntityFrameworkCore;
using Volo.Abp.Modularity;
using Volo.Abp.AuditLogging.EntityFrameworkCore;
using Volo.Abp.FeatureManagement.EntityFrameworkCore;
using Volo.Abp.PermissionManagement.EntityFrameworkCore;
using Volo.Abp.SettingManagement.EntityFrameworkCore;
using System;

namespace Tasky.AdministrationService.EntityFrameworkCore;

[DependsOn(
    typeof(AdministrationServiceDomainModule),
    typeof(AbpEntityFrameworkCoreModule)
)]
[DependsOn(typeof(AbpAuditLoggingEntityFrameworkCoreModule))]
[DependsOn(typeof(AbpFeatureManagementEntityFrameworkCoreModule))]
[DependsOn(typeof(AbpPermissionManagementEntityFrameworkCoreModule))]
[DependsOn(typeof(AbpSettingManagementEntityFrameworkCoreModule))]
public class AdministrationServiceEntityFrameworkCoreModule : AbpModule
{
    public override void ConfigureServices(ServiceConfigurationContext context)
    {
        Configure<AbpDbContextOptions>(options =>
        {
            options.UseNpgsql();
        });
        
        AppContext.SetSwitch("Npgsql.EnableLegacyTimestampBehavior", true);
        context.Services.AddAbpDbContext<AdministrationServiceDbContext>(options =>
        {
            options.ReplaceDbContext<IPermissionManagementDbContext>();
            options.ReplaceDbContext<ISettingManagementDbContext>();
            options.ReplaceDbContext<IFeatureManagementDbContext>();
            options.ReplaceDbContext<IAuditLoggingDbContext>();

            options.AddDefaultRepositories(true);
        });
    }
}
```

## Prepare for the migration

Add the ef core design nuget for the migrations.

```xml
<PackageReference Include="Microsoft.EntityFrameworkCore.Design" Version="6.0.1">
    <PrivateAssets>all</PrivateAssets>
    <IncludeAssets>runtime; build; native; contentfiles; analyzers</IncludeAssets>
</PackageReference>
```

Once this is created delete `EntityFrameworkCore` folder can be created from the host project.

## Migration

To create migrations

`dotnet ef migrations add Init`

To update database

`dotnet ef database update`

Repo: <https://github.com/antosubash/AbpMicroservice>
]]></content:encoded>
          </item><item>
          <title>Shared Project</title>
          <link>https://blog.antosubash.com/posts/netcore-microservice-with-abp-shared-project-part-2</link>
          <guid>https://blog.antosubash.com/posts/netcore-microservice-with-abp-shared-project-part-2</guid>
          <pubDate>Sat, 19 Mar 2022 00:00:00 GMT</pubDate>
          <description>In this post we will see how to do the create a Shared project which will be used by all services</description>
          <content:encoded><![CDATA[
This is second post of the series: [.NET Microservice with ABP](/posts/abp-microservice-series)

## Posts in the Series

[Part 1. Initial Setup](/posts/netcore-microservice-with-abp-init-part-1)

Part 2. Shared Project (this post)

[Part 3. Administration Service](/posts/netcore-microservice-with-abp-administration-services-part-3)

[Part 4. Identity Service](/posts/netcore-microservice-with-abp-identity-services-part-4)

[Part 5. SaaS Service](/posts/netcore-microservice-with-abp-saas-services-part-5)

[Part 6. DB Migration](/posts/netcore-microservice-with-abp-db-migration-part-6)

[Part 7. Yarp and Tye](/posts/netcore-microservice-with-abp-yarp-and-tye-part-7)

[Part 8. Identity server and Angular App](/posts/netcore-microservice-with-abp-identity-server-and-angular-part-8)

[Part 9. Distributed event bus](/posts/netcore-microservice-with-abp-distributed-event-bus-part-9)

[Part 10. Docker and CI/CD](/posts/netcore-microservice-with-abp-docker-and-ci-cd-part-10)

[Part 11. Add a New service](/posts/netcore-microservice-with-abp-add-new-service-part-11)

[Part 12. Central Logging](/posts/netcore-microservice-with-abp-add-central-logging-part-12)

## Table of contents

## Setup Shared project

We need the shared project so that we can share some start up code. This part is not necessary but it is good to have and shared module which will we can reuse.

## Install nuget

The setup script in the part 1 of this series has created a empty class library project called `Tasky.Shared.Hosting`. we will add the following nuget packages to that project. These nuget packages are essential for all the microservice we are going to create. So we will install these in a shared project and add this shared project as a reference in all the services. This will we can save some time.

```xml
<PackageReference Include="Volo.Abp.Autofac" Version="5.1.4"/>
<PackageReference Include="Volo.Abp.EventBus.RabbitMQ" Version="5.1.4"/>
<PackageReference Include="Volo.Abp.Localization" Version="5.1.4"/>
<PackageReference Include="Volo.Abp.MultiTenancy" Version="5.1.4"/>
<PackageReference Include="Volo.Abp.AspNetCore.Mvc.UI.MultiTenancy" Version="5.1.4"/>
<PackageReference Include="Serilog.AspNetCore" Version="4.1.0"/>
<PackageReference Include="Serilog.Sinks.Async" Version="1.5.0"/>
<PackageReference Include="IdentityModel" Version="5.1.0"/>
<PackageReference Include="Microsoft.AspNetCore.Authentication.JwtBearer" Version="6.0.0"/>
<PackageReference Include="Microsoft.AspNetCore.DataProtection.StackExchangeRedis" Version="6.0.0"/>
<PackageReference Include="Volo.Abp.Caching.StackExchangeRedis" Version="5.1.4"/>
<PackageReference Include="Volo.Abp.Http.Client.IdentityModel.Web" Version="5.1.4"/>
<PackageReference Include="Volo.Abp.Identity.HttpApi.Client" Version="5.1.4"/>
<PackageReference Include="Volo.Abp.AspNetCore.Serilog" Version="5.1.4"/>
<PackageReference Include="Volo.Abp.Swashbuckle" Version="5.1.4"/>
<PackageReference Include="Volo.Abp.EntityFrameworkCore" Version="5.1.4"/>
<PackageReference Include="Volo.Abp.EntityFrameworkCore.PostgreSql" Version="5.1.4"/>
```

## Shared module

Lets create a shared `TaskyHostingModule` which can be added as dependency for all of our services.

```cs
using Volo.Abp.AspNetCore.MultiTenancy;
using Volo.Abp.AspNetCore.Serilog;
using Volo.Abp.Autofac;
using Volo.Abp.Caching.StackExchangeRedis;
using Volo.Abp.Data;
using Volo.Abp.EntityFrameworkCore;
using Volo.Abp.EntityFrameworkCore.PostgreSql;
using Volo.Abp.EventBus.RabbitMq;
using Volo.Abp.Localization;
using Volo.Abp.Modularity;
using Volo.Abp.MultiTenancy;
using Volo.Abp.Swashbuckle;

namespace Tasky.Shared.Hosting;

[DependsOn(
    typeof(AbpAutofacModule),
    typeof(AbpDataModule),
    typeof(AbpCachingStackExchangeRedisModule),
    typeof(AbpAspNetCoreSerilogModule),
    typeof(AbpAspNetCoreMultiTenancyModule),
    typeof(AbpSwashbuckleModule),
    typeof(AbpEventBusRabbitMqModule),
    typeof(AbpEntityFrameworkCoreModule),
    typeof(AbpEntityFrameworkCorePostgreSqlModule)
)]
public class TaskyHostingModule : AbpModule
{
    public override void ConfigureServices(ServiceConfigurationContext context)
    {
        Configure<AbpDbContextOptions>(options =>
        {
            options.UseNpgsql();
        });

        Configure<AbpMultiTenancyOptions>(options =>
        {
            options.IsEnabled = true;
        });

        Configure<AbpDbConnectionOptions>(options =>
        {
            options.Databases.Configure("SaaSService", database =>
            {
                database.MappedConnections.Add("AbpTenantManagement");
                database.IsUsedByTenants = false;
            });

            options.Databases.Configure("AdministrationService", database =>
            {
                database.MappedConnections.Add("AbpAuditLogging");
                database.MappedConnections.Add("AbpPermissionManagement");
                database.MappedConnections.Add("AbpSettingManagement");
                database.MappedConnections.Add("AbpFeatureManagement");
            });

            options.Databases.Configure("IdentityService", database =>
            {
                database.MappedConnections.Add("AbpIdentity");
                database.MappedConnections.Add("AbpIdentityServer");
            });
        });

        Configure<AbpLocalizationOptions>(options =>
        {
            options.Languages.Add(new LanguageInfo("ar", "ar", "Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©"));
            options.Languages.Add(new LanguageInfo("cs", "cs", "ÄŒeÅ¡tina"));
            options.Languages.Add(new LanguageInfo("en", "en", "English"));
            options.Languages.Add(new LanguageInfo("en-GB", "en-GB", "English (UK)"));
            options.Languages.Add(new LanguageInfo("fi", "fi", "Finnish"));
            options.Languages.Add(new LanguageInfo("fr", "fr", "FranÃ§ais"));
            options.Languages.Add(new LanguageInfo("hi", "hi", "Hindi", "in"));
            options.Languages.Add(new LanguageInfo("is", "is", "Icelandic", "is"));
            options.Languages.Add(new LanguageInfo("it", "it", "Italiano", "it"));
            options.Languages.Add(new LanguageInfo("hu", "hu", "Magyar"));
            options.Languages.Add(new LanguageInfo("pt-BR", "pt-BR", "PortuguÃªs"));
            options.Languages.Add(new LanguageInfo("ro-RO", "ro-RO", "RomÃ¢nÄƒ"));
            options.Languages.Add(new LanguageInfo("ru", "ru", "Ð ÑƒÑÑÐºÐ¸Ð¹"));
            options.Languages.Add(new LanguageInfo("sk", "sk", "Slovak"));
            options.Languages.Add(new LanguageInfo("tr", "tr", "TÃ¼rkÃ§e"));
            options.Languages.Add(new LanguageInfo("zh-Hans", "zh-Hans", "ç®€ä½“ä¸­æ–‡"));
            options.Languages.Add(new LanguageInfo("zh-Hant", "zh-Hant", "ç¹é«”ä¸­æ–‡"));
            options.Languages.Add(new LanguageInfo("de-DE", "de-DE", "Deutsch"));
            options.Languages.Add(new LanguageInfo("es", "es", "EspaÃ±ol"));
        });
    }
}
```

This is the first setup of our microservice application. the package and the modules in this project will become the base of all the services.

Repo: <https://github.com/antosubash/AbpMicroservice>
]]></content:encoded>
          </item><item>
          <title>Initial setup</title>
          <link>https://blog.antosubash.com/posts/netcore-microservice-with-abp-init-part-1</link>
          <guid>https://blog.antosubash.com/posts/netcore-microservice-with-abp-init-part-1</guid>
          <pubDate>Fri, 18 Mar 2022 00:00:00 GMT</pubDate>
          <description>In this post we will see how to do the initial setup for a abp microservice application.</description>
          <content:encoded><![CDATA[
This is first post of the series: [.NET Microservice with ABP](/posts/abp-microservice-series)

## Posts in the Series

Part 1. Initial Setup (this post)

[Part 2. Shared Project](/posts/netcore-microservice-with-abp-shared-project-part-2)

[Part 3. Administration Service](/posts/netcore-microservice-with-abp-administration-services-part-3)

[Part 4. Identity Service](/posts/netcore-microservice-with-abp-identity-services-part-4)

[Part 5. SaaS Service](/posts/netcore-microservice-with-abp-saas-services-part-5)

[Part 6. DB Migration](/posts/netcore-microservice-with-abp-db-migration-part-6)

[Part 7. Yarp and Tye](/posts/netcore-microservice-with-abp-yarp-and-tye-part-7)

[Part 8. Identity server and Angular App](/posts/netcore-microservice-with-abp-identity-server-and-angular-part-8)

[Part 9. Distributed event bus](/posts/netcore-microservice-with-abp-distributed-event-bus-part-9)

[Part 10. Docker and CI/CD](/posts/netcore-microservice-with-abp-docker-and-ci-cd-part-10)

[Part 11. Add a New service](/posts/netcore-microservice-with-abp-add-new-service-part-11)

[Part 12. Central Logging](/posts/netcore-microservice-with-abp-add-central-logging-part-12)

## Table of contents

## Initial Setup

This is the first step in creating your ABP microservice application. We will create the projects structure and the required projects for your microservice setup.

Most of the architecture is based on the EShopOnAbp Sample microservice application here <https://github.com/abpframework/eShopOnAbp>.

## Startup script

To simplify the project creation I have created a PowerShell script which will create the required projects and folders for use. You can copy and run this file to just create your base projects. The main reason to create this PowerShell script is the get started quickly. Setting up a microservice solution is a time-consuming process **this script will not create a working solution**. This will only create required projects in the particular structure. I came up with this structure following the [EShopOnAbp](https://github.com/abpframework/eShopOnAbp) application. you can update this script with your structure.

You can find the startup script here <https://github.com/antosubash/abp-setup/blob/main/init.ps1>

```bash
$name = $args[0]

dotnet new web -n "$name.IdentityServer" -o "apps\$name.IdentityServer"
dotnet new web -n "$name.Gateway" -o "gateway\$name.Gateway"
dotnet new classlib -n "$name.Shared.Hosting" -o "shared\$name.Shared.Hosting"
dotnet new console -n "$name.DbMigrator" -o "shared\$name.DbMigrator"
abp new "$name.AdministrationService" -t module --no-ui -o services\administration
abp new "$name.IdentityService" -t module --no-ui -o services\identity
abp new "$name.SaaSService" -t module --no-ui -o services\saas
dotnet new sln -n "$name"
dotnet sln ".\$name.sln" add (Get-ChildItem -r **/*.csproj)
abp new "$name" -t app -u angular -dbms PostgreSQL -m none --separate-identity-server --database-provider ef -csf -o temp
Move-Item -Path ".\temp\$name\angular\" -Destination .\apps\angular
Move-Item -Path ".\temp\$name\aspnet-core\src\$name.DbMigrator" -Destination .\shared\ -Force
Move-Item -Path ".\temp\$name\aspnet-core\src\$name.IdentityServer" -Destination .\apps\ -Force
Remove-Item -Recurse -Force .\temp\ 
dotnet sln ".\$name.sln" remove (Get-ChildItem -r **/*.Installer.csproj)
dotnet sln ".\$name.sln" remove (Get-ChildItem -r **/*.Host.Shared.csproj)
dotnet sln ".\$name.sln" remove (Get-ChildItem -r **/*.MongoDB.csproj)
dotnet sln ".\$name.sln" remove (Get-ChildItem -r **/*.MongoDB.Tests.csproj)
dotnet sln ".\$name.sln" remove (Get-ChildItem -r **/*.AdministrationService.IdentityServer.csproj)
dotnet sln ".\$name.sln" remove (Get-ChildItem -r **/*.IdentityService.IdentityServer.csproj)
dotnet sln ".\$name.sln" remove (Get-ChildItem -r **/*.SaaSService.IdentityServer.csproj)
Remove-Item -Recurse -Force (Get-ChildItem -r **/*.SaaSService.IdentityServer)
Remove-Item -Recurse -Force (Get-ChildItem -r **/*.IdentityService.IdentityServer)
Remove-Item -Recurse -Force (Get-ChildItem -r **/*.AdministrationService.IdentityServer)
Remove-Item -Recurse -Force (Get-ChildItem -r **/*.MongoDB.Tests)
Remove-Item -Recurse -Force (Get-ChildItem -r **/*.MongoDB)
Remove-Item -Recurse -Force (Get-ChildItem -r **/*.Host.Shared)
Remove-Item -Recurse -Force (Get-ChildItem -r **/*.Installer)
abp add-module Volo.AuditLogging -s "services\administration\$name.AdministrationService.sln" --skip-db-migrations
abp add-module Volo.FeatureManagement -s "services\administration\$name.AdministrationService.sln" --skip-db-migrations
abp add-module Volo.PermissionManagement -s "services\administration\$name.AdministrationService.sln" --skip-db-migrations
abp add-module Volo.SettingManagement -s "services\administration\$name.AdministrationService.sln" --skip-db-migrations

abp add-module Volo.Identity -s "services\identity\$name.IdentityService.sln" --skip-db-migrations
abp add-module Volo.IdentityServer -s "services\identity\$name.IdentityService.sln" --skip-db-migrations

abp add-module Volo.TenantManagement -s "services\saas\$name.SaaSService.sln" --skip-db-migrations
```

## Running the startup script

To run the startup script just create a new powershell script in the location where you want to create the solution and create a file called `init.ps1` and copy and past the above mentioned scripts.

To run the script

```bash
.\init.ps1 YourProjectName
```

This will trigger the scripts and the project creation will start. Wait until the script is done and open the solution to see the created projects.

> This script will only create the project and the projects are not ready for running it.

If you want to know more about what the script is doing please check out the video above which will have an explanation of what the script is doing.

Here is the sample repo with the working version of this solution: <https://github.com/antosubash/AbpMicroservice>
]]></content:encoded>
          </item><item>
          <title>Removing IdentityServer from ABP No Layer Template</title>
          <link>https://blog.antosubash.com/posts/abp-remove-identity-server-from-abp-no-layers-app</link>
          <guid>https://blog.antosubash.com/posts/abp-remove-identity-server-from-abp-no-layers-app</guid>
          <pubDate>Sun, 30 Jan 2022 00:00:00 GMT</pubDate>
          <description>In this post we will see how to remove identity server from the No Layer ABP template</description>
          <content:encoded><![CDATA[]]></content:encoded>
          </item><item>
          <title>Introduction to ABP No Layer Template</title>
          <link>https://blog.antosubash.com/posts/abp-no-layer-template</link>
          <guid>https://blog.antosubash.com/posts/abp-no-layer-template</guid>
          <pubDate>Sat, 29 Jan 2022 00:00:00 GMT</pubDate>
          <description>In this post we will explore the new experimental no layer template from the ABP framework</description>
          <content:encoded><![CDATA[## Table of contents

## Intro

ABP team released a new experimental app template with the name "app-nolayers". This is a minimal single project ABP application. They have removed all the DDD projects and provided a simple starting point. This will be helpful for the new developers who are trying out the ABP framework. Developers can learn the ABP framework without the DDD complexities.

## Update the ABP CLI

Make sure you have recent version cli before creating the app. you can also use the following command to update the cli.

```bash
dotnet tool update -g Volo.Abp.Cli
```

## Creating the No Layers app

To create the no layers app run the following command.

```bash
abp new Acme.BookStore -t app-nolayers
```

This will create the Bookstore app as a single project application.

## Run the migrations

Navigate to the `Acme.BookStore` folder. Since this is the no-layers application there is no migrations project. To run the migration add the "--migrate-database" cli argument

```bash
dotnet run --migrate-database
```

This will add the migrations and seed the database for you. Database will add the `admin` user and the required permissions.

## Running the app

To run the app use `dotnet watch` or `dotnet run`.

You will see a empty app running.

This app has all the modules of the normal abp application. you have IdentityServer configured as well.]]></content:encoded>
          </item><item>
          <title>Add tailwindcss to your ABP MVC UI</title>
          <link>https://blog.antosubash.com/posts/abp-add-tailwindcss-to-dotnet-mvc</link>
          <guid>https://blog.antosubash.com/posts/abp-add-tailwindcss-to-dotnet-mvc</guid>
          <pubDate>Tue, 11 Jan 2022 00:00:00 GMT</pubDate>
          <description>In this post we will see how to add tailwind css to your ABP MVC UI.</description>
          <content:encoded><![CDATA[## Table of contents

## Intro

In this post we will explore how to add TailWind CSS to your ABP MVC application. We will configure tailwind and create a new landing page with tailwind. Tailwind comes with the JIT mode. so you will only use the css need not the whole library. This will result in smaller css file compared to another framework.

## Prerequisites

Make sure to install `node`, `npm`, `.net6` and `abp`

## Create an abp App and Run Migrations

### Create the App

Run the following command to create the abp app.

```bash
abp new AbpTailwindMvc
```

### Run Migrations

change directory to `src/AbpTailwindMvc.DbMigrator` and run the migration project

```bash
dotnet run
```

This will create the migrations and seed the data for your project.

## Install Tailwind

Navigate to `src/AbpTailwindMvc.Web` project and then init npm.

### Install npm packages

Lets add the required packages for the tailwind css.

```bash
npm install -D tailwindcss postcss autoprefixer
```

### Initialize Tailwind

To initialize tailwind run the following command.

```bash
npx tailwindcss init --postcss
```

This will create tailwind config file `tailwind.config.js` and postcss config file `postcss.config.js`

### Update the tailwind config

```js
module.exports = {
  content: [
    '!**/{bin,obj,node_modules}/**',
    '**/*.{cshtml,html}',
  ],
  theme: {
    extend: {},
  },
  corePlugins: {
    preflight: false,
  },
  //prefix: 'tw-',
  plugins: [],
}
```

We have make 2 changes in the default config.

- We have updated the content to look for `cshtml` and `html` files
- We have remove the preflight

### Create Tailwind css files

We need to create 2 `css` files

- `/Style/tailwind.css` // This is the input
- `/wwwroot/tailwind.css` // This is the output

Update the input file with the `imports`

```css
@import "tailwindcss/components";
@import "tailwindcss/utilities";
```

### Update the package.json

We will update the scripts section of the `package.json`

```js
"scripts": {
"test": "echo \"Error: no test specified\" && exit 1",
"buildcss:dev": "npx tailwindcss --config tailwind.config.js --postcss postcss.config.js -i ./Style/tailwind.css -o ./wwwroot/tailwind.css",
"buildcss:release": "npx tailwindcss --config tailwind.config.js --postcss postcss.config.js -i ./Style/tailwind.css -o ./wwwroot/tailwind.css --minify",
"watch": "npx tailwindcss --config tailwind.config.js --postcss postcss.config.js -i ./Style/tailwind.css -o ./wwwroot/tailwind.css --watch"
},
```

We have add the 3 new scripts to the our `package.json`

- `buildcss:dev` this will build the css based on the tailwind config
- `buildcss:release` this will build minified css based on the tailwind config
- `watch` will watch for the new changes and create update the output file

### Add tailwindcss to you MVC app bundle

In the `AbpTailwindMvcWebModule` update the `ConfigureBundles` method

```cs
Configure<AbpBundlingOptions>(options =>
            {
                options.StyleBundles.Configure(
                    BasicThemeBundles.Styles.Global,
                    bundle =>
                    {
                        bundle.AddFiles("/global-styles.css");
                        bundle.AddFiles("/tailwind.css");
                    }
                );
            });
```

### Update csproj

We need to build the css before the project is launched. To do that we will update the `csproj` and create a build task.

```xml
<Target Name="BuildCSS" BeforeTargets="Compile">
    <Exec Command="npm run buildcss:dev" Condition=" '$(Configuration)' == 'Debug' " />
    <Exec Command="npm run buildcss:release" Condition=" '$(Configuration)' == 'Release' " />
</Target>
```

This command will run the npm command before the build so that we will have our css complied and ready to be displayed.

### Usage

To apply a background color use `bg-gray-200` you will see the color change.

Repo: <https://github.com/antosubash/AbpTailwindMvcUI>
]]></content:encoded>
          </item><item>
          <title>Generate typescript client from swagger / OpenApi</title>
          <link>https://blog.antosubash.com/posts/abp-generate-typescript-client-from-swagger-and-openapi</link>
          <guid>https://blog.antosubash.com/posts/abp-generate-typescript-client-from-swagger-and-openapi</guid>
          <pubDate>Sat, 08 Jan 2022 00:00:00 GMT</pubDate>
          <description>In this post we will see how to use how to use the NSwag to generate a typescript client with ABP</description>
          <content:encoded><![CDATA[## Table of contents

## Intro

In this post we will see how to use NSwag to generate typescript client from swagger and open api. We will use abp as a sample app and generate typescript client.

## Create an abp App and Run Migrations

### Create the App

Run the following command to create the abp app.

```bash
abp new AbpNSwag
```

### Run Migrations

change directory to `src/AbpNSwag.DbMigrator` and run the migration project

```bash
dotnet run
```

## Fix the type name in the swagger

### Create type extension

Change the custom schema id for NSwag generation

```cs
using System;
using System.Linq;
using System.Reflection;
using System.Runtime.Serialization;
using System.Text;

namespace AbpNSwag
{
    public static class TypeExtensions
    {
        public static string FriendlyId(this Type type, bool fullyQualified = false)
        {
            var typeName = fullyQualified
                ? type.FullNameSansTypeParameters().Replace("+", ".")
                : type.Name;

            if (type.IsGenericType)
            {
                var genericArgumentIds = type.GetGenericArguments()
                    .Select(t => t.FriendlyId(fullyQualified))
                    .ToArray();

                return new StringBuilder(typeName)
                    .Replace(string.Format("`{0}", genericArgumentIds.Count()), string.Empty)
                    .Append(string.Format("[{0}]", string.Join(",", genericArgumentIds).TrimEnd(',')))
                    .ToString();
            }

            return typeName;
        }

        public static string FullNameSansTypeParameters(this Type type)
        {
            var fullName = type.FullName;
            if (string.IsNullOrEmpty(fullName))
                fullName = type.Name;
            var chopIndex = fullName.IndexOf("[[");
            return (chopIndex == -1) ? fullName : fullName.Substring(0, chopIndex);
        }

        public static string[] GetEnumNamesForSerialization(this Type enumType)
        {
            return enumType.GetFields(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static)
                .Select(fieldInfo =>
                {
                    var memberAttribute = fieldInfo.GetCustomAttributes(false).OfType<EnumMemberAttribute>().FirstOrDefault();
                    return (memberAttribute == null || string.IsNullOrWhiteSpace(memberAttribute.Value))
                        ? fieldInfo.Name
                        : memberAttribute.Value;
                })
                .ToArray();
        }
    }
}
```

This file is copied from the here <https://github.com/domaindrivendev/Swashbuckle.WebApi/blob/master/Swashbuckle.Core/Swagger/TypeExtensions.cs>

### Change the custom schema id and operation id

Update `AddAbpSwaggerGenWithOAuth` method call in your web project.

```cs
options.CustomSchemaIds(type => type.FriendlyId().Replace("[", "Of").Replace("]", ""));
options.CustomOperationIds(options => $"{options.ActionDescriptor.RouteValues["controller"]}{options.ActionDescriptor.RouteValues["action"]}");
```

this will fix the generic list problem and simplify the name in the swagger ui.

Now we are ready to generate the typescript client.

## Install NSwag

```bash
npm install nswag -g
```

## Generate typescript client

```bash
nswag openapi2tsclient /input:https://localhost:44392/swagger/v1/swagger.json /output:generated/MyProjectModels.ts /typeScriptTemplate Axios
```

This will generate the `Axios` client for you to use.

## Other generators

Other options is to use the `openapi-typescript-codegen` package. Install the package globally.

```bash
npm install openapi-typescript-codegen -g
```

create the local copy of swagger json from here <https://localhost:44392/swagger/v1/swagger.json> now we can use this json file to generate type script client.

```bash
openapi -i swagger.json -o api -c axios
```

this will generate axios client with proper structure.

Repo : <https://github.com/antosubash/AbpNSwag>
]]></content:encoded>
          </item><item>
          <title>Add tailwindcss to your ABP Blazor UI</title>
          <link>https://blog.antosubash.com/posts/abp-add-tailwindcss-to-blazor-ui</link>
          <guid>https://blog.antosubash.com/posts/abp-add-tailwindcss-to-blazor-ui</guid>
          <pubDate>Wed, 05 Jan 2022 00:00:00 GMT</pubDate>
          <description>In this post we will see how to add tailwind css to your ABP Blazor UI.</description>
          <content:encoded><![CDATA[## Table of contents

## Intro

In this post we will explore how to add TailWind CSS to your ABP Blazor application. We will configure tailwind in a way that it will not conflict with your current bootstrap theme. Tailwind comes with the JIT mode. so you will only use the css need not the whole library. This will result in smaller css file compared to another framework.

## Prerequisites

Make sure to install `node`, `npm`, `.net6` and `abp`

## Create an abp App and Run Migrations

### Create the App

Run the following command to create the abp app.

```bash
abp new AbpTailwindBlazor -t app -u blazor --mobile none
```

### Run Migrations

change directory to `src/AbpTailwindBlazor.DbMigrator` and run the migration project

```bash
dotnet run
```

This will create the migrations and seed the data for your project.

## Install Tailwind

Navigate to `src/AbpTailwindBlazor.Blazor` project and then init npm.

### Init Npm

To init npm run the following command.

```bash
npm init --yes
```

This will create the `package.json` file with the default values.

### Install npm packages

Lets add the required packages for the tailwind css.

```bash
npm install -D tailwindcss postcss autoprefixer
```

### Initialize Tailwind

To initialize tailwind run the following command.

```bash
npx tailwindcss init --postcss
```

This will create tailwind config file `tailwind.config.js` and postcss config file `postcss.config.js`

### Update the tailwind config

```js
module.exports = {
  content: [
    '!**/{bin,obj,node_modules}/**',
    '**/*.{razor,html}',
  ],
  theme: {
    extend: {},
  },
  corePlugins: {
    preflight: false,
  },
  prefix: 'tw-',
  plugins: [],
}
```

We have make 3 changes in the default config.

- We have updated the content to look for `razor` and `html` files
- We have remove the preflight
- We have add `prefix` to all the tailwind css

### Create Tailwind css files

We need to create 2 `css` files

- `/Style/tailwind.css` // This is the input
- `/wwwroot/tailwind.css` // This is the output

Update the input file with the `imports`

```css
@import "tailwindcss/components";
@import "tailwindcss/utilities";
```

### Update the package.json

We will update the scripts section of the `package.json`

```js
"scripts": {
"test": "echo \"Error: no test specified\" && exit 1",
"buildcss:dev": "npx tailwindcss --config tailwind.config.js --postcss postcss.config.js -i ./Style/tailwind.css -o ./wwwroot/tailwind.css",
"buildcss:release": "npx tailwindcss --config tailwind.config.js --postcss postcss.config.js -i ./Style/tailwind.css -o ./wwwroot/tailwind.css --minify",
"watch": "npx tailwindcss --config tailwind.config.js --postcss postcss.config.js -i ./Style/tailwind.css -o ./wwwroot/tailwind.css --watch"
},
```

We have add the 3 new scripts to the our `package.json`

- `buildcss:dev` this will build the css based on the tailwind config
- `buildcss:release` this will build minified css based on the tailwind config
- `watch` will watch for the new changes and create update the output file

### Update the Index page

The Index page is the `index.html` file inside the `wwwroot` folder.

We have add our generated css file to the blazor.

```html
<link href="tailwind.css" rel="stylesheet"/>
```

### Update csproj

We need to build the css before the project is launched. To do that we will update the `csproj` and create a build task.

```xml
<Target Name="BuildCSS" BeforeTargets="Compile">
    <Exec Command="npm run buildcss:dev" Condition=" '$(Configuration)' == 'Debug' " />
    <Exec Command="npm run buildcss:release" Condition=" '$(Configuration)' == 'Release' " />
</Target>
```

This command will run the npm command before the build so that we will have our css complied and ready to be displayed.

### Usage

To use the tailwind css you should use the `tw-` prefix. so to apply a background color use `tw-bg-gray-200` you will see the color change.

Repo: <https://github.com/antosubash/AbpTailwindBlazor>
]]></content:encoded>
          </item><item>
          <title>Minimal Api with ABP - Swagger and CRUD - Part 3</title>
          <link>https://blog.antosubash.com/posts/abp-crud-with-minimal-api-p3</link>
          <guid>https://blog.antosubash.com/posts/abp-crud-with-minimal-api-p3</guid>
          <pubDate>Fri, 31 Dec 2021 00:00:00 GMT</pubDate>
          <description>In this post we will see how to use minimal api with the ABP application to create a CRUD app.</description>
          <content:encoded><![CDATA[## Table of contents

## Intro

In this we will continue with the last one and create a CRUD API with Minimal API.

This is a continuation of [Part 2](https://blog.antosubash.com/posts/abp-with-minimal-api-p2)

## Create the project

```bash
dotnet new web -n MinimalAbpCRUD
```

Navigate to the `MinimalAbpCRUD` folder and add the required packages.

## Add required packages

To add the required packages use the `dotnet add package` command.

```bash
dotnet add package Volo.Abp.Autofac
dotnet add package Volo.Abp.AspNetCore.Mvc
dotnet add package Swashbuckle.AspNetCore 
dotnet add package Volo.Abp.EntityFrameworkCore.Sqlite
dotnet add package Microsoft.EntityFrameworkCore.Design
```

## Create Entity

We will create a simple `Book` Entity.

```cs
public class Book : AuditedAggregateRoot<Guid>
{
    public Book(Guid id, string name)
    {
        this.Id = id;
        this.Name = name;
    }
    public string Name { get; set; }
}
```

## Create DB Context

```cs
public class MyDbContext : AbpDbContext<MyDbContext>
{
    public DbSet<Book> Books => Set<Book>();

    public MyDbContext(DbContextOptions<MyDbContext> options)
        : base(options)
    {
    }

    protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
    {
        base.OnConfiguring(optionsBuilder);
        optionsBuilder.UseSqlite();
    }

    protected override void OnModelCreating(ModelBuilder builder)
    {
        base.OnModelCreating(builder);
        builder.Entity<Book>(b =>
        {
            b.ToTable("Books");
            b.ConfigureByConvention();
            b.HasData(new Book(Guid.NewGuid(),"My Book"));
        });
    }
}
```

This db context will configure the entity and also seed the database with one data.

## Create the minimal module

```cs
[DependsOn(
    typeof(AbpAspNetCoreMvcModule),
    typeof(AbpAutofacModule),
    typeof(AbpEntityFrameworkCoreSqliteModule)
)]
public class MinimalModule : AbpModule
{
    public override void ConfigureServices(ServiceConfigurationContext context)
    {  
        context.Services.AddEndpointsApiExplorer();
        context.Services.AddSwaggerGen();   
        context.Services.AddAbpDbContext<MyDbContext>(options =>
        {
            options.AddDefaultRepositories(includeAllEntities: true);
        }); 
        Configure<AbpDbContextOptions>(options =>
        {
            options.UseSqlite();
        });
    }

    public override void OnApplicationInitialization(ApplicationInitializationContext context)
    {
        var app = context.GetApplicationBuilder();
        var env = context.GetEnvironment();
        if (env.IsDevelopment())
        {
            app.UseSwagger();
            app.UseSwaggerUI();
        }
        app.UseHttpsRedirection();
    }
}
```

## Create the minimal api

```cs
var builder = WebApplication.CreateBuilder(args);
builder.Host.AddAppSettingsSecretsJson().UseAutofac();
builder.Services.ReplaceConfiguration(builder.Configuration);
builder.Services.AddApplication<MinimalModule>();
var app = builder.Build();

app.MapGet("/book", async ([FromServices] IRepository<Book, Guid> repository) =>
{
    return await repository.GetListAsync();
});

app.MapPost("/book", async (string name, [FromServices] IRepository<Book, Guid> repository) =>
{
    var newBook = await repository.InsertAsync(new Book(Guid.NewGuid(),name));
    return Results.Created($"/book/{newBook.Id}", newBook);
});

app.MapPut("/book/{id}", async (Guid id, string name, [FromServices] IRepository<Book, Guid> repository) =>
{
    var book = await repository.GetAsync(id);
    book.Name = name;
    return await repository.UpdateAsync(book);
});

app.MapDelete("/book/{id}", async (Guid id, [FromServices] IRepository<Book, Guid> repository) =>
{
    var book = await repository.GetAsync(id);
    await repository.DeleteAsync(id);
});

app.InitializeApplication();
app.Run();
```

## Add connection string

update the `appsettings.json` with the `ConnectionStrings`

```js
"ConnectionStrings": {
    "Default": "Filename=./db.sqlite"
}
```

## Create migration

Now our app is ready lets create migrations for the DBcontext.

```bash
dotnet ef migrations add init
```

## Apply migrations to DB

```bash
dotnet ef database update
```

## Run the App

```bash
dotnet run
```

## View the Book

Once the application is launched navigate to `/swagger` you will see swagger UI.

Repo : <https://github.com/antosubash/AbpMinimalApiCRUD>
]]></content:encoded>
          </item><item>
          <title>Minimal Api with ABP - EF Core - Part 2</title>
          <link>https://blog.antosubash.com/posts/abp-with-minimal-api-p2</link>
          <guid>https://blog.antosubash.com/posts/abp-with-minimal-api-p2</guid>
          <pubDate>Thu, 30 Dec 2021 00:00:00 GMT</pubDate>
          <description>In this post we will see how to use minimal api with the ABP application and configure EF core.</description>
          <content:encoded><![CDATA[## Table of contents

## Intro

In this we will continue with the last one and add Ef core to our Minimal ABP module.

This is a continuation of [Part 1](https://blog.antosubash.com/posts/abp-with-minimal-api-p1)

## Create the project

```bash
dotnet new web -n MinimalEFWithAbp
```

Navigate to the `MinimalEFWithAbp` folder and add the required packages.

## Add required packages

To add the required packages use the `dotnet add package` command.

```bash
dotnet add package Volo.Abp.Autofac
dotnet add package Volo.Abp.AspNetCore.Mvc
dotnet add package Volo.Abp.EntityFrameworkCore.Sqlite
dotnet add package Microsoft.EntityFrameworkCore.Design
```

## Create Entity

We will create a simple `Book` Entity.

```cs
public class Book : AuditedAggregateRoot<Guid>
{
    public Book(Guid id, string name)
    {
        this.Id = id;
        this.Name = name;
    }
    public string Name { get; set; }
}
```

## Create DB Context

```cs
public class MyDbContext : AbpDbContext<MyDbContext>
{
    public DbSet<Book> Books => Set<Book>();

    public MyDbContext(DbContextOptions<MyDbContext> options)
        : base(options)
    {
    }

    protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
    {
        base.OnConfiguring(optionsBuilder);
        optionsBuilder.UseSqlite();
    }

    protected override void OnModelCreating(ModelBuilder builder)
    {
        base.OnModelCreating(builder);
        builder.Entity<Book>(b =>
        {
            b.ToTable("Books");
            b.ConfigureByConvention();
            b.HasData(new Book(Guid.NewGuid(),"My Book"));
        });
    }
}
```

This db context will configure the entity and also seed the database with one data.

## Create the minimal module

```cs
[DependsOn(
    typeof(AbpAspNetCoreMvcModule),
    typeof(AbpAutofacModule),
    typeof(AbpEntityFrameworkCoreSqliteModule)
)]
public class MinimalModule : AbpModule
{
    public override void ConfigureServices(ServiceConfigurationContext context)
    {     
        context.Services.AddAbpDbContext<MyDbContext>(options =>
        {
            options.AddDefaultRepositories(includeAllEntities: true);
        }); 
        Configure<AbpDbContextOptions>(options =>
        {
            options.UseSqlite();
        });
    }
}
```

## Create the minimal api

```cs
var builder = WebApplication.CreateBuilder(args);
builder.Host.AddAppSettingsSecretsJson()
    .UseAutofac();
builder.Services.ReplaceConfiguration(builder.Configuration);
builder.Services.AddApplication<MinimalModule>();
var app = builder.Build();

app.MapGet("/book", async ([FromServices] IRepository<Book, Guid> repository) =>
{
    return await repository.GetListAsync();
});

app.InitializeApplication();
app.Run();
```

We have one `GET` request which will return the data from the db.

## Add connection string

update the `appsettings.json` with the `ConnectionStrings`

```js
"ConnectionStrings": {
    "Default": "Filename=./db.sqlite"
}
```

## Create migration

Now our app is ready lets create migrations for the DBcontext.

```bash
dotnet ef migrations add init
```

## Apply migrations to DB

```bash
dotnet ef database update
```

## Run the App

```bash
dotnet run
```

## View the Book

Once the application is launched navigate to `/book` you will see the seeded book as a json response.

Repo : <https://github.com/antosubash/AbpMinimalApiWithEFCore>
]]></content:encoded>
          </item><item>
          <title>Minimal Api with ABP - Hello World - Part 1</title>
          <link>https://blog.antosubash.com/posts/abp-with-minimal-api-p1</link>
          <guid>https://blog.antosubash.com/posts/abp-with-minimal-api-p1</guid>
          <pubDate>Wed, 29 Dec 2021 00:00:00 GMT</pubDate>
          <description>In this post we will see how to use minimal api with the ABP application.</description>
          <content:encoded><![CDATA[## Table of contents

## Intro

Minimal api in .Net 6 provides a new way for creating http api. Minimal API provides simplicity and removes lot of boilerplate. We will see how to use the minimal api with ABP.

## Hello world

First lets create a empty c# project.

```bash
dotnet new web -n HelloWorld
```

This will create a empty hello world project.

Let add the abp packages.

```bash
dotnet add package Volo.Abp.Autofac
dotnet add package Volo.Abp.AspNetCore.Mvc
```

### Minimal Module

lets create a very simple module.

```cs
[DependsOn(
    typeof(AbpAspNetCoreMvcModule),
    typeof(AbpAutofacModule)
)]
public class MinimalModule : AbpModule
{
}
```

This module depends on `AbpAspNetCoreMvcModule` and `AbpAutofacModule`. The configure service method is used to register the assembly of `MinimalModule` for dependency injection. 

### Hello service

lets create a simple service which will say hello world.

```cs
public class HelloService : ITransientDependency
{
    public string SayHi()
    {
        return "Hi from service";
    }
}
```

### Minimal Application

Lets create the minimal application

```cs
using Volo.Abp;
using Microsoft.AspNetCore.Mvc;
using Volo.Abp.AspNetCore.Mvc;
using Volo.Abp.Autofac;
using Volo.Abp.Modularity;
using Volo.Abp.DependencyInjection;
var builder = WebApplication.CreateBuilder(args);
builder.Host.UseAutofac();
builder.Services.ReplaceConfiguration(builder.Configuration);
builder.Services.AddApplication<MinimalModule>();

var app = builder.Build();

app.MapGet("/hi", ([FromServices] HelloService helloService) =>
{
    return helloService.SayHi();
});

app.InitializeApplication();
app.Run();
```

This application has only one end point `/hi` which prints hello world. We are Injecting the hello world service we created and then we are calling the `SayHi` method from the service.

To run the app.

```bash
dotnet run
```

Repo: <https://github.com/antosubash/AbpMinimalApiHelloWorld>
]]></content:encoded>
          </item><item>
          <title>Add a new Module and convert it to a microservice in ABP</title>
          <link>https://blog.antosubash.com/posts/abp-module-to-microservice</link>
          <guid>https://blog.antosubash.com/posts/abp-module-to-microservice</guid>
          <pubDate>Sat, 27 Nov 2021 00:00:00 GMT</pubDate>
          <description>In this post we will see how to create a modular abp application and convert it to microservice. We will add a new module to tiered abp app and then use the separate database to store the modules data and then convert the module to a microservice..</description>
          <content:encoded><![CDATA[## Table of contents

## Intro

In this post we will see how to create a modular abp application and convert it to microservice. We will add a new module to tiered abp app and then use the separate database to store the modules data and then convert the module to a microservice.

In this sample we will create Tiered app which is called `MainApp`. Then we will add a module called `ProjectService`.

## Creating the abp application and run migrations

```bash
abp new MainApp -t app -u mvc --tiered
```

## Run Migrations

Change directory to src/MainApp.DbMigrator and run the migration project

```bash
dotnet run
```

This will apply the migrations to the db and we can run the `MainApp.Web` project. This will host the UI and API..

## Add a new Module

Now we will add a new module to our MainApp. Move back to the `root` folder of your project.

```bash
abp add-module ProjectService --new
```

This will create a ProjectService and it will be available in the modules folder.

## Add and configure the host to the module

We need to add a host for our module. first we have to navigate to the the src folder of the Module.

```bash
cd .\modules\ProjectService\src\
```

Now lets create a Web Api project to host our module.

```bash
dotnet new webapi -n ProjectService.HttpApi.Host
```

Now open the ProjectService solution and the newly created Host project to the solution.

Update the `appsettings.json` with the following

```json
{
  "App": {
    "SelfUrl": "{Host Url}",
    "CorsOrigins": "https://*.MainApp.com"
  },
  "AuthServer": {
    "Authority": "{ Identity Server Url }",
    "RequireHttpsMetadata": "true",
    "SwaggerClientId": "ProjectService_Swagger",
    "SwaggerClientSecret": "1q2w3e*"
  },
  "ConnectionStrings": {
    "ProjectService": "Server=(LocalDb)\\MSSQLLocalDB;Database=ProjectService;Trusted_Connection=True"
  },
  "Redis": {
    "Configuration": "127.0.0.1"
  },
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft": "Warning",
      "Microsoft.Hosting.Lifetime": "Information"
    }
  }
}
```

Add the following packages to the `ProjectService.HttpApi.Host` project.

```xml
<ItemGroup>
    <PackageReference Include="Serilog.AspNetCore" Version="4.1.0" />
    <PackageReference Include="Volo.Abp.EntityFrameworkCore" Version="5.0.0-rc.1" />
    <PackageReference Include="Volo.Abp.AspNetCore.MultiTenancy" Version="5.0.0-rc.1" />
    <PackageReference Include="Volo.Abp.Autofac" Version="5.0.0-rc.1" />
    <PackageReference Include="Volo.Abp.Core" Version="5.0.0-rc.1" />
    <PackageReference Include="Volo.Abp.EntityFrameworkCore.SqlServer" Version="5.0.0-rc.1" />
    <PackageReference Include="Volo.Abp.Swashbuckle" Version="5.0.0-rc.1" />
    <PackageReference Include="Volo.Abp.AspNetCore.Authentication.JwtBearer" Version="5.0.0-rc.1" />
    <PackageReference Include="Volo.Abp.AspNetCore.Serilog" Version="5.0.0-rc.1" />
    <PackageReference Include="Serilog.Extensions.Logging" Version="3.0.1" />
    <PackageReference Include="Serilog.Sinks.Async" Version="1.4.0" />
    <PackageReference Include="Serilog.Sinks.File" Version="4.1.0" />
    <PackageReference Include="Serilog.Sinks.Console" Version="3.1.1" />
</ItemGroup>
```

These are the essential packages for our host.

Add `ProjectService.Application`, `ProjectService.EntityFrameworkCore`, `ProjectService.HttpApi` projects as a reference to your `ProjectService.HttpApi.Host`

We are adding the projects reference because the host project module will depend on the module from these projects.

Create a `ProjectServiceHostModule` in the newly created `ProjectService.HttpApi.Host`. This will be a abp module where we will setup the host.

Here is the sample for the `ProductService`.

```cs
using Microsoft.AspNetCore.Authentication.JwtBearer;
using Microsoft.AspNetCore.Builder;
using Microsoft.AspNetCore.Cors;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using Microsoft.OpenApi.Models;
using ProjectService.EntityFrameworkCore;
using System;
using System.Collections.Generic;
using System.Linq;
using Volo.Abp;
using Volo.Abp.AspNetCore.MultiTenancy;
using Volo.Abp.AspNetCore.Mvc;
using Volo.Abp.AspNetCore.Serilog;
using Volo.Abp.Autofac;
using Volo.Abp.Modularity;
using Volo.Abp.Swashbuckle;

namespace ProjectService.HttpApi.Host
{

    [DependsOn(
    typeof(ProjectServiceHttpApiModule),
    typeof(ProjectServiceApplicationModule),
    typeof(ProjectServiceEntityFrameworkCoreModule),
    typeof(AbpAspNetCoreMultiTenancyModule),
    typeof(AbpAutofacModule),
    typeof(AbpAspNetCoreSerilogModule),
    typeof(AbpSwashbuckleModule)
    )]
    public class ProjectServiceHostModule : AbpModule
    {
        public override void ConfigureServices(ServiceConfigurationContext context)
        {
            var configuration = context.Services.GetConfiguration();
            context.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)
                .AddJwtBearer(options =>
                {
                    options.Authority = configuration["AuthServer:Authority"];
                    options.RequireHttpsMetadata = Convert.ToBoolean(configuration["AuthServer:RequireHttpsMetadata"]);
                    options.Audience = "ProjectService";
                });

            context.Services.AddAbpSwaggerGenWithOAuth(
                configuration["AuthServer:Authority"],
                new Dictionary<string, string>
                {
                    {"ProjectService", "ProjectService API"}
                },
                options =>
                {
                    options.SwaggerDoc("v1", new OpenApiInfo { Title = "ProjectService API", Version = "v1" });
                    options.DocInclusionPredicate((docName, description) => true);
                    options.CustomSchemaIds(type => type.FullName);
                });

            Configure<AbpAspNetCoreMvcOptions>(options =>
            {
                options.ConventionalControllers.Create(typeof(ProjectServiceApplicationModule).Assembly);
            });

            context.Services.AddCors(options =>
            {
                options.AddDefaultPolicy(builder =>
                {
                    builder
                        .WithOrigins(
                            configuration["App:CorsOrigins"]
                                .Split(",", StringSplitOptions.RemoveEmptyEntries)
                                .Select(o => o.Trim().RemovePostFix("/"))
                                .ToArray()
                        )
                        .WithAbpExposedHeaders()
                        .SetIsOriginAllowedToAllowWildcardSubdomains()
                        .AllowAnyHeader()
                        .AllowAnyMethod()
                        .AllowCredentials();
                });
            });
        }

        public override void OnApplicationInitialization(ApplicationInitializationContext context)
        {
            var app = context.GetApplicationBuilder();
            var env = context.GetEnvironment();

            if (env.IsDevelopment())
            {
                app.UseDeveloperExceptionPage();
            }

            app.UseCorrelationId();
            app.UseCors();
            app.UseAbpRequestLocalization();
            app.UseStaticFiles();
            app.UseRouting();
            app.UseAuthentication();
            app.UseAbpClaimsMap();
            app.UseMultiTenancy();
            app.UseAuthorization();
            app.UseSwagger();
            app.UseAbpSwaggerUI(options => {
                options.SwaggerEndpoint("/swagger/v1/swagger.json", "ProjectService Service API");
                var configuration = context.ServiceProvider.GetRequiredService<IConfiguration>();
                options.OAuthClientId(configuration["AuthServer:SwaggerClientId"]); 
                options.OAuthClientSecret(configuration["AuthServer:SwaggerClientSecret"]); 
            });
            app.UseAbpSerilogEnrichers();
            app.UseAuditing();
            app.UseUnitOfWork();
            app.UseConfiguredEndpoints();
        }
    }
}
```

In this module the depends on section configures the modules that it depends on in the `DependsOn` section and we will configure the JWT auth and the swagger UI for the host.

Update the `Program.cs`

```cs
using System;
using System.IO;
using Microsoft.AspNetCore.Hosting;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.Hosting;
using Serilog;
using Serilog.Events;

namespace ProjectService
{
    public class Program
    {
        public static int Main(string[] args)
        {
            Log.Logger = new LoggerConfiguration()
#if DEBUG
                .MinimumLevel.Debug()
#else
                .MinimumLevel.Information()
#endif
                .MinimumLevel.Override("Microsoft", LogEventLevel.Information)
                .MinimumLevel.Override("Microsoft.EntityFrameworkCore", LogEventLevel.Warning)
                .Enrich.FromLogContext()
                .WriteTo.Async(c => c.File("Logs/logs.txt"))
#if DEBUG
                .WriteTo.Async(c => c.Console())
#endif
                .CreateLogger();

            try
            {
                Log.Information("Starting ProjectService.Host.");
                CreateHostBuilder(args).Build().Run();
                return 0;
            }
            catch (Exception ex)
            {
                Log.Fatal(ex, "Host terminated unexpectedly!");
                return 1;
            }
            finally
            {
                Log.CloseAndFlush();
            }
        }

        internal static IHostBuilder CreateHostBuilder(string[] args) =>
            Host.CreateDefaultBuilder(args)
                .ConfigureAppConfiguration(build =>
                {
                    build.AddJsonFile("appsettings.secrets.json", optional: true);
                })
                .ConfigureWebHostDefaults(webBuilder =>
                {
                    webBuilder.UseStartup<Startup>();
                })
                .UseAutofac()
                .UseSerilog();
    }

}
```

Program file is updated to use the serilog with enrichers.

Update the `Startup.cs`

```cs
using Microsoft.AspNetCore.Builder;
using Microsoft.AspNetCore.Hosting;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;
using ProjectService.HttpApi.Host;

namespace ProjectService
{
    public class Startup
    {
        public void ConfigureServices(IServiceCollection services)
        {
            services.AddApplication<ProjectServiceHostModule>();
        }

        public void Configure(IApplicationBuilder app, IWebHostEnvironment env, ILoggerFactory loggerFactory)
        {
            app.InitializeApplication();
        }
    }
}
```

In the startup file we are configuring our newly created Host module.

Create a `HomeController.cs` in the `Controller` folder and update wit the following text.

```cs
using Microsoft.AspNetCore.Mvc;
using Volo.Abp.AspNetCore.Mvc;

namespace ProjectService.HttpApi.Host.Controllers
{
    public class HomeController : AbpController
    {
        public ActionResult Index()
        {
            return Redirect("~/swagger");
        }
    }
}
```

Now our default route will be swagger.

We are mostly done with the host and now we can create the AppService.

## Add new Entity to the ProjectService

We are going to create a simple `Project` entity and create a AppService for that project. This section of the tutorial is based on the [Quick Start Guide](https://docs.abp.io/en/abp/latest/Tutorials/Todo/Index?UI=MVC&DB=EF)

We will create a new Entity inside the `ProjectService.Domain` called `Project`.

## Create an Entity

Learn more about the [Entity](https://docs.abp.io/en/abp/latest/Entities) in the abp docs.

First step is to create an Entity. Create the Entity in the `ProjectService.Domain` project.

```cs
public class Project : Entity<Guid>
{
    public string Name { get; set; }
}
```

## Add Entity to EfCore

Learn more about the [ef core](https://docs.abp.io/en/abp/latest/Entity-Framework-Core) in the abp docs.

Next is to add Entity to the EF Core. you will find the DbContext in the `ProjectService.EntityFrameworkCore` project. Add the DbSet to the DbContext

```cs
public DbSet<Project> Projects { get; set; }
```

## Configure Entity in EfCore

Make sure you have the updated the ef core global tool

Configuration is done in the `DbContextModelCreatingExtensions` class. This should be available in the `ProjectService.EntityFrameworkCore` project

```cs
builder.Entity<Project>(b =>
{
    //Configure table & schema name
    b.ToTable(ProjectServiceDbProperties.DbTablePrefix + "Projects", ProjectServiceDbProperties.Schema);

    b.ConfigureByConvention();
});
```

## Prepare for the migration

```bash
dotnet tool update --global dotnet-ef
```

Add necessary packages to the `ProjectService.EntityFrameworkCore` project.

```xml
<PackageReference Include="Microsoft.EntityFrameworkCore.Design" Version="6.0.0">
    <PrivateAssets>all</PrivateAssets>
    <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
</PackageReference>
<PackageReference Include="Volo.Abp.EntityFrameworkCore" Version="5.0.0-rc.1" />
<PackageReference Include="Volo.Abp.EntityFrameworkCore.SqlServer" Version="5.0.0-rc.1" />
```

We need to create a `ProjectServiceDbContextFactory` to support migrations. [Check here for more info about this](https://docs.microsoft.com/en-us/ef/core/cli/dbcontext-creation?tabs=dotnet-core-cli)

```cs
public class ProjectServiceDbContextFactory : IDesignTimeDbContextFactory<ProjectServiceDbContext>
{
    public ProjectServiceDbContext CreateDbContext(string[] args)
    {
        var builder = new DbContextOptionsBuilder<ProjectServiceDbContext>()
            .UseSqlServer(GetConnectionStringFromConfiguration());
        return new ProjectServiceDbContext(builder.Options);
    }

    private static string GetConnectionStringFromConfiguration()
    {
        return BuildConfiguration()
            .GetConnectionString(ProjectServiceDbProperties.ConnectionStringName);
    }

    private static IConfigurationRoot BuildConfiguration()
    {
        var builder = new ConfigurationBuilder()
            .SetBasePath(
                Path.Combine(
                    Directory.GetCurrentDirectory(),
                    $"..{Path.DirectorySeparatorChar}ProjectService.HttpApi.Host"
                )
            )
            .AddJsonFile("appsettings.json", optional: false);

        return builder.Build();
    }
}
```

This is needed for ef core migration to work. We are building the configuration by taking the `appsetting.json` from the `ProjectService.HttpApi.Host`.

## Adding Migrations

Now the `DbContextFactory` is configured we can add the migrations.

Go the `ProjectService.EntityFrameworkCore` project in the terminal and create migrations.

To create migration run this command:

```bash
dotnet ef migrations add created_projects
```

Verify the migrations created in the migrations folder.

To update the database run this command

```bash
dotnet ef database update
```

## Create a Entity Dto

Dto are placed in `ProjectService.Application.Contracts` project

```cs
public class ProjectDto: EntityDto<Guid>
{
    public string Name { get; set; }
}
```

## Create a AppService interface

create `IProjectAppService` interface in the `ProjectService.Application.Contracts` project

```cs
public interface IProjectAppService: IApplicationService
{
    Task<List<ProjectDto>> GetListAsync();
    Task<ProjectDto> CreateAsync(string text);
    Task DeleteAsync(Guid id);
}
```

## Create an Application Services

Learn more about the [Application Services](https://docs.abp.io/en/abp/latest/Application-Services) in the abp docs.

Application service are created in the `ProjectService.Application` project

```cs
[Authorize]
public class ProjectAppService : ProjectServiceAppService, IProjectAppService
{
    private readonly IRepository<Project, Guid> projectRepository;

    public ProjectAppService(IRepository<Project, Guid> projectRepository)
    {
        this.projectRepository = projectRepository;
    }

    public async Task<ProjectDto> CreateAsync(string text)
    {
        var projectItem = await projectRepository.InsertAsync(
                            new Project { Name = text }
                            );

        return new ProjectDto
        {
            Id = projectItem.Id,
            Name = projectItem.Name
        };
    }

    public async Task DeleteAsync(Guid id)
    {
        await projectRepository.DeleteAsync(id);
    }

    public async Task<List<ProjectDto>> GetListAsync()
    {
        var items = await projectRepository.GetListAsync();
        return items
            .Select(item => new ProjectDto
            {
                Id = item.Id,
                Name = item.Name
            }).ToList();
    }
}
```

## Update the EntityFrameworkCoreModule

Update the `ConfigureServices` method in the `ProjectServiceEntityFrameworkCoreModule` file.

```cs
context.Services.AddAbpDbContext<ProjectServiceDbContext>(options =>
{
    options.AddDefaultRepositories(includeAllEntities: true);
});

Configure<AbpDbContextOptions>(options =>
{
    options.UseSqlServer();
});
```

## Create API Scope, API Resource and Swagger Client in IdentityServer

We need to do this in the `MainApp`. We have to update the `IdentityServerDataSeedContributor` in the `MainApp.Domain`.

```cs
private async Task CreateApiScopesAsync()
{
    await CreateApiScopeAsync("MainApp");
    await CreateApiScopeAsync("ProjectService");
}

private async Task CreateApiResourcesAsync()
{
    var commonApiUserClaims = new[]
    {
        "email",
        "email_verified",
        "name",
        "phone_number",
        "phone_number_verified",
        "role"
    };

    await CreateApiResourceAsync("MainApp", commonApiUserClaims);
    await CreateApiResourceAsync("ProjectService", commonApiUserClaims);
}
```

Now lets update the create the swagger client for the new service.

In the `MainApp.DbMigrator` project update the `appsettings.json` with the new swagger client.

```cs
"ProjectService_Swagger": {
    "ClientId": "ProjectService_Swagger",
    "ClientSecret": "1q2w3e*",
    "RootUrl": "{ Your Service url }"
}
```

Update the `commonScopes` in the `CreateClientsAsync` method

```cs
var commonScopes = new[]
{
    "email",
    "openid",
    "profile",
    "role",
    "phone",
    "address",
    "MainApp",
    "ProjectService"
};
```

This will add the newly created scope to all the clients.

Update the `CreateClientsAsync` method to create the swagger client in the `IdentityServerDataSeedContributor` in the `MainApp.Domain`.

```cs
var swaggerClientIdProjectService = configurationSection["ProjectService_Swagger:ClientId"];
if (!swaggerClientIdProjectService.IsNullOrWhiteSpace())
{
    var swaggerRootUrl = configurationSection["ProjectService_Swagger:RootUrl"].TrimEnd('/');

    await CreateClientAsync(
        name: swaggerClientIdProjectService,
        scopes: commonScopes,
        grantTypes: new[] { "authorization_code" },
        secret: configurationSection["ProjectService_Swagger:ClientSecret"]?.Sha256(),
        requireClientSecret: false,
        redirectUri: $"{swaggerRootUrl}/swagger/oauth2-redirect.html",
        corsOrigins: new[] { swaggerRootUrl.RemovePostFix("/") }
    );
}
```

## Run Migrations again for the MainApp

Change directory to `MainApp.DbMigrator` and run the migration project

```bash
dotnet run
```

This will run the `DbMigrator` project. The `DbMigrator` will seed the database with the New Scope, API and Client in our Identity Server.

Once the migration is done lets update the `CorsOrigins` in the IdentityServer.

```json
"App": {
    "SelfUrl": "https://localhost:44373",
    "ClientUrl": "http://localhost:4200",
    "CorsOrigins": "https://*.MainApp.com,http://localhost:4200,https://localhost:44307,https://localhost:44358,https://localhost:44372,{ Project Service url }", // update the entry here
    "RedirectAllowedUrls": "http://localhost:4200,https://localhost:44307"
},
```

## Communicating with the Microservice

Now we have the application running lets see how we can communicate between services.

To communicate with the we need to use the `Client Proxy` [Check docs here](https://docs.abp.io/en/abp/latest/API/Dynamic-CSharp-API-Clients)

### Add the Contract project reference

We need to add `ProjectService.Application.Contracts` project as project reference to `MainApp.HttpApi.Client`

```xml
<ProjectReference Include="..\..\modules\ProjectService\src\ProjectService.Application.Contracts\ProjectService.Application.Contracts.csproj" />
```

Update the `MainAppHttpApiClientModule` dependency and add the `ProjectService` as a client proxy.

```cs
typeof(ProjectServiceApplicationContractsModule)
```

Update the `ConfigureServices` service in the `MainAppHttpApiClientModule.cs` file in the `MainApp.HttpApi.Client` project.

```cs
//Create dynamic client proxies
context.Services.AddHttpClientProxies(
    typeof(ProjectServiceApplicationContractsModule).Assembly,
    "ProjectService"
);
```

Now lets add Remote Service Endpoints to the `appsettings.json` in `MainApp.Web`

```json
"RemoteServices": {
    "Default": {
        "BaseUrl": "https://localhost:44358/"
    },
    "ProjectService": {
        "BaseUrl": "https://localhost:44372/"
    }
}
```

### Update the scope of the Web App

To connect to the project service we need to add the `ProjectService` scope as a scope to the `AddAbpOpenIdConnect` method inside the `ConfigureAuthentication` method in the `MainAppWebModule`

```cs
.AddAbpOpenIdConnect("oidc", options =>
{
    options.Authority = configuration["AuthServer:Authority"];
    options.RequireHttpsMetadata = Convert.ToBoolean(configuration["AuthServer:RequireHttpsMetadata"]);
    options.ResponseType = OpenIdConnectResponseType.CodeIdToken;

    options.ClientId = configuration["AuthServer:ClientId"];
    options.ClientSecret = configuration["AuthServer:ClientSecret"];

    options.SaveTokens = true;
    options.GetClaimsFromUserInfoEndpoint = true;

    options.Scope.Add("role");
    options.Scope.Add("email");
    options.Scope.Add("phone");
    options.Scope.Add("MainApp");
    options.Scope.Add("ProjectService"); // This is for the new project service
});
```

## Create a UI to display the projects

Create a project page to display the project list in the `MainApp.Web`.

Create a `Projects.cshtml`

```html
@page
@model MainApp.Web.Pages.ProjectsModel
<div class="container">
    <H1>List of projects</H1>
    @if(Model.Projects != null && Model.Projects.Count > 0){
        @foreach (var item in Model?.Projects) {
            <div class="card">
                <div class="card-body">
                    <h5 class="card-title">@item.Name</h5>
                </div>
            </div>
        }  
    }
</div>
```

Create a `Projects.cshtml.cs`

```cs
public class ProjectsModel : MainAppPageModel
    {
        private readonly ILogger<ProjectsModel> logger;

        public List<ProjectDto> Projects { get; set; }
        private IProjectAppService projectAppService { get; set; }
        public ProjectsModel(IProjectAppService projectAppService, ILogger<ProjectsModel> logger)
        {
            this.projectAppService = projectAppService;
            this.logger = logger;
            Projects = new List<ProjectDto>();
        }

        public void OnGet()
        {
            try
            {
                var projects = projectAppService.GetListAsync().Result;
                Projects = projects;
            }
            catch (Exception e)
            {
                logger.LogError(e.Message);
            }
        }
    }
```

Lets add the newly created page to the Main menu.

Update the `ConfigureMainMenuAsync` method in the `MainAppMenuContributor.cs` file.

```cs
context.Menu.Items.Insert(
    3,
    new ApplicationMenuItem(
        MainAppMenus.Home,
        l["Projects"],
        "~/Projects",
        icon: "fas fa-list",
        order: 0
    )
);
```

Now lets run the application.

## Running the application

Since we have run 4 services lets init `tye` so that it will be easier.

```bash
tye init
```

This command will create the `tye.yaml` file which will have the project without out ports binding. Update the ports from your solution. Here is the sample `tye.yaml`.

```yaml
name: mainapp
services:
- name: mainapp-web
  project: src/MainApp.Web/MainApp.Web.csproj
  bindings:
  - port: 44343 //update your ports here
    protocol: https
- name: mainapp-identityserver
  project: src/MainApp.IdentityServer/MainApp.IdentityServer.csproj
  bindings:
  - port: 44373 //update your ports here
    protocol: https
- name: mainapp-httpapi-host
  project: src/MainApp.HttpApi.Host/MainApp.HttpApi.Host.csproj
  bindings:
  - port: 44358 //update your ports here
    protocol: https
- name: project-service
  project: modules/ProjectService/src/ProjectService.HttpApi.Host/ProjectService.HttpApi.Host.csproj
  bindings:
  - port: 44372 //update your ports here
    protocol: https
```

Now run the tye command.

```bash
tye run
```

This will run all the projects. Navigate to the `ProjectService` and do the swagger authorization to login and call the project api to create new project.

To View the project visit the `MainApp.Web` project and click `Projects` menu to see the list of the project you just created.
]]></content:encoded>
          </item><item>
          <title>Create content with code in Orchard Core - Part 3</title>
          <link>https://blog.antosubash.com/posts/orchard-core-create-content-with-code</link>
          <guid>https://blog.antosubash.com/posts/orchard-core-create-content-with-code</guid>
          <pubDate>Sat, 27 Nov 2021 00:00:00 GMT</pubDate>
          <description>In this post we will see how to create content types using the code in Orchard Core.</description>
          <content:encoded><![CDATA[## Table of contents

## Intro

In this post we will see how to create content types using the code in Orchard Core. We will see how to create content types with different parts and fields. We will also see how to create content items using the code.

## Create a CMS

```bash
dotnet new occms -n MyCms
```

## Add a module to the cms with part

```bash
dotnet new ocmodulecms --name MyCms.Projects
```

## Create a solution and add the projects

To create a solution

```bash
dotnet new sln -n ContentWithCode
```

To add projects to the solution.

```bash
dotnet sln add .\MyCms\MyCms.csproj
dotnet sln add .\MyCms.Projects\MyCms.Projects.csproj
```

To add Module as a reference to the project

```bash
dotnet add .\MyCms\MyCms.csproj reference .\MyCms.Projects\MyCms.Projects.csproj
```

## Add migration

Create the migrations class `Migrations.cs` file in our module `MyCms.Projects`

```cs
using OrchardCore.ContentManagement.Metadata;
using OrchardCore.ContentManagement.Metadata.Settings;
using OrchardCore.Data.Migration;

namespace MyCms.Projects
{
    public class Migrations : DataMigration
    {
        IContentDefinitionManager _contentDefinitionManager;

        public Migrations(IContentDefinitionManager contentDefinitionManager)
        {
            _contentDefinitionManager = contentDefinitionManager;
        }

        public int Create()
        {
            _contentDefinitionManager.AlterTypeDefinition("Project", type => type
                .Draftable()
                .Versionable()
                .Creatable()
                .Securable()
                .Listable()
                .WithPart("Project")
            );

            _contentDefinitionManager.AlterPartDefinition("Project", part => part
                .WithField("Name", field => field
                    .OfType("TextField")
                    .WithDisplayName("Name")
                )
                .WithField("StartDate", field => field
                    .OfType("DateField")
                    .WithDisplayName("Start date")
                )
                .WithField("Image", field => field
                    .OfType("MediaField")
                    .WithDisplayName("Main image")
                )
                .WithField("Cost", field => field
                    .OfType("NumericField")
                    .WithDisplayName("Cost")
                )
            );

            return 1;
        }
    }
}
```

Update the start up file to add the migration.

```cs
services.AddScoped<IDataMigration,Migrations>();
```

## Create a Headless Orchard CMS

Run the `MyCms` project.

```cs
dotnet run
```

You will see a Setup screen in the `Recipe` dropdown choose the `Headless Site`

![Setup](/assets/posts/orchard/part3/orchardcore3.1.png)

Once the setup is complete then enable the `MyCms.Projects` module.

![Features](/assets/posts/orchard/part3/orchardcore3.2.png)

Go to Features and you will see the list of all the features. Search for "MyCms.Projects" and enable it.

![Enable](/assets/posts/orchard/part3/orchardcore3.3.png)

Once the module is enabled then we can start creating our content.

Go to `Content Items` page you will see a `New Projects` menu now.

![New Projects](/assets/posts/orchard/part3/orchardcore3.4.png)

You will be able to create a new project now.

![Create Projects](/assets/posts/orchard/part3/orchardcore3.6.png)

]]></content:encoded>
          </item><item>
          <title>Authentication using OpenId in React/NextJs App With Orchard Core - Part 2</title>
          <link>https://blog.antosubash.com/posts/orchard-core-openid-nextjs</link>
          <guid>https://blog.antosubash.com/posts/orchard-core-openid-nextjs</guid>
          <pubDate>Thu, 18 Nov 2021 00:00:00 GMT</pubDate>
          <description>In this post we will see how to do authentication using OpenId for a React App using Orchard Core.</description>
          <content:encoded><![CDATA[## Table of contents

## Intro

In this post we will see how to do authentication using OpenId for a React App using Orchard Core.

## Prerequisites

To create the CMS and and a sample content follow the [Getting started](https://blog.antosubash.com/posts/orchard-core-getting-started-p1)

## Create a OpenId Client

Navigate to the `https://localhost:5001/Admin` and login as a admin.

Navigate to `Security -> OpenID Connect -> Scopes -> Add an scope`.

Create two scopes `role` and `openid`.

Navigate to `Security -> OpenID Connect -> Applications -> Add an Application`.

Create a client with

Client id : client1

Display Name : client1

Type : Public client

Flows : Allow Authorization Code Flow

Redirect Uris : <http://localhost:3000>

Consent type: Explicit consent

Allowed scopes: openid, role

Click Save

## Update the CORS policy

Create a new policy to and set is as default. All credentials and any origin, headers and methods.

Update the CORS in CMS `Startup.cs` file under `ConfigureServices` function.

```cs
public void ConfigureServices(IServiceCollection services)
{
    services.AddCors(o => o.AddDefaultPolicy(builder =>
    {
        builder
            .AllowAnyOrigin()
            .AllowAnyMethod()
            .AllowAnyHeader();
    }));
    services.AddOrchardCms();
}
```

## Create a NextJS App

```bash
yarn create next-app --typescript
```

## Add npm packages

```bash
yarn add oidc-client-ts react-oidc-context @apollo/client
```

## Add .env file

```bash
NEXT_PUBLIC_BASE_URL=https://localhost:5001
NEXT_PUBLIC_GRAPHQL_URL=https://localhost:5001/api/graphql
```

## Create login component

Inside the `components` folder create `Login.tsx`

```ts
import React from 'react'
import { useAuth } from 'react-oidc-context';

const Login = () => {
    const auth = useAuth();
    if (auth.isLoading) {
      return <div>Loading...</div>;
    }

    if (auth.error) {
      return <div>Oops... {auth.error.message}</div>;
    }

    if (auth.isAuthenticated) {
      return (
        <div>
          Hello {auth.user?.profile.sub}{" "}
          <button onClick={auth.removeUser}>Log out</button>
        </div>
      );
    }

    return <button onClick={auth.signinRedirect}>Log in</button>;
}

export default Login
```

## Create Languages component

Inside the `components` folder create `Languages.tsx`

```jsx
import React from "react";
import { gql, useQuery } from "@apollo/client";

interface Props {}

const LanguagesQuery = gql`
  query Languages {
    language {
      code
      createdUtc
      displayText
      modifiedUtc
      name
    }
  }
`;

const Languages = (props: Props) => {
  const { loading, error, data } = useQuery(LanguagesQuery);

  if (loading) return <p>Loading...</p>;
  if (error) return <p>Error :(</p>;

  return data.language.map((lang: any) => (
    <div key={lang.code}>
      <p>{lang.name}</p>
    </div>
  ));
};

export default Languages;
```

## Create apollo client

Create a file `apollo-client.ts` inside the `lib` folder.

```ts
import { ApolloClient, createHttpLink, InMemoryCache } from "@apollo/client";
import { setContext } from "@apollo/client/link/context";
import { User } from "oidc-client-ts";

const httpLink = createHttpLink({
  uri: process.env.NEXT_PUBLIC_GRAPHQL_URL,
});

const authLink = setContext((_, { headers }) => {
  // get the authentication token from local storage if it exists
  const oidcStorage = sessionStorage.getItem(
    `oidc.user:${process.env.NEXT_PUBLIC_BASE_URL}:client1`
  );
  const token = User.fromStorageString(oidcStorage!).access_token;
  // return the headers to the context so httpLink can read them
  return {
    headers: {
      ...headers,
      authorization: token ? `Bearer ${token}` : "",
    },
  };
});
const client = new ApolloClient({
  link: authLink.concat(httpLink),
  cache: new InMemoryCache(),
});
export default client;
```

## Update _app.tsx

```ts
import '../styles/globals.css'
import type { AppProps } from 'next/app'
import { AuthProvider } from "react-oidc-context";
import { ApolloProvider } from "@apollo/client";
import client from '../lib/apollo-client';
function MyApp({ Component, pageProps }: AppProps) {
  const oidcConfig = {
    authority: "https://localhost:5001",
    client_id: "client1",
    redirect_uri: "http://localhost:3000",
    response_type: "code",
    scopes: "openid email"
  };
  const onSignin = () => {
    location.href = "/";
  };
  return (
    <AuthProvider {...oidcConfig} onSigninCallback={onSignin}>
      <ApolloProvider client={client}>
        <Component {...pageProps} />
      </ApolloProvider>
    </AuthProvider>
  );
}

export default MyApp
```

### Update the index page

```ts
import type { NextPage } from 'next'
import Login from './../components/Login';
import Languages from './../components/Languages'

const Home: NextPage = () => {
    return (
      <div>
        <Login />
        <Languages></Languages>
      </div>
    ); 
}

export default Home
```

## Run both CMS and Next app

Navigate to the CMS project and run

```bash
dotnet run
```

Navigate to the NextJS project and run

```bash
yarn // To install the npm packages
yarn dev // To run the app
```

Repo : <https://github.com/antosubash/OrchardCoreReactAuth>
]]></content:encoded>
          </item><item>
          <title>Add a new Module to the Tiered ABP App with separate database for the module</title>
          <link>https://blog.antosubash.com/posts/abp-add-new-module-with-seperate-db</link>
          <guid>https://blog.antosubash.com/posts/abp-add-new-module-with-seperate-db</guid>
          <pubDate>Wed, 03 Nov 2021 00:00:00 GMT</pubDate>
          <description>In this post we will see how to develop a modular with tiered abp application. We will add a new module to tiered abp app and then use the separate database to store the modules data and the identity data.</description>
          <content:encoded><![CDATA[
## Table of contents

## Add a new Module to the Tiered ABP App with a separate database for the module

In this post, we will see how to develop a modular with a tiered ABP application. We will add a new module to the tiered ABP app and then use the separate database to store the module's data and identity data.

## Creating the ABP application and running migrations

```bash
abp new MainApp -t app -u mvc --tiered 
```

## Run Migrations

Change directory to src/MainApp.DbMigrator and run the migration project

```bash
dotnet run
```

This will apply the migrations to the DB and we can run the `MainApp.Web` project. This will host the UI and API..

## Add a new Module

Now we will add a new module to our MainApp

```bash
abp add-module ModuleA --new --add-to-solution-file
```

This command will create a new module and add the new module to the solution.

Now you can run all their host and see the API and UI available in the app.

## Add a new Entity to the ModuleA

We will create a new Entity inside the `MainApp.ModuleA.Domain` called `TodoOne`

## 1. Create an [Entity](https://docs.abp.io/en/abp/latest/Entities)

The first step is to create an Entity. Create the Entity in the `MainApp.ModuleA.Domain` project.

```cs
public class TodoOne : Entity<Guid>
{
    public string Content { get; set; }
    public bool IsDone { get; set; }
}
```

## 2. Add Entity to [ef core](https://docs.abp.io/en/abp/latest/Entity-Framework-Core)

Next is to add Entity to the EF Core. we will find the DbContext in the `MainApp.ModuleA.EntityFrameworkCore` project. Add the DbSet to the DbContext

```cs
public DbSet<TodoOne> TodoOnes { get; set; }
```

## 3. Configure Entity in [ef core](https://docs.abp.io/en/abp/latest/Entity-Framework-Core#configurebyconvention-method)

Configuration is done in the `DbContextModelCreatingExtensions` class. This should be available in the `MainApp.ModuleA.EntityFrameworkCore` project

```cs
builder.Entity<TodoOne>(b =>
{
    b.ToTable(options.TablePrefix + "TodoOnes", options.Schema);
    b.ConfigureByConvention(); //auto configure for the base class props
});
```

## 4. Adding Migrations for the ModuleA

Now that the Entity is configured we can add the migrations.

Create `EntityFrameworkCore\ModuleA` folder in the `MainApp.HttpApi.Host` project.

Create a `ModuleAHttpApiHostMigrationsDbContext.cs` file in the `EntityFrameworkCore\ModuleA` folder

```cs
public class ModuleAHttpApiHostMigrationsDbContext : AbpDbContext<ModuleAHttpApiHostMigrationsDbContext>
{
    public ModuleAHttpApiHostMigrationsDbContext(DbContextOptions<ModuleAHttpApiHostMigrationsDbContext> options) : base(options)
    {
    }

    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        base.OnModelCreating(modelBuilder);

        modelBuilder.ConfigureModuleA();
    }
}
```

Create a `ModuleAHttpApiHostMigrationsDbContextFactory.cs` file in the `EntityFrameworkCore\ModuleA` folder

```cs
public class ModuleAHttpApiHostMigrationsDbContextFactory : IDesignTimeDbContextFactory<ModuleAHttpApiHostMigrationsDbContext>
{
    public ModuleAHttpApiHostMigrationsDbContext CreateDbContext(string[] args)
    {
        var configuration = BuildConfiguration();

        var builder = new DbContextOptionsBuilder<ModuleAHttpApiHostMigrationsDbContext>()
            .UseSqlServer(configuration.GetConnectionString("ModuleA"));
        return new ModuleAHttpApiHostMigrationsDbContext(builder.Options);
    }

    private static IConfigurationRoot BuildConfiguration()
    {
        var builder = new ConfigurationBuilder()
            .SetBasePath(Directory.GetCurrentDirectory())
            .AddJsonFile("appsettings.json", optional: false);

        return builder.Build();
    }
}
```

Update the connection string in `appsettings.json` in the `MainApp.HttpApi.Host`

```json
  "ConnectionStrings": {
    "Default": "Server=(LocalDb)\\MSSQLLocalDB;Database=MainApp;Trusted_Connection=True",
    "ModuleA": "Server=(LocalDb)\\MSSQLLocalDB;Database=ModuleA;Trusted_Connection=True",
  },
```

To create migration run this command:

```bash
dotnet ef migrations add created_todoone --context ModuleAHttpApiHostMigrationsDbContext --output-dir Migrations/ModuleA
```

Verify the migrations created in the migrations folder.

To update the database run this command

```bash
dotnet ef database update --context ModuleAHttpApiHostMigrationsDbContext
```

## 5. Create an Entity Dto

Dto are placed in `MainApp.ModuleA.Application.Contracts` project

```cs
public class TodoOneDto : EntityDto<Guid>
{
    public string Content { get; set; }
    public bool IsDone { get; set; }
}
```

## 6. Map Entity to Dto

Abp uses AutoMapper to map Entity to Dto. you can find the `ApplicationAutoMapperProfile` file which is used by the AutoMapper in the `MainApp.ModuleA.Application` project.

```cs
CreateMap<TodoOne, TodoOneDto>();
CreateMap<TodoOneDto, TodoOne>();
```

## 7. Create an [Application Services](https://docs.abp.io/en/abp/latest/Application-Services)

Application services are created in the `MainApp.ModuleA.Application` project

```cs
public class TodoOneAppService : ModuleAAppService
{
    private readonly IRepository<TodoOne, Guid> todoOneRepository;

    public TodoOneAppService(IRepository<TodoOne, Guid> todoOneRepository)
    {
        this.todoOneRepository = todoOneRepository;
    }

    public async Task<List<TodoOneDto>> GetAll()
    {
        return ObjectMapper.Map<List<TodoOne>, List<TodoOneDto>>(await todoOneRepository.GetListAsync());
    }

    public async Task<TodoOneDto> CreateAsync(TodoOneDto todoOneDto)
    {
        var TodoOne = ObjectMapper.Map<TodoOneDto, TodoOne>(todoOneDto);
        var createdTodoOne = await todoOneRepository.InsertAsync(TodoOne);
        return ObjectMapper.Map<TodoOne, TodoOneDto>(createdTodoOne);
    }

    public async Task<TodoOneDto> UpdateAsync(TodoOneDto todoOneDto)
    {
        var TodoOne = ObjectMapper.Map<TodoOneDto, TodoOne>(todoOneDto);
        var createdTodoOne = await todoOneRepository.UpdateAsync(TodoOne);
        return ObjectMapper.Map<TodoOne, TodoOneDto>(createdTodoOne);
    }

    public async Task<bool> DeleteAsync(Guid id)
    {
        var TodoOne = await todoOneRepository.FirstOrDefaultAsync(x=> x.Id == id);
        if(TodoOne != null)
        {
            await todoOneRepository.DeleteAsync(TodoOne);
            return true;
        }
        return false;
    }
}
```

## 8. Update `AddAbpDbContext` method in the `ModuleAEntityFrameworkCoreModule`

```cs
options.AddDefaultRepositories(includeAllEntities: true);
```

## 9. Update the `ConfigureAutoApiControllers` in the `MainAppHttpApiHostModule` in the `MainApp.HttpApi.Host`

```cs
Configure<AbpAspNetCoreMvcOptions>(options =>
            {
                options.ConventionalControllers.Create(typeof(ModuleAApplicationModule).Assembly);
            });
```

Repo: <https://github.com/antosubash/NewModuleWithTieredAbpApp>
]]></content:encoded>
          </item><item>
          <title>Add a new Module to the ABP App</title>
          <link>https://blog.antosubash.com/posts/abp-add-new-module</link>
          <guid>https://blog.antosubash.com/posts/abp-add-new-module</guid>
          <pubDate>Tue, 02 Nov 2021 00:00:00 GMT</pubDate>
          <description>In this post we will see how to develop a modular abp application. We will add a new module to default abp app and then use the same database to store the modules data and the identity data.</description>
          <content:encoded><![CDATA[## Table of contents

## Add a new Module to the ABP App

In this post we will see how to develop a modular abp application. We will add a new module to default abp app and then use the same database to store the modules data and the identity data.

## Creating the abp application and run migrations

```bash
abp new MainApp
```

## Run Migrations

Change directory to src/MainApp.DbMigrator and run the migration project

```bash
dotnet run
```

This will apply the migrations to the db and we can run the `MainApp.Web` project. This will host the UI and API..

## Add a new Module

Now we will add a new module to our MainApp. Navigate to the solution folder of the `MainApp` and run the following command

```bash
abp add-module ModuleA --new --add-to-solution-file
```

This command will create a new module and add the new module to the solution.

Now you can run the `MainApp.Web` and see the Api and UI available in the app.

## Add new Entity to the ModuleA

We will create a new Entity inside the `MainApp.ModuleA.Domain` called `TodoOne`.

## 1. Create an [Entity](https://docs.abp.io/en/abp/latest/Entities)

First step is to create an Entity. Create the Entity in the `MainApp.ModuleA.Domain` project.

```cs
public class TodoOne : Entity<Guid>
{
    public string Content { get; set; }
    public bool IsDone { get; set; }
}
```

## 2. Add Entity to [ef core](https://docs.abp.io/en/abp/latest/Entity-Framework-Core)

Next is to add Entity to the EF Core. you will find the DbContext in the `MainApp.ModuleA.EntityFrameworkCore` project. Add the DbSet to the DbContext

```cs
public DbSet<TodoOne> TodoOnes { get; set; }
```

## 3. Configure Entity in [ef core](https://docs.abp.io/en/abp/latest/Entity-Framework-Core#configurebyconvention-method)

Configuration is done in the `DbContextModelCreatingExtensions` class inside the `ConfigureModuleA` method. This should be available in the `MainApp.ModuleA.EntityFrameworkCore` project. `ConfigureModuleA` is invoked in the `MainAppDbContext`.

```cs
builder.Entity<TodoOne>(b =>
{
    b.ToTable(options.TablePrefix + "TodoOnes", options.Schema);
    b.ConfigureByConvention(); //auto configure for the base class props
});
```

## 4. Adding Migrations

Now the Entity is configured we can add the migrations.

Go the `MainApp.EntityFrameworkCore` project in the terminal and create migrations.

To create migration run this command:

```bash
dotnet ef migrations add created_todoone
```

Verify the migrations created in the migrations folder.

To update the database run this command

```bash
dotnet ef database update
```

## 5. Create a Entity Dto

Dto are placed in `MainApp.ModuleA.Application.Contracts` project

```cs
public class TodoOneDto : EntityDto<Guid>
{
    public string Content { get; set; }
    public bool IsDone { get; set; }
}
```

## 6. Map Entity to Dto

Abp uses AutoMapper to map Entity to Dto. you can find the `ApplicationAutoMapperProfile` file which is used by the AutoMapper in the `MainApp.ModuleA.Application` project.

```cs
CreateMap<TodoOne, TodoOneDto>();
CreateMap<TodoOneDto, TodoOne>();
```

## 7. Create an [Application Services](https://docs.abp.io/en/abp/latest/Application-Services)

Application service are created in the `MainApp.ModuleA.Application` project

```cs
public class TodoOneAppService : ModuleAAppService
{
    private readonly IRepository<TodoOne, Guid> todoOneRepository;

    public TodoOneAppService(IRepository<TodoOne, Guid> todoOneRepository)
    {
        this.todoOneRepository = todoOneRepository;
    }

    public async Task<List<TodoOneDto>> GetAll()
    {
        return ObjectMapper.Map<List<TodoOne>, List<TodoOneDto>>(await todoOneRepository.GetListAsync());
    }

    public async Task<TodoOneDto> CreateAsync(TodoOneDto todoOneDto)
    {
        var TodoOne = ObjectMapper.Map<TodoOneDto, TodoOne>(todoOneDto);
        var createdTodoOne = await todoOneRepository.InsertAsync(TodoOne);
        return ObjectMapper.Map<TodoOne, TodoOneDto>(createdTodoOne);
    }

    public async Task<TodoOneDto> UpdateAsync(TodoOneDto todoOneDto)
    {
        var TodoOne = ObjectMapper.Map<TodoOneDto, TodoOne>(todoOneDto);
        var createdTodoOne = await todoOneRepository.UpdateAsync(TodoOne);
        return ObjectMapper.Map<TodoOne, TodoOneDto>(createdTodoOne);
    }

    public async Task<bool> DeleteAsync(Guid id)
    {
        var TodoOne = await todoOneRepository.FirstOrDefaultAsync(x=> x.Id == id);
        if(TodoOne != null)
        {
            await todoOneRepository.DeleteAsync(TodoOne);
            return true;
        }
        return false;
    }
}
```

## 8. Update `AddAbpDbContext` method in the `ModuleAEntityFrameworkCoreModule`

```cs
options.AddDefaultRepositories(includeAllEntities: true);
```

## 9. Update the `ConfigureServices` in the `ModuleAWebModule` in the `ModuleA.Web`

```cs
Configure<AbpAspNetCoreMvcOptions>(options =>
            {
                options.ConventionalControllers.Create(typeof(ModuleAApplicationModule).Assembly);
            });
```

## 10. Test you api

Run the `MainApp.Web` project and navigate to `https://localhost:<port>/swagger/` you will see the todo apis. You can test your API there.


Repo: <https://github.com/antosubash/NewModuleWithAbp>]]></content:encoded>
          </item><item>
          <title>Orchard core. Getting started - Part 1</title>
          <link>https://blog.antosubash.com/posts/orchard-core-getting-started-p1</link>
          <guid>https://blog.antosubash.com/posts/orchard-core-getting-started-p1</guid>
          <pubDate>Mon, 01 Nov 2021 00:00:00 GMT</pubDate>
          <description>In this post we will see how to get started with the orchard core.</description>
          <content:encoded><![CDATA[## Table of contents

## Intro

In this post we will see how to get started with the orchard core.

## Installing the Orchard CMS templates

Once the .NET Core SDK has been installed, type the following command to install the templates for creating Orchard Core web applications

```bash
dotnet new -i OrchardCore.ProjectTemplates::1.1.0
```

## Creating the CMS

To create the cms run the following command.

```bash
dotnet new occms -n MyCms
```

Change directory into the `MyCms` folder and run the project.

### Running the application

```bash
dotnet watch run
```

Your application should now be running and listening on the following ports:

```bash
Now listening on: https://localhost:5001
Now listening on: http://localhost:5000
Application started. Press Ctrl+C to shut down.
```

Open a browser and navigate to <https://localhost:5001> to display the setup screen.

we will create the website using the `Headless` recipe. The Headless recipe is intended to get you started when using Orchard Core as an API, and Content Management System, with Administrator access to the host.

Complete the setup form and select the `Headless` recipe and SQLite for the database.

Submit the form. A few seconds later you should be looking at a `Headless` Site.

In order to configure it and start writing content you can go to <https://localhost:5001/admin>

## Create content

In the admin page open the `Content => Content Definition => Content Types => Create new type`

In the `New Content Type` page provide the `Display name` and the `Technical Name`.

In the `Add Parts page` Click `Save`.

In the `Edit Content Type` page `Add Parts => Title => Save` then `Fields => IsDone => Boolean Field => Save`

Then save the Content type.

Now visit content items to create a new content.

## Display content

create a `Pages` folder and create `todo.cshtml` file inside the `Pages` folder

```html
@page "/todos"
@inject OrchardCore.IOrchardHelper Orchard
@{
    var todos = await Orchard.GetRecentContentItemsByContentTypeAsync("Todos");
}
@Orchard.ConsoleLog(todos)
<h1>List all Todos</h1>
@foreach (var todo in todos) {
    <p>
        @todo.DisplayText
    </p>
    <p>
        @todo.Content.Todos.IsDone.Value
    </p>
}
```

Now navigate to <https://localhost:5001/todos> to see the created todos.

Sample repo : <https://github.com/antosubash/Anto.OrchardCore.CMS>
]]></content:encoded>
          </item><item>
          <title>Changing theme for your ABP app. Part 10</title>
          <link>https://blog.antosubash.com/posts/abp-change-theme-p10</link>
          <guid>https://blog.antosubash.com/posts/abp-change-theme-p10</guid>
          <pubDate>Tue, 26 Oct 2021 00:00:00 GMT</pubDate>
          <description>In this post we will explore how to change the theme for your ABP application.</description>
          <content:encoded><![CDATA[## Table of contents

## Intro

In this post we will explore how to change the theme for your ABP application..

## Create an abp App and Run Migrations

### Create the App

Run the following command to create the abp app.

```bash
abp new ThemeChange
```

### Run Migrations

change directory to `src/ThemeChange.DbMigrator` and run the migration project

```bash
dotnet run
```

This will create the migrations and seed the data for your project.

## Add the basic theme module to app

Run the following command in your solution folder.

```bash
abp add-module Volo.BasicTheme --with-source-code --add-to-solution-file
```

This will add the basic theme to your solution and download the source for that theme.

Now remove the nuget package reference from the `ThemeChange.Web` project for `Volo.Abp.AspNetCore.Mvc.UI.Theme.Basic`.

Add project reference from to the  `Volo.Abp.AspNetCore.Mvc.UI.Theme.Basic` to the `ThemeChange.Web`.

## Change the bootstrap theme

We are going to use the [Material kit](https://github.com/creativetimofficial/material-kit). It is a free and Open Source UI Kit for Bootstrap 4. Download the minified css from the [assets/css/material-kit.min.css](https://github.com/creativetimofficial/material-kit/blob/master/assets/css/material-kit.min.css) and place it in the `wwwroot/styles/material-kit.min.css` in the `ThemeChange.Web`

### Remove the default bootstrap theme

Update the `ConfigureBundle` method in the `BasicThemeGlobalStyleContributor` in the `Volo.Abp.AspNetCore.Mvc.UI.Theme.Basic` project

```cs
public override void ConfigureBundle(BundleConfigurationContext context)
{
    context.Files.Add("/themes/basic/layout.css");
    context.Files.Remove("/libs/bootstrap/css/bootstrap.css");
}
```

Update the `ConfigureBundles` method in the `ThemeChangeWebModule` in the `ThemeChange.Web` project.

```cs
Configure<AbpBundlingOptions>(options =>
{
    options.StyleBundles.Configure(
        BasicThemeBundles.Styles.Global,
        bundle =>
        {
            bundle.AddFiles("/global-styles.css");
            bundle.AddFiles("/styles/material-kit.min.css");
        }
    );
});
```

## Changing the layout

Layouts are available in the `Themes\basic\Layouts` folder in the `Volo.Abp.AspNetCore.Mvc.UI.Theme.Basic` project

We are going to change the `Account.cshtml` layout. Take a backup of that file.

Here is the updated cshtml. Based on the sample from this [Signin Page](https://github.com/creativetimofficial/material-kit/blob/master/pages/sign-in.html)

```bash
@using Microsoft.Extensions.Localization
@using Microsoft.Extensions.Options
@using Volo.Abp.AspNetCore.MultiTenancy
@using Volo.Abp.AspNetCore.Mvc.UI.Components.LayoutHook
@using Volo.Abp.AspNetCore.Mvc.UI.MultiTenancy.Localization
@using Volo.Abp.AspNetCore.Mvc.UI.Theme.Basic.Bundling
@using Volo.Abp.AspNetCore.Mvc.UI.Theme.Basic.Themes.Basic.Components.MainNavbar
@using Volo.Abp.AspNetCore.Mvc.UI.Theme.Basic.Themes.Basic.Components.PageAlerts
@using Volo.Abp.AspNetCore.Mvc.UI.Theming
@using Volo.Abp.AspNetCore.Mvc.UI.Widgets.Components.WidgetScripts
@using Volo.Abp.AspNetCore.Mvc.UI.Widgets.Components.WidgetStyles
@using Volo.Abp.MultiTenancy
@using Volo.Abp.Localization
@using Volo.Abp.Ui.Branding
@inject IBrandingProvider BrandingProvider
@inject IOptions<AbpMultiTenancyOptions> MultiTenancyOptions
@inject ICurrentTenant CurrentTenant
@inject IStringLocalizer<AbpUiMultiTenancyResource> MultiTenancyStringLocalizer
@inject ITenantResolveResultAccessor TenantResolveResultAccessor

@{
    Layout = null;
    var containerClass = ViewBag.FluidLayout == true ? "container-fluid" : "container"; //TODO: Better and type-safe options
    var rtl = CultureHelper.IsRtl ? "rtl" : string.Empty;
}

<!DOCTYPE html>

<html lang="@CultureInfo.CurrentCulture.Name" dir="@rtl">
<head>
    @await Component.InvokeLayoutHookAsync(LayoutHooks.Head.First, StandardLayouts.Account)

    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">

    <title>@(ViewBag.Title == null ? BrandingProvider.AppName : ViewBag.Title)</title>

    @if (ViewBag.Description != null)
    {
        <meta name="description" content="@(ViewBag.Description as string)" />
    }
    <abp-style-bundle name="@BasicThemeBundles.Styles.Global" />
      <link href="https://fonts.googleapis.com/css?family=Open+Sans:300,400,600,700" rel="stylesheet" />
    @await RenderSectionAsync("styles", false)

    @await Component.InvokeAsync(typeof(WidgetStylesViewComponent))

    @await Component.InvokeLayoutHookAsync(LayoutHooks.Head.Last, StandardLayouts.Account)
</head>
<body class="sign-in-basic">
  <nav class="navbar navbar-expand-lg position-absolute top-0 z-index-3 w-100 shadow-none my-3  navbar-transparent ">
    <div class="container">
      <a class="navbar-brand  text-white " href="/" rel="tooltip" title="Theme Change" data-placement="bottom">
        ThemeChange
      </a>
      <button class="navbar-toggler shadow-none ms-2" type="button" data-bs-toggle="collapse" data-bs-target="#navigation" aria-controls="navigation" aria-expanded="false" aria-label="Toggle navigation">
        <span class="navbar-toggler-icon mt-2">
          <span class="navbar-toggler-bar bar1"></span>
          <span class="navbar-toggler-bar bar2"></span>
          <span class="navbar-toggler-bar bar3"></span>
        </span>
      </button>
      <div class="collapse navbar-collapse w-100 pt-3 pb-2 py-lg-0 ms-lg-12 ps-lg-5" id="navigation">
      </div>
    </div>
  </nav>
  <div class="page-header align-items-start min-vh-100" style="background-image: url('https://images.unsplash.com/photo-1497294815431-9365093b7331?ixlib=rb-1.2.1&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=1950&q=80');" loading="lazy">
    <span class="mask bg-gradient-dark opacity-6"></span>
    <div class="container my-auto">
      <div class="row">
        <div class="col-lg-4 col-md-8 col-12 mx-auto">
          <div class="card z-index-0 fadeIn3 fadeInBottom">
            <div class="card-header p-0 position-relative mt-n4 mx-3 z-index-2">
              <div class="bg-gradient-primary shadow-primary border-radius-lg py-3 pe-1">
                <h4 class="text-white font-weight-bolder text-center mt-2 mb-0">Sign in</h4>
                <div class="row mt-3">
                  <div class="col-2 text-center ms-auto">
                    <a class="btn btn-link px-3" href="javascript:;">
                      <i class="fa fa-facebook text-white text-lg"></i>
                    </a>
                  </div>
                  <div class="col-2 text-center px-1">
                    <a class="btn btn-link px-3" href="javascript:;">
                      <i class="fa fa-github text-white text-lg"></i>
                    </a>
                  </div>
                  <div class="col-2 text-center me-auto">
                    <a class="btn btn-link px-3" href="javascript:;">
                      <i class="fa fa-google text-white text-lg"></i>
                    </a>
                  </div>
                </div>
              </div>
            </div>
            <div class="card-body">
                @if (MultiTenancyOptions.Value.IsEnabled &&
                  (TenantResolveResultAccessor.Result?.AppliedResolvers?.Contains(CookieTenantResolveContributor.ContributorName) == true ||
                   TenantResolveResultAccessor.Result?.AppliedResolvers?.Contains(QueryStringTenantResolveContributor.ContributorName) == true))
                {
                    <div class="card shadow-sm rounded mb-3">
                        <div class="card-body px-5">
                            <div class="row">
                                <div class="col">
                                    <span style="font-size: .8em;" class="text-uppercase text-muted">@MultiTenancyStringLocalizer["Tenant"]</span><br />
                                    <h6 class="m-0 d-inline-block">
                                        @if (CurrentTenant.Id == null)
                                        {
                                            <span>
                                                @MultiTenancyStringLocalizer["NotSelected"]
                                            </span>
                                        }
                                        else
                                        {
                                            <strong>@(CurrentTenant.Name ?? CurrentTenant.Id.Value.ToString())</strong>
                                        }
                                    </h6>
                                </div>
                                <div class="col-auto">
                                    <a id="AbpTenantSwitchLink" href="javascript:;" class="btn btn-sm mt-3 btn-outline-primary">@MultiTenancyStringLocalizer["Switch"]</a>
                                </div>
                            </div>
                        </div>
                    </div>
                }
                @(await Component.InvokeAsync<PageAlertsViewComponent>())
                @await Component.InvokeLayoutHookAsync(LayoutHooks.PageContent.First, StandardLayouts.Account)
                @RenderBody()
                @await Component.InvokeLayoutHookAsync(LayoutHooks.PageContent.Last, StandardLayouts.Account)
            </div>
          </div>
        </div>
      </div>
    </div>
    <footer class="footer position-absolute bottom-2 py-2 w-100">
      <div class="container">
        <div class="row align-items-center justify-content-lg-between">
          <div class="col-12 col-md-6 my-auto">
            <div class="copyright text-center text-sm text-white text-lg-start">
              Â© <script>
                document.write(new Date().getFullYear())
              </script>,
              made with <i class="fa fa-heart" aria-hidden="true"></i> by
              <a href="https://www.creative-tim.com" class="font-weight-bold text-white" target="_blank">Creative Tim</a>
              for a better web.
            </div>
          </div>
          <div class="col-12 col-md-6">
            <ul class="nav nav-footer justify-content-center justify-content-lg-end">
            </ul>
          </div>
        </div>
      </div>
    </footer>
  </div>
    <abp-script-bundle name="@BasicThemeBundles.Scripts.Global" />
    <script src="~/Abp/ApplicationConfigurationScript"></script>
    <script src="~/Abp/ServiceProxyScript"></script>

    @await RenderSectionAsync("scripts", false)
    @await Component.InvokeAsync(typeof(WidgetScriptsViewComponent))
    @await Component.InvokeLayoutHookAsync(LayoutHooks.Body.Last, StandardLayouts.Account)
</body>
</html>
```

Repo Link: <https://github.com/antosubash/ThemeChange>
]]></content:encoded>
          </item><item>
          <title>Deploy ABP Framework dotnet core tiered app to docker swarm. Part 9</title>
          <link>https://blog.antosubash.com/posts/abp-deploy-with-docker</link>
          <guid>https://blog.antosubash.com/posts/abp-deploy-with-docker</guid>
          <pubDate>Tue, 28 Sep 2021 00:00:00 GMT</pubDate>
          <description>In this post we will see how to deploy your dotnet core app with docker container.</description>
          <content:encoded><![CDATA[## Table of contents

## Intro

In this post we will see how to deploy your dotnet core app with docker container.

## Create ABP Tired application

```bash
abp new AbpDocker -t app -u mvc --tiered -dbms PostgreSQL
```

**Once the app is created update the connection string in all the project and run the `DbMigration` project to setup the migrations and database seeding.**

## Create a same site cookies extension

you can find the code for that here: <https://community.abp.io/articles/patch-for-chrome-login-issue-identityserver4-samesite-cookie-problem-weypwp3n>

Here is the code

```cs
public static class SameSiteCookiesServiceCollectionExtensions
{
    public static IServiceCollection AddSameSiteCookiePolicy(this IServiceCollection services)
    {
        services.Configure<CookiePolicyOptions>(options =>
        {
            options.MinimumSameSitePolicy = SameSiteMode.Lax;
            options.OnAppendCookie = cookieContext =>
                CheckSameSite(cookieContext.Context, cookieContext.CookieOptions);
            options.OnDeleteCookie = cookieContext =>
                CheckSameSite(cookieContext.Context, cookieContext.CookieOptions);
        });

        return services;
    }

    private static void CheckSameSite(HttpContext httpContext, CookieOptions options)
    {
        if (options.SameSite == SameSiteMode.None)
        {
            var userAgent = httpContext.Request.Headers["User-Agent"].ToString();
            if (!httpContext.Request.IsHttps || DisallowsSameSiteNone(userAgent))
            {
                // For .NET Core < 3.1 set SameSite = (SameSiteMode)(-1)
                options.SameSite = SameSiteMode.Lax;
            }
        }
    }

    private static bool DisallowsSameSiteNone(string userAgent)
    {
        // Cover all iOS based browsers here. This includes:
        // - Safari on iOS 12 for iPhone, iPod Touch, iPad
        // - WkWebview on iOS 12 for iPhone, iPod Touch, iPad
        // - Chrome on iOS 12 for iPhone, iPod Touch, iPad
        // All of which are broken by SameSite=None, because they use the iOS networking stack
        if (userAgent.Contains("CPU iPhone OS 12") || userAgent.Contains("iPad; CPU OS 12"))
        {
            return true;
        }

        // Cover Mac OS X based browsers that use the Mac OS networking stack. This includes:
        // - Safari on Mac OS X.
        // This does not include:
        // - Chrome on Mac OS X
        // Because they do not use the Mac OS networking stack.
        if (userAgent.Contains("Macintosh; Intel Mac OS X 10_14") &&
            userAgent.Contains("Version/") && userAgent.Contains("Safari"))
        {
            return true;
        }

        // Cover Chrome 50-69, because some versions are broken by SameSite=None,
        // and none in this range require it.
        // Note: this covers some pre-Chromium Edge versions,
        // but pre-Chromium Edge does not require SameSite=None.
        if (userAgent.Contains("Chrome/5") || userAgent.Contains("Chrome/6"))
        {
            return true;
        }

        return false;
    }
}
```

Add the following line to `ConfigureServices()` method in all 3 projects.

```cs
context.Services.AddSameSiteCookiePolicy();
```

Go to `OnApplicationInitialization()` method in AcmeBookStoreWebModule.cs add `app.UseCookiePolicy();` in all 3 projects.

```cs
app.UseCookiePolicy(); // added this, Before UseAuthentication or anything else that writes cookies.
```

## Create a new client for the production app

Update the `appsettings.json` from the `DbMigrator` to add the new client.

```json
"AbpDocker_Web_Docker": {
  "ClientId": "AbpDocker_Web_Docker",
  "ClientSecret": "1q2w3e*",
  "RootUrl": "http://host.docker.internal:9005"
},
```

Update the `IdentityServerDataSeedContributor` in the `Domain` project and add the new client to the identity server.

```cs
//webDockerClient Client
var webDockerClientId = configurationSection["AbpDocker_Web_Docker:ClientId"];
if (!webClientId.IsNullOrWhiteSpace())
{
    var webClientRootUrl = configurationSection["AbpDocker_Web_Docker:RootUrl"].EnsureEndsWith('/');

    await CreateClientAsync(
        name: webDockerClientId,
        scopes: commonScopes,
        grantTypes: new[] { "hybrid" },
        secret: (configurationSection["AbpDocker_Web_Docker:ClientSecret"] ?? "1q2w3e*").Sha256(),
        redirectUri: $"{webClientRootUrl}signin-oidc",
        postLogoutRedirectUri: $"{webClientRootUrl}signout-callback-oidc",
        frontChannelLogoutUri: $"{webClientRootUrl}Account/FrontChannelLogout",
        corsOrigins: new[] { webClientRootUrl.RemovePostFix("/") }
    );
}
```

Run the `DbMigrator` project again to see the new client.

## Create production config

Create the `appsettings.Production.json` in all the three projects.

### HttpApi.Host

```json
{
  "App": {
    "CorsOrigins": "https://*.AbpDocker.com"
  },
  "ConnectionStrings": {
    "Default": "Host=host.docker.internal;Port=5432;Database=AbpDocker;User ID=postgres;Password=postgres;"
  },
  "Redis": {
    "Configuration": "host.docker.internal"
  },
  "AuthServer": {
    "Authority": "http://host.docker.internal:9006",
    "RequireHttpsMetadata": "false",
    "SwaggerClientId": "AbpDocker_Swagger",
    "SwaggerClientSecret": "1q2w3e*"
  },
  "StringEncryption": {
    "DefaultPassPhrase": "WBN0szwYr7wL8Dou"
  }
}
```

### IdentityServer

```json
{
  "App": {
    "SelfUrl": "http://host.docker.internal:9006",
    "ClientUrl": "http://localhost:4200",
    "CorsOrigins": "https://*.AbpDocker.com,http://localhost:4200,https://localhost:44307,https://localhost:44375,http://host.docker.internal:9006,http://host.docker.internal:9005,http://host.docker.internal:9007",
    "RedirectAllowedUrls": "http://localhost:4200,https://localhost:44307,http://host.docker.internal:9006,http://host.docker.internal:9005,http://host.docker.internal:9007"
  },
  "ConnectionStrings": {
    "Default": "Host=host.docker.internal;Port=5432;Database=AbpDocker;User ID=postgres;Password=postgres;"
  },
  "Redis": {
    "Configuration": "host.docker.internal"
  }
}
```

### Web

```json
{
  "App": {
    "SelfUrl": "http://host.docker.internal:9005"
  },
  "RemoteServices": {
    "Default": {
      "BaseUrl": "http://host.docker.internal:9007/"
    }
  },
  "Redis": {
    "Configuration": "host.docker.internal"
  },
  "AuthServer": {
    "Authority": "http://host.docker.internal:9006",
    "RequireHttpsMetadata": "false",
    "ClientId": "AbpDocker_Web_Docker",
    "ClientSecret": "1q2w3e*"
  }
}
```

## Add docker support

Do the following in all 3 projects.

- `Right Click -> Add -> Docker Support`

  This will add `Docker` file into the project.

- `Right Click -> Add -> Container Orchestrator Support`

  This will add the docker file to the `docker-compose.yml`

Add port mapping to the services to the expose the services.

Final `docker-compose.yml` will look like this.

```yml
version: "3.4"

services:
  web:
    image: abpdockerweb
    ports:
      - 9005:80
    build:
      context: .
      dockerfile: src/AbpDocker.Web/Dockerfile

  identityserver:
    image: abpdockeridentityserver
    ports:
      - 9006:80
    build:
      context: .
      dockerfile: src/AbpDocker.IdentityServer/Dockerfile

  httpapi:
    image: abpdockerhttpapihost
    ports:
      - 9007:80
    build:
      context: .
      dockerfile: src/AbpDocker.HttpApi.Host/Dockerfile
```

## Build docker containers

Navigate to the directory where the `docker-compose.yml` file is present and then run the following command.

```bash
docker-compose build
```

## Deploy the docker stack

```bash
docker stack deploy -c .\docker-compose.yml abpdocker
```

## Run the app

Visit the web app in <http://host.docker.internal:9005/>

Visit the identity server in <http://host.docker.internal:9006/>

Visit the api in <http://host.docker.internal:9007/>

Repo: <https://github.com/antosubash/AbpWithDocker>
]]></content:encoded>
          </item><item>
          <title>Centralized logging for .net core ABP microservices app using Seq. Part 8</title>
          <link>https://blog.antosubash.com/posts/abp-central-application-logging-with-seq</link>
          <guid>https://blog.antosubash.com/posts/abp-central-application-logging-with-seq</guid>
          <pubDate>Sun, 26 Sep 2021 00:00:00 GMT</pubDate>
          <description>In this post we will see how to implement a central logging system for your ABP app using Seq.</description>
          <content:encoded><![CDATA[## Table of contents

## Intro

In this post we will see how to implement a central logging system for your ABP app using Seq.

## Deploy the Seq dockers container

### Enable swarm mode

```bash
docker swarm init
```

Create the docker-compose file `seq_stack.yaml`

```yaml
version: "3.2"

services:
  seq:
    image: datalust/seq
    ports:
      - 8003:80
      - 5341:5341
    volumes:
      - D:\docker\data\seq:/data
    environment:
      ACCEPT_EULA: "Y"
```

### To deploy the stack

```bash
docker stack deploy -c seq_stack.yaml seq
```

This will deploy the seq docker container.

## Create ABP Tired application

```bash
abp new SeqWithAbp -t app -u mvc --tiered
```

Once the app is created run the `DbMigration` project to setup the migrations and database seeding.

## Install Seq Sink in the projects

Install the `Serilog.Sinks.Seq` nuget package to the following projects.

- SeqWithAbp.HttpApi.Host
- SeqWithAbp.IdentityServer
- SeqWithAbp.Web

Update the `LoggerConfiguration` in the `Program.cs` with the seq endpoint in all the projects.

```cs
.WriteTo.Async(c => c.File("Logs/logs.txt"))
.WriteTo.Seq("http://localhost:5341")
```

This will post all the logs to the seq.

Sample Repo : <https://github.com/antosubash/SeqWithAbp>
]]></content:encoded>
          </item><item>
          <title>Extend Tenant management and add custom host to your ABP App. Part 7</title>
          <link>https://blog.antosubash.com/posts/abp-extend-tenant-with-custom-host</link>
          <guid>https://blog.antosubash.com/posts/abp-extend-tenant-with-custom-host</guid>
          <pubDate>Sat, 25 Sep 2021 00:00:00 GMT</pubDate>
          <description>In this post we will see how to extent the tenant entity and Add a custom tenant resolver for your ABP app.</description>
          <content:encoded><![CDATA[## Table of contents

## Intro

In this post we will see how to extent the tenant entity and Add a custom tenant resolver for your ABP app.

## Add test domain in the host file

In windows the host file is located in `C:\Windows\System32\drivers\etc\hosts`. Open the file with the Admin privilege to update the below entry.

```bash
127.0.0.1       test1.local
127.0.0.1       test2.local
127.0.0.1       test3.local
```

## Create an abp App and Run Migrations

### Create the App

Run the following command to create the abp app.

```bash
abp new CustomHost
```

### Run Migrations

change directory to src/CustomHost.DbMigrator and run the migration project

```bash
dotnet run
```

This will create the migrations and seed the data for your project.

## Extend Tenant Entity

### Configure extra properties

Create the Constant file in the `Domain.Shared` project.

```cs
public static class Constant
{
    public const string Host = "Host";
}
```

In the `Domain.Shared` project update the `CustomHostModuleExtensionConfigurator` file inside the `ConfigureExtraProperties` methods with the following.

```cs
ObjectExtensionManager.Instance.Modules()
        .ConfigureTenantManagement(tenantConfig =>
        {
            tenantConfig.ConfigureTenant(tenant =>
            {
                tenant.AddOrUpdateProperty<string>(Constant.Host);
            });
        });
```

### Configure ef core

In the `EntityFrameworkCore` project update the `CustomHostEfCoreEntityExtensionMappings` file inside the `Configure` method. Update the `OneTimeRunner.Run` with the following

```cs
ObjectExtensionManager.Instance
    .MapEfCoreProperty<Tenant, string>(Constant.Host);
```

### Add Migrations

Navigate to the `EntityFrameworkCore`.

```bash
cd .\src\CustomHost.EntityFrameworkCore\
```

Add migrations

```bash
dotnet ef migrations add "update_tenant_with_host"
```

Apply the migrations

```bash
dotnet ef database update
```

## Add a custom Tenant Repo

### Create a Custom Repo Interface in the `Domain` project

```cs
public interface ICustomTenantRepository : IBasicRepository<Tenant, Guid>
{
    Task<Tenant> GetTenantByHost(string host, CancellationToken cancellationToken = default);
}
```

## Implement the custom tenant repo in the `EntityFrameworkCore` project

```cs
public class CustomTenantRepository : EfCoreRepository<TenantManagementDbContext, Tenant, Guid>, ICustomTenantRepository
{
    public CustomTenantRepository(IDbContextProvider<TenantManagementDbContext> dbContextProvider) : base(dbContextProvider)
    {
    }

    public async Task<Tenant> GetTenantByHost(string host, CancellationToken cancellationToken = default)
    {
        var context = await GetDbContextAsync();
        var tenant =  context.Tenants.Where(u => EF.Property<string>(u, "Host") == host);
        return await tenant.FirstOrDefaultAsync(cancellationToken: cancellationToken);
    }
}
```

### Add the custom Repo to the DbContext

```cs
options.AddRepository<Tenant, CustomTenantRepository>();
```

## Implement Host Tenant Resolve Contributor

Create a file called `HostTenantResolveContributor` in the Domain Project

```cs
public class HostTenantResolveContributor : TenantResolveContributorBase
{
    public override async Task ResolveAsync(ITenantResolveContext context)
    {
        var currentContextAccessor = context.ServiceProvider.GetRequiredService<IHttpContextAccessor>();
        var tenantRepository = context.ServiceProvider.GetRequiredService<ICustomTenantRepository>();

        var host = currentContextAccessor?.HttpContext?.Request.Host.Host;
        if (tenantRepository != null)
        {
            var tenant = await tenantRepository.GetTenantByHost(host);

            if (tenant != null)
            {
                context.TenantIdOrName = tenant.Name;
            }
        }
    }

    public override string Name => "Host";
}
```

## Configure the `AbpTenantResolveOptions` in the `Web` project at `ConfigureServices` method

```cs
Configure<AbpTenantResolveOptions>(options =>
{
    options.TenantResolvers.Clear();
    options.TenantResolvers.Add(new HostTenantResolveContributor());
});
```

## Update the `CustomHostBrandingProvider` in the `Web` project to display the current tenant name.

```cs
[Dependency(ReplaceServices = true)]
public class CustomHostBrandingProvider : DefaultBrandingProvider
{
    private readonly ICurrentTenant _currentTenant;
    public override string AppName => _currentTenant.Name ?? "CustomHost";

    public CustomHostBrandingProvider(ICurrentTenant currentTenant)
    {
        _currentTenant = currentTenant;
    }
}
```

This will display the current tenant name in the home page.

Now create the new tenant and set the host name and use that host name to login to the app.

GitHub Repo : <https://github.com/antosubash/TenantWithCustomHost>
]]></content:encoded>
          </item><item>
          <title>Add profile picture to User Entity in ABP app using BlobStore and Minio. Part 6</title>
          <link>https://blog.antosubash.com/posts/abp-extend-user-entity-with-profile-picture</link>
          <guid>https://blog.antosubash.com/posts/abp-extend-user-entity-with-profile-picture</guid>
          <pubDate>Sun, 15 Aug 2021 00:00:00 GMT</pubDate>
          <description>In this post we will implement the profile picture upload for the ABP app using BlobStore and Minio.</description>
          <content:encoded><![CDATA[## Table of contents

## Intro

In this post we will implement the profile picture upload for the ABP app using BlobStore and Minio.

## Create a new project

```bash
abp new ProfilePictureSample
```

## Create a container

Create the container in `Domain` project.

Install `Volo.Abp.BlobStoring` NuGet package to your `Domain` project

```cs
[BlobContainerName("profile-picture")]
public class ProfilePictureContainer
{
}
```

## Configure Minio

Install `Volo.Abp.BlobStoring.Minio` NuGet package to your `Web` and add `[DependsOn(typeof(AbpBlobStoringMinioModule))]` to the `Web` Module

Configuration is done in the `ConfigureServices` method of your module class

```cs
Configure<AbpBlobStoringOptions>(options =>
{
    options.Containers.ConfigureDefault(container =>
    {
        container.UseMinio(minio =>
        {
            minio.EndPoint = "localhost:9900"; // your minio endPoint
            minio.AccessKey = "AKIAIOSFODNN7EXAMPLE"; // your minio accessKey
            minio.SecretKey = "wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY"; // your minio secretKey
            minio.BucketName = "profile-picture"; // your minio bucketName
        });
    });
});
```

## Extend User Entity

### Configure extra properties

Create the Constant file in the `Domain.Shared` project.

```cs
public static class ProfilePictureConsts
{
    public const string ProfilePictureId = "ProfilePictureId";
}
```

In the `Domain.Shared` project update the `ProfilePictureSampleModuleExtensionConfigurator` file inside the `ConfigureExtraProperties` methods with the following.

```cs
ObjectExtensionManager.Instance.Modules()
    .ConfigureIdentity(identity =>
    {
        identity.ConfigureUser(user =>
        {
            user.AddOrUpdateProperty<Guid>(ProfilePictureConsts.ProfilePictureId);
        });
    });
```

### Configure ef core

In the `EntityFrameworkCore` project update the `ProfilePictureSampleEfCoreEntityExtensionMappings` file inside the `Configure` method. Update the `OneTimeRunner.Run` with the following

```cs
ObjectExtensionManager.Instance
    .MapEfCoreProperty<IdentityUser, Guid>(ProfilePictureConsts.ProfilePictureId);
```

### Add Migrations

Navigate to the `EntityFrameworkCore`.

```bash
cd .\src\ProfilePictureSample.EntityFrameworkCore\
```

Add migrations

```bash
dotnet ef migrations add "update_user"
```

Apply the migrations

```bash
dotnet ef database update
```

## Create the AppService

Create a AppService to upload and view the profile picture.

```cs
[Authorize]
public class ProfilePictureAppService : ProfilePictureSampleAppService
{
    private readonly IBlobContainer<ProfilePictureContainer> _blobContainer;
    private readonly IRepository<IdentityUser, Guid> _repository;

    public ProfilePictureAppService(IBlobContainer<ProfilePictureContainer> blobContainer, IRepository<IdentityUser, Guid> repository)
    {
        _blobContainer = blobContainer;
        _repository = repository;
    }

    public virtual async Task<Guid> UploadAsync(IFormFile file)
    {
        await using var memoryStream = new MemoryStream();
        await file.CopyToAsync(memoryStream).ConfigureAwait(false);
        if (CurrentUser.Id == null)
        {
            return Guid.Empty;
        }

        var user = await _repository.GetAsync(CurrentUser.Id.Value).ConfigureAwait(false);
        var pictureId = user.GetProperty<Guid>(ProfilePictureConsts.ProfilePictureId);

        if (pictureId == Guid.Empty)
        {
            pictureId = Guid.NewGuid();
        }
        var id = pictureId.ToString();
        if (await _blobContainer.ExistsAsync(id).ConfigureAwait(false))
        {
            await _blobContainer.DeleteAsync(id).ConfigureAwait(false);
        }
        await _blobContainer.SaveAsync(id, memoryStream.ToArray()).ConfigureAwait(false);
        user.SetProperty(ProfilePictureConsts.ProfilePictureId, pictureId);
        await _repository.UpdateAsync(user).ConfigureAwait(false);
        return pictureId;
    }

    public async Task<FileResult> GetAsync()
    {
        if (CurrentUser.Id == null)
        {
            throw new FileNotFoundException();
        }

        var user = await _repository.GetAsync(CurrentUser.Id.Value).ConfigureAwait(false);
        var pictureId = user.GetProperty<Guid>(ProfilePictureConsts.ProfilePictureId);
        if (pictureId == default)
        {
            throw new FileNotFoundException();
        }

        var profilePicture = await _blobContainer.GetAllBytesOrNullAsync(pictureId.ToString()).ConfigureAwait(false);
        return new FileContentResult(profilePicture, "image/jpeg");

    }
}
```

## Repo [Link](https://github.com/antosubash/AbpProfilePictureSample)
]]></content:encoded>
          </item><item>
          <title>dotnet core large file upload with resume using tus and react/nextjs</title>
          <link>https://blog.antosubash.com/posts/dotnet-and-react-nextjs-large-file-upload-with-tus</link>
          <guid>https://blog.antosubash.com/posts/dotnet-and-react-nextjs-large-file-upload-with-tus</guid>
          <pubDate>Thu, 22 Jul 2021 00:00:00 GMT</pubDate>
          <description>In this post you will see how to upload large files with resume using tus. We will use dotnet core for the backend and nextjs for the frontend</description>
          <content:encoded><![CDATA[## Table of contents

## Large file upload with dotnet and react with tus

In this post we will see how to do large file upload in chunks with resume capabilities in dotnet core as a backend and react/nextjs as frontend.

## dotnet project

### Create the .net project using this following command

```bash
dotnet new webapp -n FileUpload -o .
```

### Add tusdotnet nuget package

```bash
dotnet add package tusdotnet --version 2.4.0
```

### Enable Cors

Update the `ConfigureServices`

```bash
services.AddCors();
```

Update `Configure` method

```bash
app.UseCors(builder => builder
        .AllowAnyHeader()
        .AllowAnyMethod()
        .AllowAnyOrigin()
        .WithExposedHeaders(CorsHelper.GetExposedHeaders()));
```

### Configure MaxRequestBodySize

Update `Configure` method and make sure this is the first pipeline request.

```cs
app.Use((context, next) =>
{
    // Default limit was changed some time ago. Should work by setting MaxRequestBodySize to null using ConfigureKestrel but this does not seem to work for IISExpress.
    // Source: https://github.com/aspnet/Announcements/issues/267
    context.Features.Get<IHttpMaxRequestBodySizeFeature>().MaxRequestBodySize = null;
    return next.Invoke();
});
```

### Configure tus

Update `Configure` method

```cs
app.UseTus(httpContext => new DefaultTusConfiguration
{
    Store = new TusDiskStore(@"C:\tusfiles\"),
    UrlPath = "/files",
    Events = new Events
    {
        OnFileCompleteAsync = async eventContext =>
        {
            // eventContext.FileId is the id of the file that was uploaded.
            // eventContext.Store is the data store that was used (in this case an instance of the TusDiskStore)

            // A normal use case here would be to read the file and do some processing on it.
            ITusFile file = await eventContext.GetFileAsync();
            var result = await DoSomeProcessing(file, eventContext.CancellationToken).ConfigureAwait(false);

            if (!result)
            {
                //throw new MyProcessingException("Something went wrong during processing");
            }
        }
    }
});
```

Make sure to put this before `UseRouting` and `UseAuthorization`

## Nextjs App

Create next app

```bash
yarn create next-app --typescript
```

Add tus package

```bash
yarn add tus-js-client
```

Create file upload component

```js
import React from "react";
import { Upload } from "tus-js-client";
interface Props {}

const FileUpload = (props: Props) => {
  const onFileChange = (e: any) => {
    var file = e.target.files[0];
    const upload = new Upload(file, {
      endpoint: "https://localhost:5001/files",
      retryDelays: [0, 1000, 3000, 5000],
      metadata: {
        filename: file.name,
        filetype: file.type,
      },
      onError: function (error) {
        console.log("Failed because: " + error);
      },
      onProgress: function (bytesUploaded, bytesTotal) {
        var percentage = ((bytesUploaded / bytesTotal) * 100).toFixed(2);
        console.log(bytesUploaded, bytesTotal, percentage + "%");
      },
      onSuccess: function () {
        console.log("Download %s from %s", upload.file.name, upload.url);
      },
    });

    // Check if there are any previous uploads to continue.
    upload.findPreviousUploads().then(function (previousUploads) {
      // Found previous uploads so we select the first one.
      if (previousUploads.length) {
        upload.resumeFromPreviousUpload(previousUploads[0]);
      }

      // Start the upload
      upload.start();
    });
  };
  return (
    <div className="text-center text-2xl p-6">
      <input type="file" name="file" id="" onChange={onFileChange} />
    </div>
  );
};

export default FileUpload;
```

Add the component to the page.

```html
<FileUpload></FileUpload>
```

Github Repo: <https://github.com/antosubash/LargeFileUploadSample>
]]></content:encoded>
          </item><item>
          <title>dotnet file upload with ABP Blob store and Minio</title>
          <link>https://blog.antosubash.com/posts/dotnet-file-upload-with-abp</link>
          <guid>https://blog.antosubash.com/posts/dotnet-file-upload-with-abp</guid>
          <pubDate>Sat, 10 Jul 2021 00:00:00 GMT</pubDate>
          <description>In this post we will implement file upload using the ABP blob store and Minio</description>
          <content:encoded><![CDATA[## Table of contents

## Intro

In this post we will implement file upload using the ABP blob store and Minio

## Create a new project

```bash
abp new FileUpload
```

## Create a container

Create the container in `Domain` project.

Install `Volo.Abp.BlobStoring` NuGet package to your `Domain` project

```cs
[BlobContainerName("document")]
public class DocumentContainer
{
}
```

## Create the Entity and Entity Dto

Create the Entity in `Domain` project.

```cs
public class Document : FullAuditedAggregateRoot<Guid>, IMultiTenant
{
    public long FileSize { get; set; }

    public string MimeType { get; set; }

    public Guid? TenantId { get; set; }

    protected Document()
    {
    }

    public Document(
        Guid id,
        long fileSize,
        string mimeType,
        Guid? tenantId
    ) : base(id)
    {
        FileSize = fileSize;
        MimeType = mimeType;
        TenantId = tenantId;
    }
}
```

Create EntityDto in `Contracts` project

```cs
public class DocumentDto : EntityDto<Guid>
{
    public long FileSize { get; set; }

    public string FileUrl { get; set; }

    public string MimeType { get; set; }
}
```

Add mapping for the Entity and Dto in the `ApplicationAutoMapperProfile` class in the `Application` project

```cs
CreateMap<Document, DocumentDto>().ReverseMap();
```

## Add entity to the DBContext

Add DbSet

```cs
public DbSet<Document> Documents { get; set; }
```

Configure Ef core

```cs
builder.Entity<Document>(b =>
{
    b.ToTable(FileUploadConsts.DbTablePrefix + "Document", FileUploadConsts.DbSchema);
    b.ConfigureByConvention();
});
```

## Add migration and update the database

To create ef migration

```bash
dotnet ef migrations add "added_documents"
```

To update the database

```bash
dotnet ef database update
```

## Configure Minio

Install `Volo.Abp.BlobStoring.Minio` NuGet package to your `Web` and add `[DependsOn(typeof(AbpBlobStoringMinioModule))]` to the `Web` Module

Configuration is done in the `ConfigureServices` method of your module class

```cs
Configure<AbpBlobStoringOptions>(options =>
{
    options.Containers.ConfigureDefault(container =>
    {
        container.UseMinio(minio =>
        {
            minio.EndPoint = "localhost:9900"; // your minio endPoint
            minio.AccessKey = "AKIAIOSFODNN7EXAMPLE"; // your minio accessKey
            minio.SecretKey = "wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY"; // your minio secretKey
            minio.BucketName = "test1"; // your minio bucketName
        });
    });
});
```

## Create Document AppService

The app service will have 2 methods one is to upload the files and another one is to view the files.

```cs
public class DocumentAppService : FileUploadAppService
{
    private readonly IBlobContainer<DocumentContainer> _blobContainer;
    private readonly IRepository<Document, Guid> _repository;
    public DocumentAppService(IRepository<Document, Guid> repository, IBlobContainer<DocumentContainer> blobContainer)
    {
        _repository = repository;
        _blobContainer = blobContainer;
    }

    public async Task<List<DocumentDto>> Upload([FromForm] List<IFormFile> files)
    {
        var output = new List<DocumentDto>();
        foreach (var file in files)
        {
            using var memoryStream = new MemoryStream();
            await file.CopyToAsync(memoryStream).ConfigureAwait(false);
            var id = Guid.NewGuid();
            var newFile = new Document(id, file.Length, file.ContentType, CurrentTenant.Id);
            var created = await _repository.InsertAsync(newFile);
            await _blobContainer.SaveAsync(id.ToString(), memoryStream.ToArray()).ConfigureAwait(false);
            output.Add(ObjectMapper.Map<Document, DocumentDto>(newFile));
        }

        return output;
    }

    public async Task<FileResult> Get(Guid id)
    {
        var currentFile = _repository.FirstOrDefault(x => x.Id == id);
        if (currentFile != null)
        {
            var myfile = await _blobContainer.GetAllBytesOrNullAsync(id.ToString());
            return new FileContentResult(myfile, currentFile.MimeType);
        }

        throw new FileNotFoundException();
    }
}
```

Repo Link : <https://github.com/antosubash/FileUpload>
]]></content:encoded>
          </item><item>
          <title>Setting up oh-my-posh and PSReadLine in PowerShell</title>
          <link>https://blog.antosubash.com/posts/setting-up-powershell-with-oh-my-posh-v3</link>
          <guid>https://blog.antosubash.com/posts/setting-up-powershell-with-oh-my-posh-v3</guid>
          <pubDate>Wed, 30 Jun 2021 00:00:00 GMT</pubDate>
          <description>In this post we will see how to setup the oh-my-posh and PSReadLine with PowerShell.</description>
          <content:encoded><![CDATA[## Table of contents

## [Oh My Posh](https://ohmyposh.dev)

Oh my is a prompt theme engine for PowerShell. It has many builtin themes and you can also create your own theme if you want. Lets see how you can install it and setup ohmyposh.

### Install in PowerShell Module

```bash
Install-Module oh-my-posh -Scope AllUsers
```

This will install ohmyposh to all the users.

If you are using the older version of the Oh My Posh. please update or uninstall the module.

To update

```bash
Update-Module -Name oh-my-posh
```

To uninstall

```bash
UnInstall-Module -Name oh-my-posh
```

### Install fonts

Oh My Posh uses [Nerd Font](https://www.nerdfonts.com/). It is recommed to use [Meslo Lgm NF](https://github.com/ryanoasis/nerd-fonts/releases/download/v2.1.0/Meslo.zip)

Download the fonts and install install it.

### Setting the font in Windows Terminal

Once the font is installed set the font as a default font in Windows Terminal.

```json
{
  "profiles": {
    "defaults": {
      "fontFace": "MesloLGM NF"
    }
  }
}
```

### View themes and select one you like

```bash
Get-PoshThemes
```

### Import module and set theme

Once you have decided on the theme we can import module and set the theme.

We need to update the PowerShell profile to import and set the theme.

To open the profile use this command.

```bash
notepad.exe $PROFILE
```

This will open the PowerShell profile in notepad.

Update the PowerShell with the following

```bash
Import-Module oh-my-posh
Set-PoshPrompt powerlevel10k_rainbow
```

This will import the Oh My Posh and set the theme.

## Install PSReadLine and PowerShellGet

Before updating PowerShellGet, you should always install the latest NuGet provider. From an elevated PowerShell session, run the following command.

```bash
Install-PackageProvider -Name NuGet -Force
```

### Install or update the PowerShellGet

To install

```bash
Install-Module -Name PowerShellGet -Force
```

To update

```bash
Update-Module -Name PowerShellGet
```

### Install PSReadLine

To install

```bash
Install-Module -Name PSReadLine -AllowPrerelease
```

### Import and configure PSReadLine

Open the powershell profile

```bash
notepad $profile
```

Add the PSReadLine config

```bash
Import-Module PSReadLine
Set-PSReadLineOption -EditMode Windows
Set-PSReadLineOption -PredictionSource History
Set-PSReadLineOption -PredictionViewStyle ListView
Set-PSReadLineOption -PredictionViewStyle InlineView
```

For more config look [here](https://github.com/PowerShell/PSReadLine/blob/master/PSReadLine/SamplePSReadLineProfile.ps1)

### Install Terminal-Icons

To install the module from the PowerShell Gallery:

```bash
Install-Module -Name Terminal-Icons -Repository PSGallery
```

Open the powershell profile

```bash
notepad $profile
```

Import the terminal font

```bash
Import-Module -Name Terminal-Icons
```

Open a new prompt and verify if you the icons with the following command

```bash
Get-ChildItem -Path . -Force
```
]]></content:encoded>
          </item><item>
          <title>Flutter Authentication using OpenID, ABP and IdentityServer4. Part 5</title>
          <link>https://blog.antosubash.com/posts/abp-auth-with-flutter-p5</link>
          <guid>https://blog.antosubash.com/posts/abp-auth-with-flutter-p5</guid>
          <pubDate>Sat, 29 May 2021 00:00:00 GMT</pubDate>
          <description>In this post we will implement the OAuth for the Flutter app.</description>
          <content:encoded><![CDATA[## Table of contents

## Intro

In this post we will implement the OAuth for the Flutter app.

## 1. Adding a new client to the IdentityServer

first step is to create a new client for the nextjs application. list of client is available in the `appsettings.json` file at `DbMigrator` project.

### 1.1 Add the new json entry

```json
"Todos_Flutter_2": {
  "ClientId": "Todos_Flutter_2",
  "RedirectUri": "http://localhost:3000/"
},
```

### 1.2 Update the CreateClientsAsync method

In the `Domain` project there is a `IdentityServerDataSeedContributor` class which has the `CreateClientsAsync` method. This method creates the Identity server clients during the migrations. so we will update this method to include the new json entry.

```cs
// Flutter2 Client
var flutter2Client = configurationSection["Todos_Flutter_2:ClientId"];
if (!flutter2Client.IsNullOrWhiteSpace())
{
    var redirectUrl = configurationSection["Todos_Flutter_2:RedirectUri"];
    await CreateClientAsync(
        name: flutter2Client,
        scopes: commonScopes,
        grantTypes: new[] { "authorization_code" },
        requireClientSecret: false,
        redirectUri: redirectUrl
    );
}
```

### 1.3 Run the migration

Now run the migration to add the client to the DB.

## 2. Exposing localhost using ngrok

`.\ngrok.exe http https://localhost:44354`

## 3. Creating a flutter app

Create the flutter app

```bash
flutter create mytodoapp
```

Move into the folder

```bash
cd mytodoapp
```

List the devices

```bash
flutter devices
```

Run the app

```bash
flutter run
```

## 4. Add dependencies

```yaml
dependencies:
  openid_client: ^0.4.1
  url_launcher: ^6.0.4
```

### 4.1 Update the Android Manifest

Update the android app to use the `usesCleartextTraffic`

you can find the android manifest in `mytodoapp\android\app\src\main`

```xml
<application
    android:usesCleartextTraffic="true"
    android:label="mytodos"
    android:icon="@mipmap/ic_launcher">
```

## 5. Create flutter page to login and logout

```dart
import 'package:flutter/material.dart';
import 'package:openid_client/openid_client.dart';
import 'package:openid_client/openid_client_io.dart';
import 'package:url_launcher/url_launcher.dart';
import 'dart:async';

class HomePage extends StatefulWidget {
  HomePage({Key? key}) : super(key: key);

  @override
  _HomePageState createState() => _HomePageState();
}

class _HomePageState extends State<HomePage> {
  final String _clientId = 'Todos_Flutter_2';
  static const String _issuer = 'https://d78170304b87.ngrok.io';
  final List<String> _scopes = <String>[
    'openid',
    'profile',
    'email',
    'offline_access',
    'Todos'
  ];
  String logoutUrl = "";
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text("Home"),
      ),
      body: Container(
        child: Center(
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.center,
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              ElevatedButton(
                child: Text("Login"),
                onPressed: () async {
                  var tokenInfo = await authenticate(
                      Uri.parse(_issuer), _clientId, _scopes);
                  print(tokenInfo.accessToken);
                },
              ),
              ElevatedButton(
                child: Text("Logout"),
                onPressed: () async {
                  logout();
                },
              ),
            ],
          ),
        ),
      ),
    );
  }

  Future<TokenResponse> authenticate(
      Uri uri, String clientId, List<String> scopes) async {
    // create the client
    var issuer = await Issuer.discover(uri);
    var client = new Client(issuer, clientId);

    // create a function to open a browser with an url
    urlLauncher(String url) async {
      if (await canLaunch(url)) {
        await launch(url, forceWebView: true, enableJavaScript: true);
      } else {
        throw 'Could not launch $url';
      }
    }

    // create an authenticator
    var authenticator = new Authenticator(
      client,
      scopes: scopes,
      urlLancher: urlLauncher,
      port: 3000,
    );

    // starts the authentication
    var c = await authenticator.authorize();
    // close the webview when finished
    closeWebView();

    var res = await c.getTokenResponse();
    setState(() {
      logoutUrl = c.generateLogoutUrl().toString();
    });
    print(res.accessToken);
    return res;
  }

  Future<void> logout() async {
    if (await canLaunch(logoutUrl)) {
      await launch(logoutUrl, forceWebView: true);
    } else {
      throw 'Could not launch $logoutUrl';
    }
    await Future.delayed(Duration(seconds: 2));
    closeWebView();
  }
}
```

## Github Repo Link : <https://github.com/antosubash/Todos>
]]></content:encoded>
          </item><item>
          <title>Application features with dotnet core and ABP. Part 4</title>
          <link>https://blog.antosubash.com/posts/abp-feature-p4</link>
          <guid>https://blog.antosubash.com/posts/abp-feature-p4</guid>
          <pubDate>Mon, 17 May 2021 00:00:00 GMT</pubDate>
          <description>ABP Feature system is used to enable, disable or change the behavior of the application features on runtime.</description>
          <content:encoded><![CDATA[## Table of contents

## Intro

ABP Feature system is used to enable, disable or change the behavior of the application features on runtime.

## Create feature constant

```cs
public static class TodoFeatures
{
    public const string Todo = "Todo";
    public const string MaxTodoPerUser = "MaxTodoPerUser";
}
```

## Create feature definition provider

```cs
public class TodoFeatureDefinitionProvider : FeatureDefinitionProvider
{
    public override void Define(IFeatureDefinitionContext context)
    {
        var myGroup = context.AddGroup("MyTodoApp");

        myGroup.AddFeature(
            TodoFeatures.Todo,
            defaultValue: "false",
            displayName: L("Todo"),
            valueType: new ToggleStringValueType()
        );

        myGroup.AddFeature(
            TodoFeatures.MaxTodoPerUser,
            defaultValue: "10",
            displayName: L("MaxTodoPerUser"),
            valueType: new FreeTextStringValueType(
                            new NumericValueValidator(0, 1000000))
        );
    }

    private static LocalizableString L(string name)
    {
        return LocalizableString.Create<TodosResource>(name);
    }
}
```

## Expose api base on feature

You can use the `RequiresFeature` attribute to restrict access to the api endpoint.

```cs
[RequiresFeature(TodoFeatures.Todo)]
```

## IFeatureChecker service

you can use the FeatureChecker service to check if the feature is enabled or not and get the value of the feature.

```cs
var maxTodoPerUser = await FeatureChecker.GetAsync<int>(TodoFeatures.MaxTodoPerUser);
```

For more info check the official docs : <https://docs.abp.io/en/abp/latest/Features>
]]></content:encoded>
          </item><item>
          <title>Authorization in dotnet core with ABP. Part 3</title>
          <link>https://blog.antosubash.com/posts/abp-authorization-p3</link>
          <guid>https://blog.antosubash.com/posts/abp-authorization-p3</guid>
          <pubDate>Sun, 16 May 2021 00:00:00 GMT</pubDate>
          <description>In this post we will implement the Authorization in ABP with IdentityServer</description>
          <content:encoded><![CDATA[## Table of contents

## Intro

In this post we are going to setup the authorization for the dotnet core ABP app. ABP extends ASP.NET Core Authorization by adding permissions as auto policies.

## Creating permission

In the ABP application the permission are available in the `Contracts` project. Find the Permissions class and add your custom permission.

```cs
public static class Todo
{
    public const string Default = GroupName + ".Todo";
    public const string Create = Default + ".Create";
    public const string Update = Default + ".Update";
    public const string Delete = Default + ".Delete";
}
```

## Define permission

`PermissionDefinitionProvider` is where you have to define the permissions.

```cs
var myGroup = context.AddGroup(TodosPermissions.GroupName);

var todoPermission = myGroup.AddPermission(TodosPermissions.Todo.Default, L("Permission:Default"));
todoPermission.AddChild(TodosPermissions.Todo.Create, L("Permission:Create"));
todoPermission.AddChild(TodosPermissions.Todo.Update, L("Permission:Update"));
todoPermission.AddChild(TodosPermissions.Todo.Delete, L("Permission:Delete"));
```

## Protecting api endpoint based on permission

Once the permission is defined now we can create use the `Authorize` attribute to enforce the permission

```cs
[Authorize(TodosPermissions.Todo.Default)]
public async Task<List<TodoDto>> GetAll()
{
    return ObjectMapper.Map<List<Todo>, List<TodoDto>>(await todoRepository.GetListAsync());
}
```

In the above code we have added the default permission to the getAll api call.

## Checking permission

ASP.NET Core provides the `IAuthorizationService` that can be used to check for authorization. Once you inject, you can use it in your code to conditionally control the authorization.

```cs
var result = await AuthorizationService
    .AuthorizeAsync(TodosPermissions.Todo.Default);
if (result.Succeeded == false)
{
    //throw exception
    throw new AbpAuthorizationException("...");
}
```

or

```cs
await AuthorizationService.CheckAsync(TodosPermissions.Todo.Default);
```

For more info check the official docs : <https://docs.abp.io/en/abp/latest/Authorization>
]]></content:encoded>
          </item><item>
          <title>SPA Authentication using Next.js, ABP and IdentityServer4. Part 2</title>
          <link>https://blog.antosubash.com/posts/abp-auth-with-nextjs-p2</link>
          <guid>https://blog.antosubash.com/posts/abp-auth-with-nextjs-p2</guid>
          <pubDate>Sat, 06 Mar 2021 00:00:00 GMT</pubDate>
          <description>In this post we will implement the SPA authentication for the Nexjs.js app as the frontend and ABP with IdentityServer as Backend</description>
          <content:encoded><![CDATA[## Table of contents

## Intro

In this post we will see how to create a Identity server Client and configure it to implement authenticate for the Next.js Application.

## 1. Adding a new client to the IdentityServer

first step is to create a new client for the nextjs application. list of client is available in the `appsettings.json` file at `DbMigrator` project.

### 1.1 Add the new json entry

```json
"Todos_Spa_1": {
    "ClientId": "Todos_Spa_1",
    "ClientSecret": "1q2w3e*",
    "RootUrl": "http://localhost:3000"
},
```

### 1.2 Update the CreateClientsAsync method

In the `Domain` project there is a `IdentityServerDataSeedContributor` class which has the `CreateClientsAsync` method. This method creates the Identity server clients during the migrations. so we will update this method to include the new json entry.

```cs
// React Client
var reactClient = configurationSection["Todos_Spa_1:ClientId"];
if (!reactClient.IsNullOrWhiteSpace())
{
    var webClientRootUrl = configurationSection["Todos_Spa_1:RootUrl"]?.TrimEnd('/');

    await CreateClientAsync(
        name: reactClient,
        scopes: commonScopes,
        grantTypes: new[] { "client_credentials", "authorization_code" },
        secret: (configurationSection["Todos_Spa_1:ClientSecret"] ?? "1q2w3e*").Sha256(),
        requireClientSecret: false,
        redirectUri: $"{webClientRootUrl}/authentication/login-callback/identity-server4",
        postLogoutRedirectUri: $"{webClientRootUrl}",
        corsOrigins: new[] { webClientRootUrl.RemovePostFix("/") }
    );
}
```

### 1.3 Run the migration

Now run the migration to add the client to the DB.

## 2. Create Next.js App

```bash
yarn create next-app
```

## 3. Add next-auth package

```bash
yarn add next-auth
```

## 4. Add .env file

```bash
NEXTAUTH_URL=http://localhost:3000
NEXT_PUBLIC_API_URL=https://localhost:44391
IdentityServer4_Domain=localhost:44354
IdentityServer4_CLIENT_ID=Todos_Spa_1
IdentityServer4_CLIENT_SECRET="1q2w3e*"
NODE_TLS_REJECT_UNAUTHORIZED=0
```

`NEXT_PUBLIC_API_URL` is the ABP application url.

`NEXTAUTH_URL` is the nextjs app url.

`NODE_TLS_REJECT_UNAUTHORIZED` is set to 0 to work with ssl in localhost.

## 5. Setup next-auth

create a `/pages/api/auth/[...nextauth].js` and add the following

```js
import NextAuth from "next-auth";
import Providers from "next-auth/providers";

export default NextAuth({
  // Configure one or more authentication providers
  providers: [
    Providers.IdentityServer4({
      id: "identity-server4",
      name: "IdentityServer4",
      scope: "openid profile email Todos offline_access", // Allowed Scopes
      domain: process.env.IdentityServer4_Domain,
      clientId: process.env.IdentityServer4_CLIENT_ID,
      clientSecret: process.env.IdentityServer4_CLIENT_SECRET,
    }),
  ],
  callbacks: {
    /**
     * @param  {object} session      Session object
     * @param  {object} token        User object    (if using database sessions)
     *                               JSON Web Token (if not using database sessions)
     * @return {object}              Session that will be returned to the client
     */
    async session(session, token) {
      // Add property to session, like an access_token from a provider.
      session.accessToken = token.accessToken;
      return session;
    },

    async jwt(token, user, account, profile, isNewUser) {
      // Add access_token to the token right after signin
      if (account?.accessToken) {
        token.accessToken = account.accessToken;
      }
      return token;
    },
  },
});
```

## 6. Create login Component

```js
import React from "react";
import { signIn, signOut, useSession } from "next-auth/client";
function Login() {
  const [session, loading] = useSession();

  return (
    <>
      {!session && (
        <>
          Not signed in <br />
          <button onClick={() => signIn("identity-server4")}>Sign in</button>
        </>
      )}
      {session && (
        <>
          Signed in as {session.user.email} <br />
          <button onClick={() => signOut()}>Sign out</button>
        </>
      )}
    </>
  );
}

export default Login;
```

## 7. Render the login component

Now you can render the login component in any page to trigger the auth.

`<Login></Login>`

## Github Repo Link : <https://github.com/antosubash/Todos>
]]></content:encoded>
          </item><item>
          <title>ABP Getting Started With .Net Core and EF Core. ABP Part 1</title>
          <link>https://blog.antosubash.com/posts/abp-getting-started-p1</link>
          <guid>https://blog.antosubash.com/posts/abp-getting-started-p1</guid>
          <pubDate>Fri, 05 Mar 2021 00:00:00 GMT</pubDate>
          <description>This is an introduction to the ABP Application framework with .Net core and EF core. I have created a Todo App with a CRUD function.</description>
          <content:encoded><![CDATA[## Table of contents

## Intro

In this post we will see how to create a CRUD API in ABP Application framework with dotnet core and ef core. It will be simple Todo api.

You can watch the videos or continue with the post.

[![IMAGE ALT TEXT HERE](https://img.youtube.com/vi/m8pjAtmpmBI/0.jpg)](https://www.youtube.com/watch?v=m8pjAtmpmBI)

## Preparing the Project

Use the Getting started at <https://docs.abp.io/en/abp/latest/getting-started?ui=mvc&db=ef&tiered=no> guide to setup the basic abp application

## 1. Create an [Entity](https://docs.abp.io/en/abp/latest/Entities)

First step is to create an Entity. Create the Entity in the `Domain` project

```cs
public class Todo : Entity<Guid>
{
    public string Content { get; set; }
    public bool IsDone { get; set; }
}
```

## 2. Add Entity to [ef core](https://docs.abp.io/en/abp/latest/Entity-Framework-Core)

Next is to add Entity to the EF Core. you will find the DbContext in the `EntityFrameworkCore` project. Add the DbSet to the DbContext

```cs
public DbSet<Todo> Todos { get; set; }
```

## 3. Configure Entity in [ef core](https://docs.abp.io/en/abp/latest/Entity-Framework-Core#configurebyconvention-method)

Configuration is done in the `DbContextModelCreatingExtensions` class. This should be available in the `EntityFrameworkCore` project

```cs
builder.Entity<Todo>(b =>
{
    b.ToTable(TodosConsts.DbTablePrefix + "Todos", TodosConsts.DbSchema);
    b.ConfigureByConvention(); //auto configure for the base class props
});
```

## 4. Adding Migrations

Now the Entity is configured we can add the migrations.

Go the `EntityFrameworkCore.DbMigrations` project in the terminal and create migrations.

To create migration run this command:

```bash
dotnet ef migrations add created_todo
```

Verify the migrations created in the migrations folder.

To update the database run this command

```bash
dotnet ef database update
```

## 5. Create a Entity Dto

Dto are placed in `Contracts` project

```cs
public class TodoDto : EntityDto<Guid>
{
    public string Content { get; set; }
    public bool IsDone { get; set; }
}
```

## 6. Map Entity to Dto

Abp uses AutoMapper to map Entity to Dto. you can find the `ApplicationAutoMapperProfile` file which is used by the AutoMapper in the `Application` project.

```cs
CreateMap<Todo, TodoDto>();
CreateMap<TodoDto, Todo>();
```

## 7. Create an [Application Services](https://docs.abp.io/en/abp/latest/Application-Services)

Application service are created in the `Application` project

```cs
public class TodoAppService : YourProjectAppService
{
    private readonly IRepository<Todo, Guid> todoRepository;

    public TodoAppService(IRepository<Todo, Guid> todoRepository)
    {
        this.todoRepository = todoRepository;
    }

    public async Task<List<TodoDto>> GetAll()
    {
        return ObjectMapper.Map<List<Todo>, List<TodoDto>>(await todoRepository.GetListAsync());
    }

    public async Task<TodoDto> CreateAsync(TodoDto todoDto)
    {
        var todo = ObjectMapper.Map<TodoDto, Todo>(todoDto);
        var createdTodo = await todoRepository.InsertAsync(todo);
        return ObjectMapper.Map<Todo, TodoDto>(createdTodo);
    }

    public async Task<TodoDto> UpdateAsync(TodoDto todoDto)
    {
        var todo = ObjectMapper.Map<TodoDto, Todo>(todoDto);
        var createdTodo = await todoRepository.UpdateAsync(todo);
        return ObjectMapper.Map<Todo, TodoDto>(createdTodo);
    }

    public async Task<bool> DeleteAsync(Guid id)
    {
        var todo = await todoRepository.FirstOrDefaultAsync(x=> x.Id == id);
        if(todo != null)
        {
            await todoRepository.DeleteAsync(todo);
            return true;
        }
        return false;
    }
}
```

Once you created the Application configuration ABP can automatically configure your service as API controllers by conventions.

## Github Repo Link : <https://github.com/antosubash/Todos>
]]></content:encoded>
          </item><item>
          <title>Docker swarm setup for localhost</title>
          <link>https://blog.antosubash.com/posts/docker-swarm-localhost</link>
          <guid>https://blog.antosubash.com/posts/docker-swarm-localhost</guid>
          <pubDate>Sat, 26 Dec 2020 00:00:00 GMT</pubDate>
          <description>In this post we will see how to setup docker swarm for localhost.</description>
          <content:encoded><![CDATA[## Table of contents

Most of the stack used here are available in my github [repo](https://github.com/antosubash/docker_stack).

## My docker localhost setup

This is my localhost setup.

## Enable swarn mode

`docker swarm init`

## protainer deployment

`docker stack deploy --compose-file=portainer-agent-stack.yml portainer`

## MySql Volume

`docker volume create mysql1`

## Postgres Volume

`docker volume create postgres`

## Mongo Volume

`docker volume create mongo1`

## deploy mysql stack

`docker stack deploy --compose-file=mysql_stack.yml mysql`

## deploy mongodb stack

`docker stack deploy --compose-file=mongo_stack.yml mongo`

## deploy postgres stack

`docker stack deploy --compose-file=postgres_stack.yml postgres`

## docker see the services

`docker service ls`
]]></content:encoded>
          </item><item>
          <title>Set up Wsl with zsh and oh-my-zsh</title>
          <link>https://blog.antosubash.com/posts/setup-zsh-and-oh-my-zsh</link>
          <guid>https://blog.antosubash.com/posts/setup-zsh-and-oh-my-zsh</guid>
          <pubDate>Sat, 12 Dec 2020 00:00:00 GMT</pubDate>
          <description>In this post we will see how to setup zsh shell in the wsl and use oh-my-zsh.</description>
          <content:encoded><![CDATA[## Table of contents

In this post we will see how can we install and setup up zsh shell and use oh-my-posh with it in wsl ubuntu.

## Setup Z Shell

### Install the Z shell and git

```bash
sudo apt install zsh
sudo apt install git
```

### Check the Z shell version

```bash
zsh --version
```

### Change the default shell

```bash
chsh -s $(which zsh)
```

## Log out and login again to use the new default shell

### Check the current shell

```bash
echo $SHELL // Expected result: /bin/zsh
```

### Install Oh My Zsh

```bash
sh -c "$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)"
```

## Install zsh-autosuggestions and zsh-syntax-highlighting

### Set up zsh-syntax-highlighting

1. Clone this repository into `$ZSH_CUSTOM/plugins` (by default `~/.oh-my-zsh/custom/plugins`):

```zsh
git clone https://github.com/zsh-users/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting
```

### Set up zsh-autosuggestions

1. Clone this repository into `$ZSH_CUSTOM/plugins` (by default `~/.oh-my-zsh/custom/plugins`)

```sh
git clone https://github.com/zsh-users/zsh-autosuggestions ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-autosuggestions
```

### Plugins

Oh My Zsh comes with a shitload of plugins for you to take advantage of. You can take a look in the [plugins](https://github.com/ohmyzsh/ohmyzsh/tree/master/plugins) directory and/or the [wiki](https://github.com/ohmyzsh/ohmyzsh/wiki/Plugins) to see what's currently available.

#### Enabling Plugins

Once you spot a plugin (or several) that you'd like to use with Oh My Zsh, you'll need to enable them in the `.zshrc` file. You'll find the zshrc file in your `$HOME` directory. Open it with your favorite text editor and you'll see a spot to list all the plugins you want to load.

```shell
vi ~/.zshrc
```

For example, this might begin to look like this:

```shell
plugins=(
  git
  zsh-autosuggestions
  zsh-syntax-highlighting
)
```

### Load the config

```sh
source ~/.zshrc
```
]]></content:encoded>
          </item><item>
          <title>Set up Windows Terminal with PoshGit, oh-my-posh and Cascadia Code PL</title>
          <link>https://blog.antosubash.com/posts/setup-window-terminal-with-poshgit</link>
          <guid>https://blog.antosubash.com/posts/setup-window-terminal-with-poshgit</guid>
          <pubDate>Sat, 05 Dec 2020 00:00:00 GMT</pubDate>
          <description>In this post we will see how to setup windows terminal with PoshGit and oh-my-posh to make the terminal more productive</description>
          <content:encoded><![CDATA[## Table of contents

## Set up Windows Terminal with PoshGit, oh-my-posh and Cascadia Code PLi

You can watch a videos of how to setup or continue with the post.

[![IMAGE ALT TEXT HERE](https://img.youtube.com/vi/cJ7oINPF2mo/0.jpg)](https://www.youtube.com/watch?v=cJ7oINPF2mo)

There are few ways to install the window terminal. The easy way is to install from the [windows store](https://aka.ms/terminal). There are few other ways available.

Via [WinGet][winget] (official package manager for Windows):

```powershell
winget install --id=Microsoft.WindowsTerminal -e
```

Via [Chocolatey][chocolatey]:

```powershell
choco install microsoft-windows-terminal
```

Via [Scoop][scoop]:

```powershell
scoop install windows-terminal
```

Once the terminal is installed then you have to install 2 important powershell modules they are `posh-git` and `oh-my-posh`. **Make sure you open the terminal as Administrator**

```bash
Install-Module posh-git -Scope CurrentUser
Install-Module oh-my-posh -Scope CurrentUser
```

Once module is installed then we have to import the module. We will do this in the powershell profile.

To open the profile type

```bash
if (!(Test-Path -Path $PROFILE )) { New-Item -Type File -Path $PROFILE -Force }
notepad $PROFILE
```

The above command will check if the profile is already available. if it is not available then it will create one for you. Once created we can open this in the notepad. once the notepad is opened append the following.

```bash
Import-Module posh-git
Import-Module oh-my-posh
Set-Theme Paradox
```

This will be executed before you open the powershell. we are importing the powershell modules and setting a theme for our powershell.

Now we have to install the font [Cascadia Code PL](https://github.com/microsoft/cascadia-code/releases). You can get it from here https://github.com/microsoft/cascadia-code/releases

Once the font is installed you can set the font in the [profile settings](https://docs.microsoft.com/en-us/windows/terminal/customize-settings/profile-settings).

here is the sample

```json
{
    // Make changes here to the powershell.exe profile.
    "guid": "{61c54bbd-c2c6-5271-96e7-009a87ff44bf}",
    "name": "Windows PowerShell",
    "commandline": "powershell.exe",
    "fontFace": "Cascadia Code PL",
    "hidden": false
},
```

[scoop]: https://scoop.sh/
[scoop-extras]: https://github.com/lukesampson/scoop/wiki/Buckets
[windowsterminal]: https://github.com/microsoft/terminal
[winget]: https://github.com/microsoft/winget-cli/
[chocolatey]: https://chocolatey.org/
]]></content:encoded>
          </item><item>
          <title>Css for leaflet div element</title>
          <link>https://blog.antosubash.com/posts/css-for-leaflet-div-element</link>
          <guid>https://blog.antosubash.com/posts/css-for-leaflet-div-element</guid>
          <pubDate>Mon, 21 Sep 2020 00:00:00 GMT</pubDate>
          <description>If you are like me who struggle with anything CSS. These are some small css that will help you to fill the leaflet map without setting the fixed height</description>
          <content:encoded><![CDATA[
## Css for the leaflet div

There are a few times when I set the div height to 100% the leaflet map is empty. This is mostly because the div is not fully occupying the entries space available. These are some CSS snippets I use during those times.

### To fill the entire page

```css
#map {
  height: 100vh;
  width: 100vw;
}
```

### To fill the entire div

```css
#map {
  position: absolute;
  top: 0;
  bottom: 0;
  left: 0;
  right: 0;
}
```

## Using CSS calc

Most of the times there will be a Top bar or a Sidebar available in the map during these times the `calc` function in the css will come in handy. lets assume you have side bar which is `100px` and top bar which is `60px` you can use something like below.

```css
#map {
  width: calc(100vw - 100px);
  height: calc(100vh - 60px);
  margin-top: 60px;
  margin-left: 100px;
}
```
]]></content:encoded>
          </item><item>
          <title>Setup docker in Ubuntu 18.04</title>
          <link>https://blog.antosubash.com/posts/setup-docker-node-hetzner</link>
          <guid>https://blog.antosubash.com/posts/setup-docker-node-hetzner</guid>
          <pubDate>Thu, 17 Sep 2020 07:35:07 GMT</pubDate>
          <description>In this post you will see how to setup docker in Ubuntu 18.04. We will also change the default ssh port and install fail2ban.</description>
          <content:encoded><![CDATA[## Table of contents

## Adding new user

```bash
adduser docker-login
usermod -aG sudo docker-login
su - docker-login
```

## Changing ssh

```bash
nano /etc/ssh/sshd_config

ClientAliveInterval 300
ClientAliveCountMax 1
AllowUsers root docker-login
Port 234
MaxAuthTries 5
AllowTcpForwarding no                   # Disables port forwarding.
AllowAgentForwarding no                 # Disables the forwarding of the SSH login.
```

## Refresh and restart

```bash

sshd -t

systemctl restart sshd
```

## Fail2ban

```bash
apt install fail2ban
systemctl enable fail2ban

cp /etc/fail2ban/jail.conf /etc/fail2ban/jail.local

nano /etc/fail2ban/jail.local

enabled = true
port = 234

systemctl restart fail2ban
```

## Install Docker

```bash
sudo apt update

sudo apt install apt-transport-https ca-certificates curl software-properties-common

curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -
sudo add-apt-repository "deb [arch=amd64] https://download.docker.com/linux/ubuntu bionic stable"
sudo apt update
apt-cache policy docker-ce
sudo apt install docker-ce
sudo systemctl status docker
sudo systemctl enable docker
sudo usermod -aG docker ${USER}
su - ${USER}
id -nG
sudo usermod -aG docker docker-login
docker
```
]]></content:encoded>
          </item><item>
          <title>Traefik setup with docker swarm</title>
          <link>https://blog.antosubash.com/posts/setup-traefik-docker</link>
          <guid>https://blog.antosubash.com/posts/setup-traefik-docker</guid>
          <pubDate>Thu, 17 Sep 2020 05:35:07 GMT</pubDate>
          <description>In this post you will see how to setup traefik with docker swarm. Along with that we will also setup Portainer and Swarmpit so that it is easy to manage the docker swarm.</description>
          <content:encoded><![CDATA[## Table of contents

## Docker swarm init

```bash
docker swarm init --advertise-addr 10.0.0.3
```

## Create a traefik network

```bash
docker network create --driver overlay traefik-public
```

## Create a htpasswd password

```bash
docker run --rm httpd:2.4-alpine htpasswd -nbB admin <password> | cut -d ":" -f 2
```

Escape the $ sign in the password by adding one more $

## Create folders

### for Traefik

create a folder and set 600 as permission.

```bash
mkdir /home/docker-login/data/traefik
touch /home/docker-login/data/traefik/acme.json
chmod 600 /home/docker-login/data/traefik/acme.json
```

### for Swarmpit

```bash
mkdir /home/docker-login/data/db-data
mkdir /home/docker-login/data/influx-data
```

### for Portainer

```bash
mkdir /mnt/volume2/portainer
```

## Traefik docker compose yml

Sample yml

```yml
version: "3.3"

services:
  traefik:
    image: "traefik:v2.1.4"
    command:
      - --log.level=INFO
      - --entrypoints.web.address=:80
      - --entrypoints.websecure.address=:443
      - --providers.docker
      - --providers.docker.exposedbydefault=false
      - --providers.docker.swarmmode=true
      - --providers.docker.network=traefik-public
      - --api
      - --api.dashboard=true
      - --certificatesresolvers.leresolver.acme.caserver=https://acme-v02.api.letsencrypt.org/directory
      # update your email here
      - --certificatesresolvers.leresolver.acme.email=youremail@test.com
      # Make sure the this file is available and permission is set correctly
      - --certificatesresolvers.leresolver.acme.storage=/le/acme.json
      - --certificatesresolvers.leresolver.acme.tlschallenge=true
    ports:
      - "80:80"
      - "443:443"
    networks:
      - traefik-public
    volumes:
      - "/var/run/docker.sock:/var/run/docker.sock:ro"
      # Make sure the volume folder is created
      - "/home/docker-login/data/traefik/acme.json:/le/acme.json"
    deploy:
      labels:
        # Dashboard
        - "traefik.enable=true"
        # Change the host url here
        - "traefik.http.routers.traefik.rule=Host(`traefik.example.com`)"
        - "traefik.http.routers.traefik.service=api@internal"
        - "traefik.http.services.traefik.loadbalancer.server.port=8080"
        - "traefik.http.routers.traefik.tls.certresolver=leresolver"
        - "traefik.http.routers.traefik.entrypoints=websecure"
        - "traefik.http.routers.traefik.middlewares=authtraefik"
        # Change the auth password here
        - "traefik.http.middlewares.authtraefik.basicauth.users=admin:yournewpassword" # user/password

        # global redirect to https
        - "traefik.http.routers.http-catchall.rule=hostregexp(`{host:.+}`)"
        - "traefik.http.routers.http-catchall.entrypoints=web"
        - "traefik.http.routers.http-catchall.middlewares=redirect-to-https"

        # middleware redirect
        - "traefik.http.middlewares.redirect-to-https.redirectscheme.scheme=https"

  my-app:
    image: containous/whoami:v1.3.0
    networks:
      - traefik-public
    command:
      - --port=8082 # Our service listens on 8082
    deploy:
      labels:
        - "traefik.enable=true"
        # Change the host url here
        - "traefik.http.routers.my-app.rule=Host(`whoami.example.com`)"
        - "traefik.http.services.my-app.loadbalancer.server.port=8082"
        - "traefik.http.routers.my-app.middlewares=auth"
        - "traefik.http.routers.my-app.entrypoints=websecure"
        - "traefik.http.routers.my-app.tls=true"
        - "traefik.http.routers.my-app.tls.certresolver=leresolver"
        # Change the password here
        - "traefik.http.middlewares.auth.basicauth.users=admin:changeme" # user/password

networks:
  traefik-public:
    external: true
```

## Swarmpit Docker compose

Make sure the service name for swarmpit is "app"

```yml
version: "3.3"

services:
  app:
    image: swarmpit/swarmpit:latest
    environment:
      - SWARMPIT_DB=http://db:5984
      - SWARMPIT_INFLUXDB=http://influxdb:8086
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock:ro
    networks:
      - traefik-public
    deploy:
      labels:
        - "traefik.enable=true"
        # change the host name here
        - "traefik.http.routers.app.rule=Host(`swarm.example.com`)"
        - "traefik.http.services.app.loadbalancer.server.port=8080"
        - "traefik.http.routers.app.tls=true"
        - "traefik.http.routers.app.tls.certresolver=leresolver"
        - "traefik.docker.network=traefik-public"
      resources:
        limits:
          cpus: "0.50"
          memory: 1024M
        reservations:
          cpus: "0.25"
          memory: 512M
      placement:
        constraints:
          - node.role == manager

  db:
    image: couchdb:2.3.0
    volumes:
      # make sure the folder is available
      - /home/docker-login/data/db-data:/opt/couchdb/data
    networks:
      - traefik-public
    deploy:
      resources:
        limits:
          cpus: "0.30"
          memory: 256M
        reservations:
          cpus: "0.15"
          memory: 128M

  influxdb:
    image: influxdb:1.7
    volumes:
      # make sure the folder is available
      - /home/docker-login/data/influx-data:/var/lib/influxdb
    networks:
      - traefik-public
    deploy:
      resources:
        limits:
          cpus: "0.60"
          memory: 512M
        reservations:
          cpus: "0.30"
          memory: 128M

  agent:
    image: swarmpit/agent:latest
    environment:
      - DOCKER_API_VERSION=1.35
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock:ro
    networks:
      - traefik-public
    deploy:
      mode: global
      labels:
        swarmpit.agent: "true"
      resources:
        limits:
          cpus: "0.10"
          memory: 64M
        reservations:
          cpus: "0.05"
          memory: 32M

networks:
  traefik-public:
    external: true
```

## Portainer

```yml
version: "3.2"

services:
  agent:
    image: portainer/agent
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock
      - /var/lib/docker/volumes:/var/lib/docker/volumes
    networks:
      - traefik-public
    deploy:
      mode: global
      placement:
        constraints: [node.platform.os == linux]

  portainer:
    image: portainer/portainer
    command: -H tcp://tasks.agent:9001 --tlsskipverify
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock
      # make sure the folder is available
      - /mnt/volume2/portainer:/data
    networks:
      - traefik-public
    deploy:
      labels:
        - "traefik.enable=true"
        # change the host here
        - "traefik.http.routers.portainer.rule=Host(`admin.example.com`)"
        - "traefik.http.services.portainer.loadbalancer.server.port=9000"
        - "traefik.http.routers.portainer.entrypoints=websecure"
        - "traefik.http.routers.portainer.tls=true"
        - "traefik.http.routers.portainer.tls.certresolver=leresolver"
      mode: replicated
      placement:
        constraints: [node.role == manager]

networks:
  traefik-public:
    external: true
```
]]></content:encoded>
          </item>
        </channel>
        </rss>